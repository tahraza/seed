# Système d'Exploitation

> "Un OS est ce qui reste quand on a enlevé tout ce qui est utile." — Ken Thompson

Félicitations ! Vous avez construit le matériel, l'assembleur et le compilateur. Votre machine nand2c est fonctionnelle. Mais pour l'instant, chaque programmeur doit réinventer la roue : comment dessiner un cercle ? Comment lire une chaîne de caractères ? Comment gérer la mémoire dynamiquement ?

Dans ce chapitre, nous allons construire un **Système d'Exploitation** minimal qui simplifie l'accès au matériel et fournit des services essentiels.

---

## Où en sommes-nous ?

![Position dans l'architecture](images/architecture-stack.svg)

*Nous sommes à la Couche 6 : Système d'Exploitation - Le sommet de la pyramide logicielle !*

```
┌─────────────────────────────────────────┐
│         APPLICATIONS                     │  ← Vous écrivez ici
├─────────────────────────────────────────┤
│    SYSTÈME D'EXPLOITATION               │  ← Ce chapitre
│    malloc, screen, keyboard, string     │
├─────────────────────────────────────────┤
│         COMPILATEUR C32                 │  ← Chapitre 7-8
├─────────────────────────────────────────┤
│         ASSEMBLEUR A32                  │  ← Chapitre 6
├─────────────────────────────────────────┤
│            CPU + RAM                    │  ← Chapitre 3-5
├─────────────────────────────────────────┤
│         PORTES LOGIQUES                 │  ← Chapitre 1-2
└─────────────────────────────────────────┘
```

---

## Qu'est-ce qu'un Système d'Exploitation ?

### Définition

Un **système d'exploitation** (OS) est la couche logicielle qui :

1. **Gère les ressources matérielles** (CPU, mémoire, périphériques)
2. **Fournit des abstractions** aux programmes (fichiers, processus, fenêtres)
3. **Isole les programmes** les uns des autres (protection)
4. **Offre des services** via des appels système (syscalls)

### Les fonctions d'un OS complet

| Fonction | Description | Dans nand2c ? |
|:---------|:------------|:------------:|
| **Gestion mémoire** | Allouer/libérer la mémoire | ✓ Oui |
| **Graphiques** | Dessiner à l'écran | ✓ Oui |
| **Entrées** | Lire le clavier | ✓ Oui |
| **Sorties** | Afficher du texte | ✓ Oui |
| **Chaînes** | Manipuler du texte | ✓ Oui |
| **Mathématiques** | Fonctions avancées | ✓ Oui |
| **Fichiers** | Sauvegarder des données | ✗ Non |
| **Réseau** | Communication | ✗ Non |
| **Multitâche** | Plusieurs programmes | Basique |
| **Protection** | Isolation mémoire | ✗ Non |

Notre OS nand2c est un **OS minimal** orienté vers l'apprentissage. Il n'a pas de système de fichiers ni de protection mémoire, mais il illustre les concepts fondamentaux.

### Architecture de notre OS

```
┌─────────────────────────────────────────────────────────┐
│                    APPLICATIONS                          │
│              (snake.c, shell.c, ...)                    │
├─────────────────────────────────────────────────────────┤
│                   BIBLIOTHÈQUES OS                       │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐       │
│  │  Mem    │ │ Screen  │ │Keyboard │ │ String  │       │
│  │ malloc  │ │draw_*   │ │ read    │ │ strlen  │       │
│  │ free    │ │print    │ │ wait    │ │ strcpy  │       │
│  └─────────┘ └─────────┘ └─────────┘ └─────────┘       │
│  ┌─────────┐ ┌─────────┐ ┌─────────┐                   │
│  │  Math   │ │ Output  │ │  Sys    │                   │
│  │ abs     │ │ putchar │ │ halt    │                   │
│  │ sqrt    │ │ print_* │ │ error   │                   │
│  └─────────┘ └─────────┘ └─────────┘                   │
├─────────────────────────────────────────────────────────┤
│                    MATÉRIEL (MMIO)                       │
│           Screen: 0x00400000   Keyboard: 0x00402600     │
└─────────────────────────────────────────────────────────┘
```

---

## Le Bootstrap : Comment l'OS Démarre

### Le problème du démarrage

Quand le CPU démarre, il ne connaît rien :
- Pas de système d'exploitation
- Pas de notion de "programme"
- Juste : "lire l'instruction à l'adresse 0x0000 et l'exécuter"

### La séquence de démarrage

```
1. Reset du CPU
   ↓
2. PC = 0x00000000
   ↓
3. Fetch première instruction
   ↓
4. Code de bootstrap (notre "BIOS")
   - Initialise la pile (SP)
   - Initialise le tas (heap)
   - Appelle main()
   ↓
5. Programme utilisateur s'exécute
```

### Le code de bootstrap

```asm
; Bootstrap - Première instruction exécutée
.text
.global _start

_start:
    ; 1. Initialiser le Stack Pointer
    MOV SP, #0x00100000     ; Pile en haut de la RAM

    ; 2. Initialiser les variables globales à 0
    BL __init_bss

    ; 3. Initialiser le tas (heap)
    BL __init_heap

    ; 4. Appeler main()
    BL main

    ; 5. Si main() retourne, arrêter le CPU
    SVC #0x10               ; syscall: halt

__init_bss:
    ; Mettre à zéro la section .bss (variables non initialisées)
    LDR R0, =__bss_start
    LDR R1, =__bss_end
    MOV R2, #0
.Lloop:
    CMP R0, R1
    B.GE .Ldone
    STR R2, [R0]
    ADD R0, R0, #4
    B .Lloop
.Ldone:
    BX LR
```

### La carte mémoire

```
0x00000000 ┌─────────────────────────┐
           │      Code (.text)        │  Instructions du programme
0x00100000 ├─────────────────────────┤
           │    Données (.data)       │  Variables initialisées
           ├─────────────────────────┤
           │      BSS (.bss)          │  Variables non initialisées
           ├─────────────────────────┤
           │        HEAP              │  Allocation dynamique (malloc)
           │          ↓               │  Grandit vers le bas
           │                          │
           │          ↑               │
           │        STACK             │  Pile (variables locales)
0x00200000 ├─────────────────────────┤
           │      (Libre)             │
0x00400000 ├─────────────────────────┤
           │    SCREEN (MMIO)         │  320×240 pixels, 1 bit/pixel
0x00402600 ├─────────────────────────┤
           │   KEYBOARD (MMIO)        │  Registre clavier
0xFFFF0000 ├─────────────────────────┤
           │    OUTPUT (MMIO)         │  Sortie console
0xFFFFFFFF └─────────────────────────┘
```

---

## Gestion de la Mémoire

### Le problème

Jusqu'à présent, nous avons utilisé :
- **Variables globales** : taille fixée à la compilation
- **Variables locales** : sur la pile, libérées automatiquement

```c
int buffer[100];        // Global : 100 éléments, toujours
void foo() {
    int temp[10];       // Local : 10 éléments, durée de foo()
}
```

Mais que faire si on veut :
- Allouer une taille **inconnue à la compilation** ?
- Garder des données **au-delà de la fonction** ?
- Créer des **structures de données dynamiques** (listes, arbres) ?

**Solution** : L'allocation dynamique avec `malloc()` et `free()`.

### Le Tas (Heap)

Le **tas** est une zone mémoire gérée dynamiquement :

```
           Avant malloc(100)              Après malloc(100)
          ┌─────────────────┐           ┌─────────────────┐
          │                 │           │                 │
          │   LIBRE         │           │   LIBRE         │
          │                 │           ├─────────────────┤
          │                 │           │  100 octets     │ ← retourné
heap_ptr→ ├─────────────────┤           ├─────────────────┤
          │                 │  heap_ptr→│                 │
          │   (pile, etc.)  │           │   (pile, etc.)  │
          └─────────────────┘           └─────────────────┘
```

### Allocateur "Bump" (Version Simple)

L'allocateur le plus simple : un pointeur qui avance.

```c
// Variables globales de l'allocateur
char* heap_start = (char*)0x00110000;  // Début du tas
char* heap_end   = (char*)0x001F0000;  // Fin du tas
char* heap_ptr;                         // Position actuelle

void heap_init() {
    heap_ptr = heap_start;
}

void* malloc(int size) {
    // Vérifier qu'il reste de la place
    if (heap_ptr + size > heap_end) {
        return 0;  // NULL - plus de mémoire !
    }

    // Aligner sur 4 octets (important pour les performances)
    size = (size + 3) & ~3;

    // Réserver l'espace
    void* result = heap_ptr;
    heap_ptr = heap_ptr + size;

    return result;
}

void free(void* ptr) {
    // Ne fait rien !
    // La mémoire n'est jamais récupérée.
}
```

**Avantages** :
- Très simple à implémenter
- Très rapide (O(1))
- Pas de fragmentation

**Inconvénients** :
- La mémoire libérée n'est jamais réutilisée
- Fuite mémoire garantie à long terme

**Utilisation idéale** : Programmes courts où on alloue beaucoup mais libère peu.

### Allocateur par Liste Libre (Version Avancée)

Pour réutiliser la mémoire, on maintient une **liste des blocs libres**.

#### Structure d'un bloc

```
┌──────────────────────────────────────┐
│ size (4 octets) │ next (4 octets)   │  En-tête (8 octets)
├──────────────────────────────────────┤
│                                      │
│           Données utilisateur        │  size octets
│                                      │
└──────────────────────────────────────┘
```

#### Implémentation

```c
typedef struct Block {
    int size;              // Taille des données (sans l'en-tête)
    struct Block* next;    // Prochain bloc libre (ou NULL)
} Block;

Block* free_list = 0;      // Liste des blocs libres
char* heap_ptr;            // Pour les nouvelles allocations

void heap_init() {
    heap_ptr = (char*)0x00110000;
    free_list = 0;
}

void* malloc(int size) {
    // Aligner sur 8 octets
    size = (size + 7) & ~7;

    // 1. Chercher un bloc libre de taille suffisante
    Block* prev = 0;
    Block* curr = free_list;

    while (curr != 0) {
        if (curr->size >= size) {
            // Trouvé ! Retirer de la liste libre
            if (prev == 0) {
                free_list = curr->next;
            } else {
                prev->next = curr->next;
            }
            // Retourner l'adresse après l'en-tête
            return (void*)((char*)curr + 8);
        }
        prev = curr;
        curr = curr->next;
    }

    // 2. Pas de bloc libre : allouer depuis le tas
    Block* new_block = (Block*)heap_ptr;
    heap_ptr = heap_ptr + 8 + size;

    new_block->size = size;
    new_block->next = 0;

    return (void*)((char*)new_block + 8);
}

void free(void* ptr) {
    if (ptr == 0) return;

    // Retrouver l'en-tête (8 octets avant ptr)
    Block* block = (Block*)((char*)ptr - 8);

    // Ajouter en tête de la liste libre
    block->next = free_list;
    free_list = block;
}
```

#### Visualisation

```
Après malloc(100), malloc(50), free(premier bloc) :

free_list → ┌────────────────┐
            │ size=100       │
            │ next=NULL      │     Bloc libre (ex-premier)
            │ [libre]        │
            └────────────────┘

heap_ptr →  ┌────────────────┐
            │ size=50        │
            │ next=NULL      │     Bloc utilisé
            │ [données]      │
            └────────────────┘
```

### Fragmentation

**Problème** : Après plusieurs malloc/free, la mémoire devient "fragmentée" :

```
┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐
│LIBRE │ │USED  │ │LIBRE │ │USED  │ │LIBRE │
│ 20   │ │ 100  │ │ 30   │ │ 50   │ │ 40   │
└──────┘ └──────┘ └──────┘ └──────┘ └──────┘

Total libre : 90 octets
Mais impossible d'allouer 80 octets d'un bloc !
```

**Solutions** (non implémentées dans nand2c) :
- **Coalescence** : Fusionner les blocs libres adjacents
- **Compactage** : Déplacer les blocs pour éliminer les trous
- **Buddy allocator** : Diviser en puissances de 2

---

## Bibliothèque Graphique (Screen)

### L'écran Memory-Mapped

L'écran nand2c est accessible via MMIO :

| Propriété | Valeur |
|-----------|--------|
| Adresse base | `0x00400000` |
| Résolution | 320 × 240 pixels |
| Couleurs | 1 bit/pixel (noir/blanc) |
| Organisation | 8 pixels par octet, MSB à gauche |
| Taille totale | 320 × 240 / 8 = 9600 octets |

### Organisation des pixels

```
Octet à l'adresse 0x00400000 :
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 7 │ 6 │ 5 │ 4 │ 3 │ 2 │ 1 │ 0 │  ← Numéro du bit
└───┴───┴───┴───┴───┴───┴───┴───┘
  ↓   ↓   ↓   ↓   ↓   ↓   ↓   ↓
pixel 0 1 2 3 4 5 6 7 (première ligne)

Ligne y, colonne x :
  octet  = SCREEN_BASE + y * 40 + x / 8
  bit    = 7 - (x % 8)
```

### Fonctions de base

```c
char* SCREEN = (char*)0x00400000;
int current_color = 1;  // 1 = blanc, 0 = noir

void screen_init() {
    // Effacer l'écran (tout noir)
    int i;
    for (i = 0; i < 9600; i = i + 1) {
        SCREEN[i] = 0;
    }
}

void screen_set_color(int color) {
    current_color = color;
}

void screen_draw_pixel(int x, int y) {
    // Vérifier les limites
    if (x < 0 || x >= 320 || y < 0 || y >= 240) {
        return;
    }

    // Calculer l'adresse et le masque
    int byte_offset = y * 40 + x / 8;
    int bit_mask = 1 << (7 - (x % 8));

    if (current_color) {
        // Allumer le pixel (OR)
        SCREEN[byte_offset] = SCREEN[byte_offset] | bit_mask;
    } else {
        // Éteindre le pixel (AND NOT)
        SCREEN[byte_offset] = SCREEN[byte_offset] & (~bit_mask);
    }
}
```

### Algorithme de Bresenham (Lignes)

Pour dessiner des lignes **sans multiplication ni division** :

```c
int abs(int x) {
    if (x < 0) return -x;
    return x;
}

void screen_draw_line(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1;  // Direction x
    int sy = (y1 < y2) ? 1 : -1;  // Direction y
    int err = dx - dy;

    while (1) {
        screen_draw_pixel(x1, y1);

        // Arrivé à destination ?
        if (x1 == x2 && y1 == y2) break;

        int e2 = 2 * err;

        if (e2 > -dy) {
            err = err - dy;
            x1 = x1 + sx;
        }
        if (e2 < dx) {
            err = err + dx;
            y1 = y1 + sy;
        }
    }
}
```

**Pourquoi Bresenham ?**
- Utilise uniquement des **additions et comparaisons**
- Pas de multiplication ni division (lent sur notre CPU)
- Résultat visuellement correct

### Rectangle et Cercle

```c
void screen_draw_rect(int x, int y, int w, int h) {
    // Dessiner les 4 côtés
    screen_draw_line(x, y, x + w - 1, y);          // Haut
    screen_draw_line(x, y + h - 1, x + w - 1, y + h - 1);  // Bas
    screen_draw_line(x, y, x, y + h - 1);          // Gauche
    screen_draw_line(x + w - 1, y, x + w - 1, y + h - 1);  // Droite
}

void screen_fill_rect(int x, int y, int w, int h) {
    int i, j;
    for (j = 0; j < h; j = j + 1) {
        for (i = 0; i < w; i = i + 1) {
            screen_draw_pixel(x + i, y + j);
        }
    }
}

// Algorithme de Bresenham pour cercle
void screen_draw_circle(int cx, int cy, int r) {
    int x = r;
    int y = 0;
    int err = 1 - r;

    while (x >= y) {
        // Dessiner 8 points symétriques
        screen_draw_pixel(cx + x, cy + y);
        screen_draw_pixel(cx - x, cy + y);
        screen_draw_pixel(cx + x, cy - y);
        screen_draw_pixel(cx - x, cy - y);
        screen_draw_pixel(cx + y, cy + x);
        screen_draw_pixel(cx - y, cy + x);
        screen_draw_pixel(cx + y, cy - x);
        screen_draw_pixel(cx - y, cy - x);

        y = y + 1;
        if (err < 0) {
            err = err + 2 * y + 1;
        } else {
            x = x - 1;
            err = err + 2 * (y - x) + 1;
        }
    }
}
```

### Affichage de texte

Pour afficher du texte, on utilise une **police bitmap** :

```c
// Police 8x8 pixels (simplifié, seulement quelques caractères)
// Chaque caractère est 8 octets (8 lignes de 8 bits)

void screen_draw_char(int x, int y, char c) {
    int* font = get_font_data(c);  // Retourne 8 octets
    int row, col;

    for (row = 0; row < 8; row = row + 1) {
        int line = font[row];
        for (col = 0; col < 8; col = col + 1) {
            if (line & (1 << (7 - col))) {
                screen_draw_pixel(x + col, y + row);
            }
        }
    }
}

void screen_print(int x, int y, char* text) {
    while (*text != 0) {
        screen_draw_char(x, y, *text);
        x = x + 8;  // Avancer de 8 pixels
        text = text + 1;
    }
}
```

---

## Entrées / Sorties

### Sortie console (Output)

```c
int* OUTPUT = (int*)0xFFFF0000;

void putchar(char c) {
    *OUTPUT = c;
}

void puts(char* s) {
    while (*s != 0) {
        putchar(*s);
        s = s + 1;
    }
}

void print_int(int n) {
    // Cas négatif
    if (n < 0) {
        putchar('-');
        n = -n;
    }

    // Récursion pour afficher les chiffres dans l'ordre
    if (n >= 10) {
        print_int(n / 10);
    }
    putchar('0' + (n % 10));
}

void print_hex(int n) {
    char* hex = "0123456789ABCDEF";
    int i;

    putchar('0');
    putchar('x');

    for (i = 28; i >= 0; i = i - 4) {
        putchar(hex[(n >> i) & 0xF]);
    }
}
```

### Entrée clavier (Keyboard)

```c
int* KEYBOARD = (int*)0x00402600;

int keyboard_read() {
    return *KEYBOARD;
}

int keyboard_wait() {
    int key;

    // Attendre qu'une touche soit pressée
    while ((key = keyboard_read()) == 0) {
        // Boucle d'attente active (polling)
    }

    // Attendre que la touche soit relâchée
    while (keyboard_read() != 0) {
        // Éviter les répétitions
    }

    return key;
}

// Lire une ligne complète
int keyboard_read_line(char* buffer, int max_len) {
    int i = 0;
    int key;

    while (i < max_len - 1) {
        key = keyboard_wait();

        if (key == 13) {  // Entrée
            break;
        } else if (key == 8 && i > 0) {  // Backspace
            i = i - 1;
            putchar(8);   // Reculer
            putchar(' '); // Effacer
            putchar(8);   // Reculer encore
        } else if (key >= 32 && key < 127) {  // Caractère imprimable
            buffer[i] = key;
            i = i + 1;
            putchar(key);
        }
    }

    buffer[i] = 0;  // Terminer la chaîne
    putchar(10);    // Nouvelle ligne
    return i;
}
```

---

## Bibliothèque String

### Fonctions essentielles

```c
int strlen(char* s) {
    int len = 0;
    while (*s != 0) {
        len = len + 1;
        s = s + 1;
    }
    return len;
}

void strcpy(char* dest, char* src) {
    while (*src != 0) {
        *dest = *src;
        dest = dest + 1;
        src = src + 1;
    }
    *dest = 0;
}

int strcmp(char* a, char* b) {
    while (*a != 0 && *b != 0) {
        if (*a < *b) return -1;
        if (*a > *b) return 1;
        a = a + 1;
        b = b + 1;
    }
    if (*a == 0 && *b == 0) return 0;
    if (*a == 0) return -1;
    return 1;
}

char* strcat(char* dest, char* src) {
    char* start = dest;

    // Aller à la fin de dest
    while (*dest != 0) {
        dest = dest + 1;
    }

    // Copier src
    while (*src != 0) {
        *dest = *src;
        dest = dest + 1;
        src = src + 1;
    }
    *dest = 0;

    return start;
}

// Convertir une chaîne en entier
int atoi(char* s) {
    int result = 0;
    int sign = 1;

    // Gérer le signe
    if (*s == '-') {
        sign = -1;
        s = s + 1;
    }

    // Convertir les chiffres
    while (*s >= '0' && *s <= '9') {
        result = result * 10 + (*s - '0');
        s = s + 1;
    }

    return result * sign;
}
```

---

## Bibliothèque Math

### Fonctions de base

```c
int abs(int x) {
    if (x < 0) return -x;
    return x;
}

int min(int a, int b) {
    if (a < b) return a;
    return b;
}

int max(int a, int b) {
    if (a > b) return a;
    return b;
}

// Racine carrée entière (méthode de Newton)
int sqrt(int n) {
    if (n <= 1) return n;

    int x = n;
    int y = (x + 1) / 2;

    while (y < x) {
        x = y;
        y = (x + n / x) / 2;
    }

    return x;
}

// Division avec reste
int div(int a, int b) {
    return a / b;
}

int mod(int a, int b) {
    return a - (a / b) * b;
}

// Générateur pseudo-aléatoire (LCG)
int rand_seed = 12345;

int rand() {
    rand_seed = rand_seed * 1103515245 + 12345;
    return (rand_seed / 65536) % 32768;
}

void srand(int seed) {
    rand_seed = seed;
}
```

---

## Appels Système (Syscalls)

### Concept

Un **appel système** est une requête du programme vers l'OS. Sur nand2c, on utilise l'instruction `SVC` (SuperVisor Call).

```c
// En assembleur
SVC #0x10    ; Syscall numéro 0x10

// Le numéro détermine l'action :
// 0x10 = halt (arrêter le CPU)
// 0x01 = putchar (afficher un caractère, R0 = caractère)
// 0x02 = getchar (lire un caractère, résultat dans R0)
```

### Table des syscalls nand2c

| Numéro | Nom | Description | Paramètres |
|--------|-----|-------------|------------|
| `0x01` | putchar | Afficher un caractère | R0 = caractère |
| `0x02` | getchar | Lire un caractère | Résultat dans R0 |
| `0x10` | halt | Arrêter le CPU | R0 = code de sortie |
| `0x20` | time | Obtenir le temps | Résultat dans R0 |

### Implémentation côté CPU

```c
// Dans le simulateur CPU (simplifié)
void handle_svc(int syscall_num) {
    switch (syscall_num) {
        case 0x01:  // putchar
            printf("%c", registers[0]);
            break;

        case 0x02:  // getchar
            registers[0] = getchar();
            break;

        case 0x10:  // halt
            running = 0;
            exit_code = registers[0];
            break;

        case 0x20:  // time
            registers[0] = get_current_time();
            break;
    }
}
```

---

## Exercices Pratiques

### Exercices sur le Simulateur Web

Lancez le **Simulateur Web** et allez dans **Exercices OS** :

| Exercice | Description | Concepts |
|----------|-------------|----------|
| `os-boot` | Bootstrap et initialisation | Séquence de démarrage |
| `os-bump` | Allocateur bump | malloc simple |
| `os-free` | Allocateur avec free list | malloc/free |
| `os-screen` | Driver écran | MMIO, pixels |
| `os-font` | Police bitmap | Affichage texte |
| `os-console` | Console interactive | I/O combinées |
| `os-kbd` | Driver clavier | Lecture touches |
| `os-shell` | Shell basique | Application complète |

### Exercice 1 : Étendre l'allocateur

Ajoutez la **coalescence** à l'allocateur par liste libre :

```c
void free(void* ptr) {
    if (ptr == 0) return;

    Block* block = (Block*)((char*)ptr - 8);

    // TODO: Vérifier si le bloc suivant est libre
    // Si oui, fusionner les deux blocs

    // TODO: Vérifier si le bloc précédent est libre
    // Si oui, fusionner avec lui aussi

    block->next = free_list;
    free_list = block;
}
```

### Exercice 2 : Dessiner un triangle

Implémentez `screen_draw_triangle()` :

```c
void screen_draw_triangle(int x1, int y1, int x2, int y2, int x3, int y3) {
    // TODO: Utiliser screen_draw_line() trois fois
}
```

### Exercice 3 : Printf simplifié

Implémentez `printf()` avec support de `%d`, `%s`, `%x` :

```c
void printf(char* format, ...) {
    // TODO: Parser le format et afficher les arguments
    // Indice: utiliser va_list si supporté, sinon pointeur sur la pile
}
```

---

## Applications Démo

Le répertoire `demos/` contient des exemples complets :

| Démo | Description | Concepts utilisés |
|:-----|:------------|:------------------|
| `01_hello` | Hello World | putchar, puts |
| `02_fibonacci` | Suite de Fibonacci | Arithmétique, récursion |
| `03_graphics` | Dessins géométriques | Screen, Bresenham |
| `04_snake` | Jeu du serpent | Tout ! |
| `05_shell` | Interface commande | Keyboard, String, Screen |
| `06_coroutines` | Changement de contexte | Pile, registres |
| `07_scheduler` | Ordonnanceur basique | Multitâche |

### Compiler et exécuter

```bash
# Compiler une démo
cargo run -p c32_cli -- demos/04_snake/snake.c -o snake.bin

# Exécuter
cargo run -p c32_runner -- snake.bin

# Ou utiliser le Simulateur Web !
```

---

## Ce qu'il faut retenir

### Les 5 services fondamentaux d'un OS

1. **Gestion mémoire** : `malloc()` / `free()`
   - Bump allocator : simple mais sans réutilisation
   - Free list : réutilise la mémoire libérée

2. **Graphiques** : `screen_draw_*()`
   - MMIO à 0x00400000
   - Bresenham pour les lignes et cercles

3. **Entrées** : `keyboard_read()` / `keyboard_wait()`
   - Polling du registre clavier
   - (Interruptions pour les systèmes avancés)

4. **Sorties** : `putchar()` / `puts()` / `print_int()`
   - Écriture vers OUTPUT MMIO

5. **Chaînes** : `strlen()` / `strcpy()` / `strcmp()`
   - Manipulation de texte

### Le chemin complet

```
Votre code C32           →  Compilé en assembleur A32
     ↓
Assembleur A32           →  Assemblé en binaire
     ↓
Binaire                  →  Chargé en mémoire
     ↓
CPU                      →  Fetch-Decode-Execute
     ↓
MMIO                     →  Écran s'allume, clavier répond
```

---

## Auto-évaluation

### Quiz

**Q1.** Quelle est la différence entre un allocateur "bump" et un allocateur par liste libre ?

**Q2.** Pourquoi l'algorithme de Bresenham est-il adapté à notre CPU ?

**Q3.** Comment fonctionne le mapping mémoire de l'écran ?

**Q4.** Qu'est-ce qu'un appel système et pourquoi est-il nécessaire ?

**Q5.** Décrivez la séquence de démarrage de notre OS.

### Réponses

<details>
<summary>Voir les réponses</summary>

**R1.** Le bump allocator avance simplement un pointeur et ne réutilise jamais la mémoire libérée. L'allocateur par liste libre maintient une liste des blocs libérés et peut les réallouer.

**R2.** Bresenham n'utilise que des additions et comparaisons, pas de multiplication ni division. Notre CPU exécute ces opérations beaucoup plus rapidement.

**R3.** L'écran est mappé à l'adresse 0x00400000. Chaque octet contient 8 pixels (1 bit par pixel). Pour un écran 320×240, cela fait 40 octets par ligne, 9600 octets au total.

**R4.** Un appel système permet à un programme utilisateur de demander un service à l'OS (afficher, lire, allouer). L'instruction SVC déclenche le handler approprié.

**R5.** 1) CPU démarre à l'adresse 0, 2) Bootstrap initialise SP, 3) BSS mis à zéro, 4) Heap initialisé, 5) main() appelé, 6) SVC halt à la fin.

</details>

### Checklist

- [ ] Je comprends la différence entre pile, tas et données statiques
- [ ] Je peux expliquer comment malloc() et free() fonctionnent
- [ ] Je sais comment dessiner un pixel à l'écran via MMIO
- [ ] Je comprends l'algorithme de Bresenham
- [ ] Je peux lire le clavier et afficher du texte
- [ ] Je sais ce qu'est un appel système

---

## Pour aller plus loin

### Concepts non implémentés dans nand2c

| Concept | Description | Difficulté |
|---------|-------------|:----------:|
| **Système de fichiers** | Sauvegarder des données | ★★★ |
| **Mémoire virtuelle** | Isolation des processus | ★★★★ |
| **Multitâche préemptif** | Interruptions timer | ★★★ |
| **Protection mémoire** | Modes utilisateur/superviseur | ★★★★ |
| **Drivers** | Support de périphériques variés | ★★★ |

### Ressources recommandées

- **Operating Systems: Three Easy Pieces** (gratuit en ligne)
- **xv6** : OS pédagogique du MIT
- **Linux From Scratch** : Construire Linux depuis zéro
- **OSDev Wiki** : Communauté de développement d'OS
