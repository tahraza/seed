# Système d'Exploitation

> "Un OS est ce qui reste quand on a enlevé tout ce qui est utile." — Ken Thompson

Félicitations ! Vous avez construit le matériel, l'assembleur et le compilateur. Votre machine Codex est fonctionnelle. Mais pour l'instant, chaque programmeur doit réinventer la roue : comment dessiner un cercle ? comment lire une chaîne de caractères ?

Dans ce dernier chapitre, nous allons construire une **Bibliothèque Système** qui simplifie l'accès au matériel.

---

## Où en sommes-nous ?

![Position dans l'architecture](images/architecture-stack.svg)

*Nous sommes à la Couche 6 : Système d'Exploitation - Le sommet de la pyramide logicielle !*

C'est le **sommet de la pyramide** logicielle ! L'OS cache la complexité du matériel et offre des services de haut niveau aux applications.

---

## Qu'est-ce qu'un Système d'Exploitation ?

### La hiérarchie logicielle

![Hiérarchie logicielle](images/software-hierarchy.svg)

### Ce que fait un OS

| Fonction | Description |
|:---------|:------------|
| **Gestion mémoire** | Allouer/libérer de la mémoire dynamiquement |
| **Graphiques** | Dessiner des formes, du texte |
| **Entrées/Sorties** | Lire le clavier, afficher à l'écran |
| **Fichiers** | Sauvegarder/charger des données (avancé) |
| **Multitâche** | Exécuter plusieurs programmes (avancé) |

Notre OS Codex implémente les trois premiers points.

---

## Gestion de la Mémoire (Le Tas / Heap)

### Le problème

Jusqu'à présent, nous utilisions :

- **Variables globales** : Taille fixée à la compilation
- **Variables locales** : Sur la pile, libérées automatiquement

Mais que faire si on veut allouer une taille **inconnue à l'avance** ?

### L'allocateur "Bump" (Simple)

L'allocateur le plus simple : un pointeur qui avance à chaque allocation.

```c
char* heap_ptr = (char*)HEAP_START;

char* malloc(int size) {
    char* result = heap_ptr;
    heap_ptr = heap_ptr + size;
    return result;
}

void free(char* ptr) {
    // Ne fait rien ! La mémoire n'est jamais récupérée.
}
```

**Avantage** : Très simple, très rapide.
**Inconvénient** : On ne peut pas réutiliser la mémoire libérée.

### L'allocateur par Liste Chaînée (Avancé)

Pour réutiliser la mémoire, chaque bloc contient :
- Sa taille
- Un pointeur vers le bloc libre suivant

```
┌────────────────────────────────────────────────────┐
│ [size|next] [données...]  [size|next] [données...] │
└────────────────────────────────────────────────────┘
```

Quand on libère un bloc, on l'ajoute à la liste des blocs libres. Quand on alloue, on cherche un bloc de taille suffisante.

---

## Bibliothèque Graphique

### Le problème

Pour allumer un pixel, il faut :

1. Calculer l'adresse de l'octet
2. Calculer la position du bit
3. Faire un OR pour allumer (ou AND + NOT pour éteindre)

C'est fastidieux et source d'erreurs.

### Les fonctions graphiques

```c
void screen_init();
void screen_clear();
void screen_set_color(int color);

void screen_draw_pixel(int x, int y);
void screen_draw_line(int x1, int y1, int x2, int y2);
void screen_draw_rect(int x, int y, int w, int h);
void screen_draw_circle(int cx, int cy, int r);
void screen_print(char* text, int x, int y);
```

### L'algorithme de Bresenham

Pour dessiner des lignes droites avec uniquement des additions et des comparaisons:

```c
void screen_draw_line(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);
    int sx = x1 < x2 ? 1 : -1;
    int sy = y1 < y2 ? 1 : -1;
    int err = dx - dy;

    while (1) {
        screen_draw_pixel(x1, y1);
        if (x1 == x2 && y1 == y2) break;
        int e2 = 2 * err;
        if (e2 > -dy) { err = err - dy; x1 = x1 + sx; }
        if (e2 < dx)  { err = err + dx; y1 = y1 + sy; }
    }
}
```

Pas de multiplication, pas de division — uniquement des opérations que notre CPU fait rapidement !

---

## Entrées / Sorties

### Printf simplifié

```c
void putchar(char c) {
    // Appel système SVC pour afficher un caractère
}

void puts(char* s) {
    while (*s != 0) {
        putchar(*s);
        s = s + 1;
    }
}

void print_int(int n) {
    if (n < 0) {
        putchar('-');
        n = -n;
    }
    if (n >= 10) {
        print_int(n / 10);
    }
    putchar('0' + (n % 10));
}
```

### Lecture du clavier

```c
int keyboard_read() {
    int* kbd = (int*)0x00402600;
    return *kbd;
}

int keyboard_wait() {
    int key;
    while ((key = keyboard_read()) == 0) {
        // Attendre
    }
    return key;
}
```

---

## Interruptions et Timer (Concepts)

### Le problème du polling

Dans notre approche actuelle, le CPU vérifie constamment le clavier :

```c
while (keyboard_read() == 0) {}  // CPU occupe à ne rien faire !
```

### Les interruptions

Avec les interruptions, le matériel **signale** au CPU qu'un événement s'est produit:

1. Le CPU exécute le programme
2. Une touche est pressée → Le matériel déclenche une **interruption**
3. Le CPU s'arrête et saute vers le **handler d'interruption**
4. Le handler traite l'événement
5. Le CPU reprend le programme là où il s'était arrêté

C'est la base du multitâche et des systèmes réactifs !

---

## Applications Démo

Le répertoire `demos/` contient des exemples complets :

| Démo | Description |
|:-----|:------------|
| `01_hello` | Hello World classique |
| `02_counter` | Compteur avec affichage |
| `03_graphics` | Dessins géométriques |
| `04_snake` | Jeu du serpent complet ! |
| `05_shell` | Interface en ligne de commande |

### Compiler et exécuter une démo

```bash
# Compiler
cargo run -p c32_cli -- demos/04_snake/main.c -o snake.bin

# Exécuter
cargo run -p a32_runner -- snake.bin
```

Ou utilisez le **Simulateur Web** pour une expérience visuelle !

---

## Exercices Pratiques

### Exercices sur le Simulateur Web

La section **OS** contient des exercices interactifs :

| Exercice | Description |
|:---------|:------------|
| `Calculatrice` | Calculatrice interactive avec clavier |
| `Variables` | Shell pour définir des variables |
| `Timer` | Affichage d'un compteur animé |
| `Scheduler` | Simulation d'un ordonnanceur |
| `Projet Mini-OS` | Shell multi-applications |
| `Task Manager` | Gestionnaire de tâches visuel |

### Défis suggérés

1. **Étendre l'OS** : Ajoutez `screen_draw_triangle()` en utilisant trois appels à `screen_draw_line()`.

2. **Gestion mémoire** : Testez l'allocateur avec plusieurs `malloc()` et observez le comportement.

3. **Projet final** : Créez votre propre application dans `demos/` en utilisant tout ce que vous avez appris !

---

## Le Parcours Complet

Vous avez parcouru tout le chemin :

```
Chapitre 0 : Introduction
    ↓
Chapitre 1-5 : MATÉRIEL
    NAND → Portes → ALU → Mémoire → CPU
    ↓
Chapitre 6-9 : LOGICIEL
    Assembleur → Compilateur → C32 → OS
    ↓
Applications : Jeux, Calculatrices, Shell...
```

Vous comprenez maintenant que l'ordinateur n'est pas une boîte magique, mais une **pyramide d'abstractions** magnifiquement ordonnées.

---

## Ce qu'il faut retenir

1. **L'OS cache le matériel** : `draw_circle()` au lieu de manipuler des bits

2. **Gestion mémoire dynamique** : `malloc()` et `free()`

3. **Bibliothèque graphique** : Lignes, rectangles, cercles, texte

4. **Entrées/Sorties** : `putchar()`, `keyboard_read()`

5. **Interruptions** : Le matériel peut signaler des événements au CPU

---

## Félicitations !

Vous avez parcouru tout le chemin, de la **porte NAND** au **système d'exploitation**. Vous comprenez maintenant :

- Comment les bits deviennent des calculs (ALU)

- Comment les calculs deviennent de la mémoire (RAM)

- Comment la mémoire devient un programme (CPU)

- Comment un programme devient une application (Compilateur + OS)

Quand vous verrez du code s'exécuter, vous saurez **exactement** ce qui se passe dans la machine. Ce n'est plus de la magie — c'est de l'ingénierie que vous maîtrisez.

---

**Et maintenant ?**

- Apprenez le C pour approfondir la programmation système
- Étudiez le noyau Linux pour voir un vrai OS
- Explorez les architectures ARM/RISC-V modernes
- Construisez vos propres projets sur la base de Codex !

---

## Auto-évaluation

Testez votre compréhension de l'ensemble du parcours.

### Questions de compréhension

**Q1.** Qu'est-ce qu'un allocateur mémoire et pourquoi en a-t-on besoin ?

<details>
<summary>Voir la réponse</summary>

Un **allocateur mémoire** gère l'attribution dynamique de mémoire :
- `alloc(size)` : Trouve un bloc libre de `size` octets
- `free(ptr)` : Libère un bloc précédemment alloué

Sans allocateur, il faudrait déclarer toutes les variables à l'avance. L'allocation dynamique permet de créer des structures de données de taille variable (listes, arbres, etc.).
</details>

**Q2.** Comment fonctionne l'affichage graphique via MMIO ?

<details>
<summary>Voir la réponse</summary>

Le framebuffer est une zone mémoire à `0x00400000` :
- 320×240 pixels, 1 bit par pixel
- Chaque mot de 32 bits = 32 pixels horizontaux
- Écrire dans cette zone met à jour l'écran directement

```c
// Allumer le pixel (x, y)
uint *screen = (uint*)0x00400000;
int word_index = y * 10 + (x / 32);  // 10 mots par ligne
int bit = 31 - (x % 32);
screen[word_index] |= (1 << bit);
```
</details>

**Q3.** Quelle est la différence entre polling et interruptions ?

<details>
<summary>Voir la réponse</summary>

- **Polling** : Le CPU vérifie périodiquement si un événement s'est produit
  - Simple mais gaspille des cycles CPU
- **Interruptions** : Le périphérique signale au CPU quand il a besoin d'attention
  - Efficace mais plus complexe à implémenter

Codex utilise le polling pour simplifier, les vrais OS utilisent les interruptions.
</details>

**Q4.** Pourquoi sépare-t-on le code en bibliothèques (Math, String, Screen, etc.) ?

<details>
<summary>Voir la réponse</summary>

**Modularité** : Chaque bibliothèque a une responsabilité claire :
- `Math` : Opérations arithmétiques (multiply, divide)
- `String` : Manipulation de chaînes (length, copy, compare)
- `Screen` : Affichage (drawPixel, drawLine, drawChar)
- `Memory` : Allocation dynamique

Avantages : réutilisation, maintenance facile, abstraction des détails.
</details>

**Q5.** Résumez le chemin complet du code source à l'exécution.

<details>
<summary>Voir la réponse</summary>

1. **Code C32** → Compilateur → **Code assembleur A32**
2. **Code A32** → Assembleur → **Binaire A32B**
3. **Binaire** → Chargé en RAM par le "loader"
4. **CPU** lit les instructions depuis la RAM
5. **Fetch → Decode → Execute → Memory → Writeback**
6. Le programme interagit via **MMIO** (écran, clavier)
7. **SVC #0** termine le programme

Chaque couche est une abstraction sur la précédente !
</details>

### Réflexion finale

Vous avez maintenant une vision complète de comment fonctionne un ordinateur :

| Couche | Ce que vous avez appris |
|--------|------------------------|
| Portes logiques | NAND → NOT, AND, OR, XOR, MUX |
| Arithmétique | Half Adder → Full Adder → ALU |
| Mémoire | DFF → Registre → RAM → PC |
| CPU | Fetch-Decode-Execute, pipeline |
| ISA | Instructions A32, encodage binaire |
| Assembleur | Texte → Binaire (2 passes) |
| Compilateur | C32 → Assembleur (lexer, parser, codegen) |
| OS | Allocation mémoire, graphiques, I/O |

**Vous n'êtes plus un utilisateur passif de la technologie — vous comprenez comment elle fonctionne !**

### Checklist de validation finale

- [ ] Je peux expliquer comment NAND permet de construire toutes les portes
- [ ] Je comprends le complément à 2 et les drapeaux NZCV
- [ ] Je sais tracer l'exécution d'une instruction dans le CPU
- [ ] Je peux écrire et déboguer un programme en assembleur A32
- [ ] Je comprends comment le compilateur traduit C32 en assembleur
- [ ] Je sais utiliser le MMIO pour l'écran et le clavier
- [ ] Je peux expliquer la hiérarchie mémoire (registres → cache → RAM)
