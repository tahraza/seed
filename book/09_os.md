# Système d'Exploitation

> "Un OS est ce qui reste quand on a enlevé tout ce qui est utile." — Ken Thompson

Félicitations ! Vous avez construit le matériel, l'assembleur et le compilateur. Votre machine Codex est fonctionnelle. Mais pour l'instant, chaque programmeur doit réinventer la roue : comment dessiner un cercle ? comment lire une chaîne de caractères ?

Dans ce dernier chapitre, nous allons construire une **Bibliothèque Système** qui simplifie l'accès au matériel.

---

## Où en sommes-nous ?

![Position dans l'architecture](images/architecture-stack.svg)

*Nous sommes à la Couche 6 : Système d'Exploitation - Le sommet de la pyramide logicielle !*

C'est le **sommet de la pyramide** logicielle ! L'OS cache la complexité du matériel et offre des services de haut niveau aux applications.

---

## Qu'est-ce qu'un Système d'Exploitation ?

### La hiérarchie logicielle

![Hiérarchie logicielle](images/software-hierarchy.svg)

### Ce que fait un OS

| Fonction | Description |
|:---------|:------------|
| **Gestion mémoire** | Allouer/libérer de la mémoire dynamiquement |
| **Graphiques** | Dessiner des formes, du texte |
| **Entrées/Sorties** | Lire le clavier, afficher à l'écran |
| **Fichiers** | Sauvegarder/charger des données (avancé) |
| **Multitâche** | Exécuter plusieurs programmes (avancé) |

Notre OS Codex implémente les trois premiers points.

---

## Gestion de la Mémoire (Le Tas / Heap)

### Le problème

Jusqu'à présent, nous utilisions :

- **Variables globales** : Taille fixée à la compilation
- **Variables locales** : Sur la pile, libérées automatiquement

Mais que faire si on veut allouer une taille **inconnue à l'avance** ?

### L'allocateur "Bump" (Simple)

L'allocateur le plus simple : un pointeur qui avance à chaque allocation.

```c
char* heap_ptr = (char*)HEAP_START;

char* malloc(int size) {
    char* result = heap_ptr;
    heap_ptr = heap_ptr + size;
    return result;
}

void free(char* ptr) {
    // Ne fait rien ! La mémoire n'est jamais récupérée.
}
```

**Avantage** : Très simple, très rapide.
**Inconvénient** : On ne peut pas réutiliser la mémoire libérée.

### L'allocateur par Liste Chaînée (Avancé)

Pour réutiliser la mémoire, chaque bloc contient :
- Sa taille
- Un pointeur vers le bloc libre suivant

```
┌────────────────────────────────────────────────────┐
│ [size|next] [données...]  [size|next] [données...] │
└────────────────────────────────────────────────────┘
```

Quand on libère un bloc, on l'ajoute à la liste des blocs libres. Quand on alloue, on cherche un bloc de taille suffisante.

---

## Bibliothèque Graphique

### Le problème

Pour allumer un pixel, il faut :

1. Calculer l'adresse de l'octet
2. Calculer la position du bit
3. Faire un OR pour allumer (ou AND + NOT pour éteindre)

C'est fastidieux et source d'erreurs.

### Les fonctions graphiques

```c
void screen_init();
void screen_clear();
void screen_set_color(int color);

void screen_draw_pixel(int x, int y);
void screen_draw_line(int x1, int y1, int x2, int y2);
void screen_draw_rect(int x, int y, int w, int h);
void screen_draw_circle(int cx, int cy, int r);
void screen_print(char* text, int x, int y);
```

### L'algorithme de Bresenham

Pour dessiner des lignes droites avec uniquement des additions et des comparaisons:

```c
void screen_draw_line(int x1, int y1, int x2, int y2) {
    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);
    int sx = x1 < x2 ? 1 : -1;
    int sy = y1 < y2 ? 1 : -1;
    int err = dx - dy;

    while (1) {
        screen_draw_pixel(x1, y1);
        if (x1 == x2 && y1 == y2) break;
        int e2 = 2 * err;
        if (e2 > -dy) { err = err - dy; x1 = x1 + sx; }
        if (e2 < dx)  { err = err + dx; y1 = y1 + sy; }
    }
}
```

Pas de multiplication, pas de division — uniquement des opérations que notre CPU fait rapidement !

---

## Entrées / Sorties

### Printf simplifié

```c
void putchar(char c) {
    // Appel système SVC pour afficher un caractère
}

void puts(char* s) {
    while (*s != 0) {
        putchar(*s);
        s = s + 1;
    }
}

void print_int(int n) {
    if (n < 0) {
        putchar('-');
        n = -n;
    }
    if (n >= 10) {
        print_int(n / 10);
    }
    putchar('0' + (n % 10));
}
```

### Lecture du clavier

```c
int keyboard_read() {
    int* kbd = (int*)0x00402600;
    return *kbd;
}

int keyboard_wait() {
    int key;
    while ((key = keyboard_read()) == 0) {
        // Attendre
    }
    return key;
}
```

---

## Interruptions et Timer (Concepts)

### Le problème du polling

Dans notre approche actuelle, le CPU vérifie constamment le clavier :

```c
while (keyboard_read() == 0) {}  // CPU occupe à ne rien faire !
```

### Les interruptions

Avec les interruptions, le matériel **signale** au CPU qu'un événement s'est produit:

1. Le CPU exécute le programme
2. Une touche est pressée → Le matériel déclenche une **interruption**
3. Le CPU s'arrête et saute vers le **handler d'interruption**
4. Le handler traite l'événement
5. Le CPU reprend le programme là où il s'était arrêté

C'est la base du multitâche et des systèmes réactifs !

---

## Applications Démo

Le répertoire `demos/` contient des exemples complets :

| Démo | Description |
|:-----|:------------|
| `01_hello` | Hello World classique |
| `02_counter` | Compteur avec affichage |
| `03_graphics` | Dessins géométriques |
| `04_snake` | Jeu du serpent complet ! |
| `05_shell` | Interface en ligne de commande |

### Compiler et exécuter une démo

```bash
# Compiler
cargo run -p c32_cli -- demos/04_snake/main.c -o snake.bin

# Exécuter
cargo run -p a32_runner -- snake.bin
```

Ou utilisez le **Simulateur Web** pour une expérience visuelle !

---

## Exercices Pratiques

### Exercices sur le Simulateur Web

La section **OS** contient des exercices interactifs :

| Exercice | Description |
|:---------|:------------|
| `Calculatrice` | Calculatrice interactive avec clavier |
| `Variables` | Shell pour définir des variables |
| `Timer` | Affichage d'un compteur animé |
| `Scheduler` | Simulation d'un ordonnanceur |
| `Projet Mini-OS` | Shell multi-applications |
| `Task Manager` | Gestionnaire de tâches visuel |

### Défis suggérés

1. **Étendre l'OS** : Ajoutez `screen_draw_triangle()` en utilisant trois appels à `screen_draw_line()`.

2. **Gestion mémoire** : Testez l'allocateur avec plusieurs `malloc()` et observez le comportement.

3. **Projet final** : Créez votre propre application dans `demos/` en utilisant tout ce que vous avez appris !

---

## Le Parcours Complet

Vous avez parcouru tout le chemin :

```
Chapitre 0 : Introduction
    ↓
Chapitre 1-5 : MATÉRIEL
    NAND → Portes → ALU → Mémoire → CPU
    ↓
Chapitre 6-9 : LOGICIEL
    Assembleur → Compilateur → C32 → OS
    ↓
Applications : Jeux, Calculatrices, Shell...
```

Vous comprenez maintenant que l'ordinateur n'est pas une boîte magique, mais une **pyramide d'abstractions** magnifiquement ordonnées.

---

## Ce qu'il faut retenir

1. **L'OS cache le matériel** : `draw_circle()` au lieu de manipuler des bits

2. **Gestion mémoire dynamique** : `malloc()` et `free()`

3. **Bibliothèque graphique** : Lignes, rectangles, cercles, texte

4. **Entrées/Sorties** : `putchar()`, `keyboard_read()`

5. **Interruptions** : Le matériel peut signaler des événements au CPU

---

## Félicitations !

Vous avez parcouru tout le chemin, de la **porte NAND** au **système d'exploitation**. Vous comprenez maintenant :

- Comment les bits deviennent des calculs (ALU)

- Comment les calculs deviennent de la mémoire (RAM)

- Comment la mémoire devient un programme (CPU)

- Comment un programme devient une application (Compilateur + OS)

Quand vous verrez du code s'exécuter, vous saurez **exactement** ce qui se passe dans la machine. Ce n'est plus de la magie — c'est de l'ingénierie que vous maîtrisez.

---

**Et maintenant ?**

- Apprenez le C pour approfondir la programmation système

- Étudiez le noyau Linux pour voir un vrai OS

- Explorez les architectures ARM/RISC-V modernes

- Construisez vos propres projets sur la base de Codex !
