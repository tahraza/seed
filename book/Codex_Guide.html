<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Projet Nand2Tetris-Codex" />
  <meta name="dcterms.date" content="2026-01-01" />
  <title>L’Architecture Codex</title>
  <style>
html {
font-family: DejaVu Serif;
font-size: 11pt;
color: #1a1a1a;
background-color: #fdfdfd;
}
body {
margin: 0 auto;
max-width: 36em;
padding-left: 50px;
padding-right: 50px;
padding-top: 50px;
padding-bottom: 50px;
hyphens: auto;
overflow-wrap: break-word;
text-rendering: optimizeLegibility;
font-kerning: normal;
}
@media (max-width: 600px) {
body {
font-size: 0.9em;
padding: 12px;
}
h1 {
font-size: 1.8em;
}
}
@media print {
html {
background-color: white;
}
body {
background-color: transparent;
color: black;
font-size: 12pt;
}
p, h2, h3 {
orphans: 3;
widows: 3;
}
h2, h3, h4 {
page-break-after: avoid;
}
}
p {
margin: 1em 0;
}
a {
color: #1a1a1a;
}
a:visited {
color: #1a1a1a;
}
img {
max-width: 100%;
}
svg {
height: auto;
max-width: 100%;
}
h1, h2, h3, h4, h5, h6 {
margin-top: 1.4em;
}
h5, h6 {
font-size: 1em;
font-style: italic;
}
h6 {
font-weight: normal;
}
ol, ul {
padding-left: 1.7em;
margin-top: 1em;
}
li > ol, li > ul {
margin-top: 0;
}
blockquote {
margin: 1em 0 1em 1.7em;
padding-left: 1em;
border-left: 2px solid #e6e6e6;
color: #606060;
}
code {
font-family: DejaVu Sans Mono;
font-size: 85%;
margin: 0;
hyphens: manual;
}
pre {
margin: 1em 0;
overflow: auto;
}
pre code {
padding: 0;
overflow: visible;
overflow-wrap: normal;
}
.sourceCode {
background-color: transparent;
overflow: visible;
}
hr {
background-color: #1a1a1a;
border: none;
height: 1px;
margin: 1em 0;
}
table {
margin: 1em 0;
border-collapse: collapse;
width: 100%;
overflow-x: auto;
display: block;
font-variant-numeric: lining-nums tabular-nums;
}
table caption {
margin-bottom: 0.75em;
}
tbody {
margin-top: 0.5em;
border-top: 1px solid #1a1a1a;
border-bottom: 1px solid #1a1a1a;
}
th {
border-top: 1px solid #1a1a1a;
padding: 0.25em 0.5em 0.25em 0.5em;
}
td {
padding: 0.125em 0.5em 0.25em 0.5em;
}
header {
margin-bottom: 4em;
text-align: center;
}
#TOC li {
list-style: none;
}
#TOC ul {
padding-left: 1.3em;
}
#TOC > ul {
padding-left: 0;
}
#TOC a:not(:hover) {
text-decoration: none;
}
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}

ul.task-list[class]{list-style: none;}
ul.task-list li input[type="checkbox"] {
font-size: inherit;
width: 0.8em;
margin: 0 0.8em 0.2em -1.6em;
vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}

pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
  
</head>
<body>
<header id="title-block-header">
<h1 class="title">L’Architecture Codex</h1>
<p class="subtitle">De la Porte Logique au Système d’Exploitation
32-bits</p>
<p class="author">Projet Nand2Tetris-Codex</p>
<p class="date">2026</p>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#larchitecture-codex-guide-de-létudiant" id="toc-larchitecture-codex-guide-de-létudiant"><span class="toc-section-number">1</span> L’Architecture Codex : Guide de
l’Étudiant</a>
<ul>
<li><a href="#table-des-matières" id="toc-table-des-matières"><span class="toc-section-number">1.1</span> Table des Matières</a></li>
<li><a href="#comment-utiliser-ce-guide" id="toc-comment-utiliser-ce-guide"><span class="toc-section-number">1.2</span> Comment utiliser ce guide</a></li>
</ul></li>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">2</span> Introduction</a>
<ul>
<li><a href="#le-mystère-de-lordinateur" id="toc-le-mystère-de-lordinateur"><span class="toc-section-number">2.1</span> Le Mystère de
l’Ordinateur</a></li>
<li><a href="#pourquoi-construire-un-ordinateur" id="toc-pourquoi-construire-un-ordinateur"><span class="toc-section-number">2.2</span> Pourquoi Construire un Ordinateur
?</a></li>
<li><a href="#ce-que-vous-allez-construire" id="toc-ce-que-vous-allez-construire"><span class="toc-section-number">2.3</span> Ce que Vous Allez
Construire</a></li>
<li><a href="#codex-vs-hack-nand2tetris-original" id="toc-codex-vs-hack-nand2tetris-original"><span class="toc-section-number">2.4</span> Codex vs Hack (Nand2Tetris
Original)</a></li>
<li><a href="#ce-que-vous-allez-apprendre" id="toc-ce-que-vous-allez-apprendre"><span class="toc-section-number">2.5</span> Ce que Vous Allez
Apprendre</a></li>
<li><a href="#vos-outils" id="toc-vos-outils"><span class="toc-section-number">2.6</span> Vos Outils</a></li>
<li><a href="#comment-utiliser-ce-livre" id="toc-comment-utiliser-ce-livre"><span class="toc-section-number">2.7</span> Comment Utiliser ce Livre</a></li>
<li><a href="#la-grande-aventure-commence" id="toc-la-grande-aventure-commence"><span class="toc-section-number">2.8</span> La Grande Aventure
Commence</a></li>
</ul></li>
<li><a href="#logique-booléenne" id="toc-logique-booléenne"><span class="toc-section-number">3</span> Logique Booléenne</a>
<ul>
<li><a href="#où-en-sommes-nous" id="toc-où-en-sommes-nous"><span class="toc-section-number">3.1</span> Où en sommes-nous ?</a></li>
<li><a href="#pourquoi-le-binaire" id="toc-pourquoi-le-binaire"><span class="toc-section-number">3.2</span> Pourquoi le Binaire ?</a></li>
<li><a href="#la-porte-nand-notre-axiome" id="toc-la-porte-nand-notre-axiome"><span class="toc-section-number">3.3</span> La Porte NAND : Notre
Axiome</a></li>
<li><a href="#construction-des-portes-élémentaires" id="toc-construction-des-portes-élémentaires"><span class="toc-section-number">3.4</span> Construction des Portes
Élémentaires</a></li>
<li><a href="#le-lien-avec-lordinateur-complet" id="toc-le-lien-avec-lordinateur-complet"><span class="toc-section-number">3.5</span> Le Lien avec l’Ordinateur
Complet</a></li>
<li><a href="#description-matérielle-codex-hdl" id="toc-description-matérielle-codex-hdl"><span class="toc-section-number">3.6</span> Description Matérielle (Codex
HDL)</a></li>
<li><a href="#exercices-pratiques" id="toc-exercices-pratiques"><span class="toc-section-number">3.7</span> Exercices Pratiques</a></li>
<li><a href="#défis-supplémentaires" id="toc-défis-supplémentaires"><span class="toc-section-number">3.8</span> Défis Supplémentaires</a></li>
<li><a href="#ce-quil-faut-retenir" id="toc-ce-quil-faut-retenir"><span class="toc-section-number">3.9</span> Ce qu’il faut retenir</a></li>
</ul></li>
<li><a href="#arithmétique-binaire" id="toc-arithmétique-binaire"><span class="toc-section-number">4</span> Arithmétique Binaire</a>
<ul>
<li><a href="#où-en-sommes-nous-1" id="toc-où-en-sommes-nous-1"><span class="toc-section-number">4.1</span> Où en sommes-nous ?</a></li>
<li><a href="#pourquoi-larithmétique-est-elle-si-importante" id="toc-pourquoi-larithmétique-est-elle-si-importante"><span class="toc-section-number">4.2</span> Pourquoi l’Arithmétique est-elle
si Importante ?</a></li>
<li><a href="#représentation-des-nombres" id="toc-représentation-des-nombres"><span class="toc-section-number">4.3</span> Représentation des
Nombres</a></li>
<li><a href="#laddition-binaire" id="toc-laddition-binaire"><span class="toc-section-number">4.4</span> L’Addition Binaire</a></li>
<li><a href="#le-demi-additionneur-half-adder" id="toc-le-demi-additionneur-half-adder"><span class="toc-section-number">4.5</span> Le Demi-Additionneur (Half
Adder)</a></li>
<li><a href="#ladditionneur-complet-full-adder" id="toc-ladditionneur-complet-full-adder"><span class="toc-section-number">4.6</span> L’Additionneur Complet (Full
Adder)</a></li>
<li><a href="#ladditionneur-32-bits-ripple-carry-adder" id="toc-ladditionneur-32-bits-ripple-carry-adder"><span class="toc-section-number">4.7</span> L’Additionneur 32-bits (Ripple
Carry Adder)</a></li>
<li><a href="#lalu-arithmetic-logic-unit" id="toc-lalu-arithmetic-logic-unit"><span class="toc-section-number">4.8</span> L’ALU (Arithmetic Logic
Unit)</a></li>
<li><a href="#architecture-de-lalu" id="toc-architecture-de-lalu"><span class="toc-section-number">4.9</span> Architecture de l’ALU</a></li>
<li><a href="#exercices-pratiques-1" id="toc-exercices-pratiques-1"><span class="toc-section-number">4.10</span> Exercices Pratiques</a></li>
<li><a href="#défis-supplémentaires-1" id="toc-défis-supplémentaires-1"><span class="toc-section-number">4.11</span> Défis Supplémentaires</a></li>
<li><a href="#le-lien-avec-le-cpu" id="toc-le-lien-avec-le-cpu"><span class="toc-section-number">4.12</span> Le Lien avec le CPU</a></li>
<li><a href="#ce-quil-faut-retenir-1" id="toc-ce-quil-faut-retenir-1"><span class="toc-section-number">4.13</span> Ce qu’il faut retenir</a></li>
</ul></li>
<li><a href="#logique-séquentielle-et-mémoire" id="toc-logique-séquentielle-et-mémoire"><span class="toc-section-number">5</span> Logique Séquentielle et Mémoire</a>
<ul>
<li><a href="#où-en-sommes-nous-2" id="toc-où-en-sommes-nous-2"><span class="toc-section-number">5.1</span> Où en sommes-nous ?</a></li>
<li><a href="#pourquoi-la-mémoire-est-elle-fondamentale" id="toc-pourquoi-la-mémoire-est-elle-fondamentale"><span class="toc-section-number">5.2</span> Pourquoi la Mémoire est-elle
Fondamentale ?</a></li>
<li><a href="#le-temps-et-lhorloge-clock" id="toc-le-temps-et-lhorloge-clock"><span class="toc-section-number">5.3</span> Le Temps et l’Horloge
(Clock)</a></li>
<li><a href="#la-bascule-d-d-flip-flop-dff" id="toc-la-bascule-d-d-flip-flop-dff"><span class="toc-section-number">5.4</span> La Bascule D (D Flip-Flop /
DFF)</a></li>
<li><a href="#le-registre-1-bit-bit" id="toc-le-registre-1-bit-bit"><span class="toc-section-number">5.5</span> Le Registre 1-bit (Bit)</a></li>
<li><a href="#le-registre-32-bits" id="toc-le-registre-32-bits"><span class="toc-section-number">5.6</span> Le Registre 32-bits</a></li>
<li><a href="#la-ram-random-access-memory" id="toc-la-ram-random-access-memory"><span class="toc-section-number">5.7</span> La RAM (Random Access
Memory)</a></li>
<li><a href="#le-compteur-de-programme-pc" id="toc-le-compteur-de-programme-pc"><span class="toc-section-number">5.8</span> Le Compteur de Programme
(PC)</a></li>
<li><a href="#les-différents-types-de-mémoire" id="toc-les-différents-types-de-mémoire"><span class="toc-section-number">5.9</span> Les Différents Types de
Mémoire</a></li>
<li><a href="#exercices-pratiques-2" id="toc-exercices-pratiques-2"><span class="toc-section-number">5.10</span> Exercices Pratiques</a></li>
<li><a href="#défis-supplémentaires-2" id="toc-défis-supplémentaires-2"><span class="toc-section-number">5.11</span> Défis Supplémentaires</a></li>
<li><a href="#le-lien-avec-la-suite" id="toc-le-lien-avec-la-suite"><span class="toc-section-number">5.12</span> Le Lien avec la Suite</a></li>
<li><a href="#ce-quil-faut-retenir-2" id="toc-ce-quil-faut-retenir-2"><span class="toc-section-number">5.13</span> Ce qu’il faut retenir</a></li>
</ul></li>
<li><a href="#architecture-machine-isa-a32" id="toc-architecture-machine-isa-a32"><span class="toc-section-number">6</span> Architecture Machine (ISA A32)</a>
<ul>
<li><a href="#où-en-sommes-nous-3" id="toc-où-en-sommes-nous-3"><span class="toc-section-number">6.1</span> Où en sommes-nous ?</a></li>
<li><a href="#quest-ce-quune-architecture" id="toc-quest-ce-quune-architecture"><span class="toc-section-number">6.2</span> Qu’est-ce qu’une Architecture
?</a></li>
<li><a href="#pourquoi-risc-larchitecture-loadstore" id="toc-pourquoi-risc-larchitecture-loadstore"><span class="toc-section-number">6.3</span> Pourquoi RISC ? L’architecture
Load/Store</a></li>
<li><a href="#le-cycle-de-vie-dune-instruction" id="toc-le-cycle-de-vie-dune-instruction"><span class="toc-section-number">6.4</span> Le Cycle de Vie d’une
Instruction</a></li>
<li><a href="#les-registres-le-plan-de-travail" id="toc-les-registres-le-plan-de-travail"><span class="toc-section-number">6.5</span> Les Registres : Le Plan de
Travail</a></li>
<li><a href="#la-carte-mémoire-memory-map" id="toc-la-carte-mémoire-memory-map"><span class="toc-section-number">6.6</span> La Carte Mémoire (Memory
Map)</a></li>
<li><a href="#le-format-des-instructions" id="toc-le-format-des-instructions"><span class="toc-section-number">6.7</span> Le Format des
Instructions</a></li>
<li><a href="#les-instructions-en-détail" id="toc-les-instructions-en-détail"><span class="toc-section-number">6.8</span> Les Instructions en
Détail</a></li>
<li><a href="#la-pile-stack" id="toc-la-pile-stack"><span class="toc-section-number">6.9</span> La Pile (Stack)</a></li>
<li><a href="#exemples-de-programmes" id="toc-exemples-de-programmes"><span class="toc-section-number">6.10</span> Exemples de Programmes</a></li>
<li><a href="#gestion-des-erreurs-traps" id="toc-gestion-des-erreurs-traps"><span class="toc-section-number">6.11</span> Gestion des Erreurs
(Traps)</a></li>
<li><a href="#exercices-pratiques-3" id="toc-exercices-pratiques-3"><span class="toc-section-number">6.12</span> Exercices Pratiques</a></li>
<li><a href="#ce-quil-faut-retenir-3" id="toc-ce-quil-faut-retenir-3"><span class="toc-section-number">6.13</span> Ce qu’il faut retenir</a></li>
</ul></li>
<li><a href="#le-processeur-cpu" id="toc-le-processeur-cpu"><span class="toc-section-number">7</span> Le Processeur (CPU)</a>
<ul>
<li><a href="#où-en-sommes-nous-4" id="toc-où-en-sommes-nous-4"><span class="toc-section-number">7.1</span> Où en sommes-nous ?</a></li>
<li><a href="#quest-ce-quun-cpu" id="toc-quest-ce-quun-cpu"><span class="toc-section-number">7.2</span> Qu’est-ce qu’un CPU ?</a></li>
<li><a href="#architecture-du-cpu-data-path" id="toc-architecture-du-cpu-data-path"><span class="toc-section-number">7.3</span> Architecture du CPU (Data
Path)</a></li>
<li><a href="#les-composants-du-cpu" id="toc-les-composants-du-cpu"><span class="toc-section-number">7.4</span> Les Composants du CPU</a></li>
<li><a href="#le-cycle-dexécution-en-détail" id="toc-le-cycle-dexécution-en-détail"><span class="toc-section-number">7.5</span> Le Cycle d’Exécution en
Détail</a></li>
<li><a href="#implémentation-du-cpu-en-hdl" id="toc-implémentation-du-cpu-en-hdl"><span class="toc-section-number">7.6</span> Implémentation du CPU en
HDL</a></li>
<li><a href="#exercices-pratiques-4" id="toc-exercices-pratiques-4"><span class="toc-section-number">7.7</span> Exercices Pratiques</a></li>
<li><a href="#conseils-de-débogage" id="toc-conseils-de-débogage"><span class="toc-section-number">7.8</span> Conseils de Débogage</a></li>
<li><a href="#aller-plus-loin-le-cpu-pipeline" id="toc-aller-plus-loin-le-cpu-pipeline"><span class="toc-section-number">7.9</span> Aller Plus Loin : Le CPU
Pipeline</a></li>
<li><a href="#le-lien-avec-la-suite-1" id="toc-le-lien-avec-la-suite-1"><span class="toc-section-number">7.10</span> Le Lien avec la Suite</a></li>
<li><a href="#ce-quil-faut-retenir-4" id="toc-ce-quil-faut-retenir-4"><span class="toc-section-number">7.11</span> Ce qu’il faut retenir</a></li>
</ul></li>
<li><a href="#lassembleur" id="toc-lassembleur"><span class="toc-section-number">8</span> L’Assembleur</a>
<ul>
<li><a href="#où-en-sommes-nous-5" id="toc-où-en-sommes-nous-5"><span class="toc-section-number">8.1</span> Où en sommes-nous ?</a></li>
<li><a href="#le-rôle-de-lassembleur" id="toc-le-rôle-de-lassembleur"><span class="toc-section-number">8.2</span> Le Rôle de l’Assembleur</a></li>
<li><a href="#la-stratégie-des-deux-passes" id="toc-la-stratégie-des-deux-passes"><span class="toc-section-number">8.3</span> La Stratégie des Deux
Passes</a></li>
<li><a href="#sections-et-directives" id="toc-sections-et-directives"><span class="toc-section-number">8.4</span> Sections et Directives</a></li>
<li><a href="#exemple-dencodage" id="toc-exemple-dencodage"><span class="toc-section-number">8.5</span> Exemple d’Encodage</a></li>
<li><a href="#la-gestion-des-grandes-constantes" id="toc-la-gestion-des-grandes-constantes"><span class="toc-section-number">8.6</span> La Gestion des Grandes
Constantes</a></li>
<li><a href="#exercices-pratiques-5" id="toc-exercices-pratiques-5"><span class="toc-section-number">8.7</span> Exercices Pratiques</a></li>
<li><a href="#ce-quil-faut-retenir-5" id="toc-ce-quil-faut-retenir-5"><span class="toc-section-number">8.8</span> Ce qu’il faut retenir</a></li>
</ul></li>
<li><a href="#construction-du-compilateur" id="toc-construction-du-compilateur"><span class="toc-section-number">9</span> Construction du Compilateur</a>
<ul>
<li><a href="#où-en-sommes-nous-6" id="toc-où-en-sommes-nous-6"><span class="toc-section-number">9.1</span> Où en sommes-nous ?</a></li>
<li><a href="#le-rôle-du-compilateur" id="toc-le-rôle-du-compilateur"><span class="toc-section-number">9.2</span> Le Rôle du Compilateur</a></li>
<li><a href="#les-phases-du-compilateur" id="toc-les-phases-du-compilateur"><span class="toc-section-number">9.3</span> Les Phases du Compilateur</a></li>
<li><a href="#compilation-des-structures-de-contrôle" id="toc-compilation-des-structures-de-contrôle"><span class="toc-section-number">9.4</span> Compilation des Structures de
Contrôle</a></li>
<li><a href="#compilation-des-fonctions" id="toc-compilation-des-fonctions"><span class="toc-section-number">9.5</span> Compilation des Fonctions</a></li>
<li><a href="#le-compilateur-c32" id="toc-le-compilateur-c32"><span class="toc-section-number">9.6</span> Le Compilateur C32</a></li>
<li><a href="#construisez-votre-propre-compilateur" id="toc-construisez-votre-propre-compilateur"><span class="toc-section-number">9.7</span> Construisez Votre Propre
Compilateur !</a></li>
<li><a href="#exercices-pratiques-6" id="toc-exercices-pratiques-6"><span class="toc-section-number">9.8</span> Exercices Pratiques</a></li>
<li><a href="#ce-quil-faut-retenir-6" id="toc-ce-quil-faut-retenir-6"><span class="toc-section-number">9.9</span> Ce qu’il faut retenir</a></li>
</ul></li>
<li><a href="#langage-de-haut-niveau-c32" id="toc-langage-de-haut-niveau-c32"><span class="toc-section-number">10</span> Langage de Haut Niveau (C32)</a>
<ul>
<li><a href="#où-en-sommes-nous-7" id="toc-où-en-sommes-nous-7"><span class="toc-section-number">10.1</span> Où en sommes-nous ?</a></li>
<li><a href="#pourquoi-un-langage-de-haut-niveau" id="toc-pourquoi-un-langage-de-haut-niveau"><span class="toc-section-number">10.2</span> Pourquoi un Langage de Haut
Niveau ?</a></li>
<li><a href="#spécification-du-langage-c32" id="toc-spécification-du-langage-c32"><span class="toc-section-number">10.3</span> Spécification du Langage
C32</a></li>
<li><a href="#opérateurs" id="toc-opérateurs"><span class="toc-section-number">10.4</span> Opérateurs</a></li>
<li><a href="#structures-de-contrôle" id="toc-structures-de-contrôle"><span class="toc-section-number">10.5</span> Structures de Contrôle</a></li>
<li><a href="#fonctions" id="toc-fonctions"><span class="toc-section-number">10.6</span> Fonctions</a></li>
<li><a href="#pointeurs-et-tableaux" id="toc-pointeurs-et-tableaux"><span class="toc-section-number">10.7</span> Pointeurs et Tableaux</a></li>
<li><a href="#accès-au-matériel-mmio" id="toc-accès-au-matériel-mmio"><span class="toc-section-number">10.8</span> Accès au Matériel (MMIO)</a></li>
<li><a href="#exemple-complet-1" id="toc-exemple-complet-1"><span class="toc-section-number">10.9</span> Exemple Complet</a></li>
<li><a href="#exercices-pratiques-7" id="toc-exercices-pratiques-7"><span class="toc-section-number">10.10</span> Exercices Pratiques</a></li>
<li><a href="#les-structures-structs" id="toc-les-structures-structs"><span class="toc-section-number">10.11</span> Les Structures
(Structs)</a></li>
<li><a href="#limitations-du-c32" id="toc-limitations-du-c32"><span class="toc-section-number">10.12</span> Limitations du C32</a></li>
<li><a href="#ce-quil-faut-retenir-7" id="toc-ce-quil-faut-retenir-7"><span class="toc-section-number">10.13</span> Ce qu’il faut retenir</a></li>
</ul></li>
<li><a href="#système-dexploitation" id="toc-système-dexploitation"><span class="toc-section-number">11</span> Système d’Exploitation</a>
<ul>
<li><a href="#où-en-sommes-nous-8" id="toc-où-en-sommes-nous-8"><span class="toc-section-number">11.1</span> Où en sommes-nous ?</a></li>
<li><a href="#quest-ce-quun-système-dexploitation" id="toc-quest-ce-quun-système-dexploitation"><span class="toc-section-number">11.2</span> Qu’est-ce qu’un Système
d’Exploitation ?</a></li>
<li><a href="#gestion-de-la-mémoire-le-tas-heap" id="toc-gestion-de-la-mémoire-le-tas-heap"><span class="toc-section-number">11.3</span> Gestion de la Mémoire (Le Tas /
Heap)</a></li>
<li><a href="#bibliothèque-graphique" id="toc-bibliothèque-graphique"><span class="toc-section-number">11.4</span> Bibliothèque Graphique</a></li>
<li><a href="#entrées-sorties" id="toc-entrées-sorties"><span class="toc-section-number">11.5</span> Entrées / Sorties</a></li>
<li><a href="#interruptions-et-timer-concepts" id="toc-interruptions-et-timer-concepts"><span class="toc-section-number">11.6</span> Interruptions et Timer
(Concepts)</a></li>
<li><a href="#applications-démo" id="toc-applications-démo"><span class="toc-section-number">11.7</span> Applications Démo</a></li>
<li><a href="#exercices-pratiques-8" id="toc-exercices-pratiques-8"><span class="toc-section-number">11.8</span> Exercices Pratiques</a></li>
<li><a href="#le-parcours-complet-1" id="toc-le-parcours-complet-1"><span class="toc-section-number">11.9</span> Le Parcours Complet</a></li>
<li><a href="#ce-quil-faut-retenir-8" id="toc-ce-quil-faut-retenir-8"><span class="toc-section-number">11.10</span> Ce qu’il faut retenir</a></li>
<li><a href="#félicitations" id="toc-félicitations"><span class="toc-section-number">11.11</span> Félicitations !</a></li>
</ul></li>
<li><a href="#annexe-tous-les-exercices" id="toc-annexe-tous-les-exercices"><span class="toc-section-number">12</span> Annexe : Tous les Exercices</a>
<ul>
<li><a href="#a.-exercices-hdl-portes-logiques" id="toc-a.-exercices-hdl-portes-logiques"><span class="toc-section-number">12.1</span> A. Exercices HDL (Portes
Logiques)</a></li>
<li><a href="#b.-exercices-assembleur-a32" id="toc-b.-exercices-assembleur-a32"><span class="toc-section-number">12.2</span> B. Exercices Assembleur
A32</a></li>
<li><a href="#c.-exercices-c32" id="toc-c.-exercices-c32"><span class="toc-section-number">12.3</span> C. Exercices C32</a></li>
<li><a href="#d.-construction-du-compilateur" id="toc-d.-construction-du-compilateur"><span class="toc-section-number">12.4</span> D. Construction du
Compilateur</a></li>
<li><a href="#e.-systeme-dexploitation" id="toc-e.-systeme-dexploitation"><span class="toc-section-number">12.5</span> E. Systeme
d’Exploitation</a></li>
<li><a href="#conseils-pour-les-exercices" id="toc-conseils-pour-les-exercices"><span class="toc-section-number">12.6</span> Conseils pour les
Exercices</a></li>
</ul></li>
</ul>
</nav>
<h1 data-number="1" id="larchitecture-codex-guide-de-létudiant"><span class="header-section-number">1</span> L’Architecture Codex : Guide de
l’Étudiant</h1>
<p>Ce livre accompagne le projet <strong>Nand2Tetris-Codex</strong>. Il
a pour but de vous guider pas à pas dans la construction d’un ordinateur
complet, moderne et 32-bits, à partir de rien.</p>
<h2 data-number="1.1" id="table-des-matières"><span class="header-section-number">1.1</span> Table des Matières</h2>
<ol type="1">
<li><strong><a href="00_introduction.md">Introduction</a></strong>
<ul>
<li>La philosophie du projet.</li>
<li>Différences avec le Hack (Nand2Tetris original).</li>
<li>Présentation des outils.</li>
</ul></li>
<li><strong><a href="01_logique_booleenne.md">Chapitre 1 : Logique
Booléenne</a></strong>
<ul>
<li>L’abstraction binaire.</li>
<li>Les portes logiques fondamentales (Nand, And, Or, Xor).</li>
<li><em>Exercices :</em> Implémentation dans
<code>hdl_lib/01_gates</code>.</li>
</ul></li>
<li><strong><a href="02_arithmetique.md">Chapitre 2 : Arithmétique
Binaire</a></strong> <em>(À venir)</em>
<ul>
<li>Représentation des nombres (Complément à 2).</li>
<li>Additionneurs et ALU (Arithmetic Logic Unit).</li>
<li><em>Exercices :</em> <code>hdl_lib/03_arith</code>.</li>
</ul></li>
<li><strong><a href="03_memoire.md">Chapitre 3 : Logique Séquentielle et
Mémoire</a></strong> <em>(À venir)</em>
<ul>
<li>Le temps et l’horloge.</li>
<li>Flip-Flops, Registres et RAM.</li>
<li><em>Exercices :</em> <code>hdl_lib/04_seq</code> &amp;
<code>02_multibit</code>.</li>
</ul></li>
<li><strong><a href="04_architecture.md">Chapitre 4 : Architecture
Machine (ISA A32)</a></strong> <em>(À venir)</em>
<ul>
<li>Le jeu d’instructions A32-Lite.</li>
<li>Registres, adressage et structure.</li>
<li><em>Référence :</em> <code>SPECS.md</code>.</li>
</ul></li>
<li><strong><a href="05_cpu.md">Chapitre 5 : Le Processeur
(CPU)</a></strong> <em>(À venir)</em>
<ul>
<li>Implémentation du chemin de données (Data Path).</li>
<li>Logique de contrôle.</li>
<li><em>Exercices :</em> <code>hdl_lib/05_cpu</code>.</li>
</ul></li>
<li><strong><a href="06_assembleur.md">Chapitre 6 :
L’Assembleur</a></strong> <em>(À venir)</em>
<ul>
<li>Traduction symbolique vers binaire.</li>
<li>Gestion des symboles et des labels.</li>
<li><em>Outils :</em> <code>a32_asm</code>.</li>
</ul></li>
<li><strong><a href="07_compilateur.md">Chapitre 7 : Construction du
Compilateur</a></strong> <em>(À venir)</em>
<ul>
<li>Analyse lexicale et syntaxique (Parsing).</li>
<li>Génération de code pour pile.</li>
<li><em>Outils :</em> <code>c32_cli</code>.</li>
</ul></li>
<li><strong><a href="08_langage.md">Chapitre 8 : Langage de Haut Niveau
(C32)</a></strong> <em>(À venir)</em>
<ul>
<li>Syntaxe du langage C32.</li>
<li>Structures de contrôle et types.</li>
</ul></li>
<li><strong><a href="09_os.md">Chapitre 9 : Système
d’Exploitation</a></strong> <em>(À venir)</em>
<ul>
<li>Gestion de la mémoire (Heap).</li>
<li>Entrées/Sorties (Clavier, Écran).</li>
<li><em>Exercices :</em> <code>os_lib</code>.</li>
</ul></li>
</ol>
<h2 data-number="1.2" id="comment-utiliser-ce-guide"><span class="header-section-number">1.2</span> Comment utiliser ce guide</h2>
<p>Chaque chapitre commence par une <strong>Théorie</strong>, expliquant
les concepts fondamentaux. Ensuite, la section
<strong>Implémentation</strong> détaille ce que vous devez construire,
en faisant référence aux dossiers du projet.</p>
<blockquote>
<p><strong>Note :</strong> Ce projet utilise Rust pour l’outillage, mais
votre travail consistera principalement à écrire du HDL (Hardware
Description Language), de l’assembleur A32 et du C32.</p>
</blockquote>
<h1 data-number="2" id="introduction"><span class="header-section-number">2</span> Introduction</h1>
<p>Bienvenue dans le projet <strong>Codex</strong>. Si vous lisez ceci,
c’est que vous avez l’ambition de comprendre comment fonctionnent les
ordinateurs — non pas en lisant des théories abstraites, mais en en
construisant un vous-même, de zéro.</p>
<h2 data-number="2.1" id="le-mystère-de-lordinateur"><span class="header-section-number">2.1</span> Le Mystère de l’Ordinateur</h2>
<p>Prenez un instant pour réfléchir à ce qui se passe quand vous tapez
une lettre sur votre clavier :</p>
<ol type="1">
<li>Vos doigts appuient sur une touche physique</li>
<li>Un signal électrique est envoyé</li>
<li>Ce signal est transformé en code numérique</li>
<li>Le processeur le détecte et l’interprète</li>
<li>Un programme décide quoi faire de cette information</li>
<li>Des pixels s’allument sur votre écran pour afficher la lettre</li>
</ol>
<p>Entre votre doigt et le pixel, il y a des <strong>dizaines de couches
d’abstraction</strong>. Chaque couche fait confiance à celle en dessous
et simplifie la vie de celle au-dessus.</p>
<p>Ce livre va vous faire traverser <strong>toutes ces couches</strong>,
de la plus basse (les portes logiques) à la plus haute (les
applications).</p>
<h2 data-number="2.2" id="pourquoi-construire-un-ordinateur"><span class="header-section-number">2.2</span> Pourquoi Construire un
Ordinateur ?</h2>
<h3 data-number="2.2.1" id="le-problème-de-la-boîte-noire"><span class="header-section-number">2.2.1</span> Le problème de la “boîte
noire”</h3>
<p>Dans notre vie quotidienne, l’ordinateur est une “boîte noire”. Nous
tapons sur un clavier, touchons un écran, et la magie opère. En tant
qu’ingénieurs logiciels, nous travaillons souvent sur des couches
d’abstraction très élevées (Python, Java, React).</p>
<p>Cette abstraction est une bénédiction pour la productivité, mais elle
crée un <strong>fossé de compréhension</strong>. Combien de développeurs
savent vraiment : - Comment le processeur exécute leur code ? - Pourquoi
certaines opérations sont rapides et d’autres lentes ? - Ce qui se passe
quand on écrit <code>x = 5</code> ? - Comment une image apparaît à
l’écran ?</p>
<h3 data-number="2.2.2" id="lapproche-du-nand-au-tetris"><span class="header-section-number">2.2.2</span> L’approche “Du NAND au
Tetris”</h3>
<p>Ce projet a pour but de <strong>briser l’abstraction</strong>. Nous
allons descendre au niveau le plus bas — la porte logique — et remonter
couche par couche jusqu’à pouvoir jouer à un jeu vidéo écrit dans un
langage de haut niveau sur notre propre machine.</p>
<p>À la fin de ce parcours, quand vous verrez du code s’exécuter, vous
saurez <strong>exactement</strong> ce qui se passe dans la machine. Ce
n’est plus de la magie — c’est de l’ingénierie que vous maîtrisez.</p>
<h2 data-number="2.3" id="ce-que-vous-allez-construire"><span class="header-section-number">2.3</span> Ce que Vous Allez
Construire</h2>
<p>Voici les couches que nous allons traverser, de bas en haut :</p>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                     COUCHE 7: Applications                       │
│              (Jeux, Shell, Calculatrice, Éditeur)                │
│                                                                  │
│   C&#39;est ce que l&#39;utilisateur voit et utilise. Tout le reste     │
│   n&#39;existe que pour rendre cette couche possible.                │
├─────────────────────────────────────────────────────────────────┤
│                  COUCHE 6: Système d&#39;Exploitation                │
│           (Gestion mémoire, Drivers écran/clavier)               │
│                                                                  │
│   L&#39;OS cache la complexité du matériel. Au lieu de manipuler    │
│   des adresses, on appelle draw_pixel() ou read_key().          │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 5: Langage de Haut Niveau (C32)           │
│                    (Variables, fonctions, boucles)               │
│                                                                  │
│   On écrit du code lisible par un humain. Le compilateur        │
│   le transforme en instructions machine.                         │
├─────────────────────────────────────────────────────────────────┤
│                      COUCHE 4: Compilateur                       │
│               (Transforme C32 → Assembleur A32)                  │
│                                                                  │
│   Le compilateur est un traducteur automatique. Il comprend     │
│   votre intention et génère le code équivalent.                  │
├─────────────────────────────────────────────────────────────────┤
│                   COUCHE 3: Assembleur (A32 ASM)                 │
│               (Mnémoniques → Code machine binaire)               │
│                                                                  │
│   L&#39;assembleur traduit les instructions humainement lisibles    │
│   (ADD, MOV) en suites de 0 et de 1 que le CPU comprend.        │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 2: Architecture Machine (ISA)             │
│          (Jeu d&#39;instructions, Registres, Mémoire)                │
│                                                                  │
│   C&#39;est le &quot;contrat&quot; entre le matériel et le logiciel.          │
│   Il définit ce que le processeur sait faire.                    │
├─────────────────────────────────────────────────────────────────┤
│                    COUCHE 1: Logique Matérielle                  │
│               (Portes logiques, ALU, RAM, CPU)                   │
│                                                                  │
│   Des circuits électroniques qui ne connaissent que 0 et 1,     │
│   mais qui, combinés intelligemment, peuvent tout calculer.      │
├─────────────────────────────────────────────────────────────────┤
│                     COUCHE 0: La Porte NAND                      │
│                    (Notre axiome de départ)                      │
│                                                                  │
│   Tout commence ici. Une seule porte logique, et à partir       │
│   d&#39;elle, nous construisons tout le reste.                       │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<h3 data-number="2.3.1" id="la-beauté-de-labstraction"><span class="header-section-number">2.3.1</span> La beauté de
l’abstraction</h3>
<p>Chaque couche a une propriété remarquable : <strong>elle n’a besoin
de connaître que la couche juste en dessous</strong>.</p>
<ul>
<li>Le programmeur C32 n’a pas besoin de savoir comment fonctionne
l’ALU</li>
<li>L’ALU n’a pas besoin de savoir qu’elle va être utilisée pour un jeu
vidéo</li>
<li>La porte NAND ne “sait” pas qu’elle fait partie d’un ordinateur</li>
</ul>
<p>Cette séparation des préoccupations est ce qui rend possible la
construction de systèmes complexes.</p>
<h2 data-number="2.4" id="codex-vs-hack-nand2tetris-original"><span class="header-section-number">2.4</span> Codex vs Hack (Nand2Tetris
Original)</h2>
<p>Ce cours est fortement inspiré du légendaire “Nand2Tetris” de Noam
Nisan et Shimon Schocken. Cependant, l’ordinateur <em>Hack</em> original
a été conçu pour une simplicité maximale, parfois au détriment du
réalisme moderne.</p>
<p>L’ordinateur <strong>Codex</strong> propose une approche différente
:</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Caractéristique</th>
<th style="text-align: left;">Hack (Original)</th>
<th style="text-align: left;">Codex (Ce projet)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Architecture</strong></td>
<td style="text-align: left;">16-bits</td>
<td style="text-align: left;"><strong>32-bits</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Registres</strong></td>
<td style="text-align: left;">2 (A et D)</td>
<td style="text-align: left;"><strong>16 (R0-R15)</strong> style
ARM</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Mémoire</strong></td>
<td style="text-align: left;">Séparée (Harvard)</td>
<td style="text-align: left;"><strong>Unifiée</strong> (Von
Neumann)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Instructions</strong></td>
<td style="text-align: left;">Simple, propriétaire</td>
<td style="text-align: left;"><strong>RISC moderne</strong>
(Load/Store)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Écran</strong></td>
<td style="text-align: left;">Monochrome fixe</td>
<td style="text-align: left;"><strong>320×240 couleurs</strong></td>
</tr>
</tbody>
</table>
<h3 data-number="2.4.1" id="pourquoi-ces-changements"><span class="header-section-number">2.4.1</span> Pourquoi ces changements
?</h3>
<ol type="1">
<li><p><strong>32 bits</strong> : C’est la taille standard des machines
modernes (avant 64 bits). Cela permet d’adresser 4 Go de mémoire et de
manipuler des nombres plus grands.</p></li>
<li><p><strong>16 registres</strong> : Les processeurs ARM (smartphones,
Raspberry Pi) utilisent aussi des registres R0-R15. Comprendre Codex,
c’est comprendre ARM.</p></li>
<li><p><strong>Architecture RISC</strong> : Les instructions sont
simples et régulières. Le CPU fait une chose à la fois, mais le fait
vite.</p></li>
<li><p><strong>Load/Store</strong> : Le CPU ne calcule jamais
directement en mémoire. Il charge d’abord les données dans des
registres, calcule, puis stocke le résultat. C’est plus simple à
implémenter et à comprendre.</p></li>
</ol>
<h2 data-number="2.5" id="ce-que-vous-allez-apprendre"><span class="header-section-number">2.5</span> Ce que Vous Allez
Apprendre</h2>
<p>À la fin de ce livre, vous saurez :</p>
<p><strong>Au niveau matériel :</strong> - Comment construire des portes
logiques à partir de NAND - Comment un additionneur transforme des bits
en nombres - Comment la mémoire “se souvient” des données - Comment le
CPU orchestre tout cela</p>
<p><strong>Au niveau logiciel :</strong> - Comment l’assembleur traduit
les mnémoniques en binaire - Comment un compilateur transforme du code
lisible en instructions - Comment un OS simplifie l’accès au matériel -
Comment une application utilise toutes ces couches</p>
<p><strong>Au niveau conceptuel :</strong> - Pourquoi les ordinateurs
utilisent le binaire - Comment l’abstraction permet de gérer la
complexité - Pourquoi certaines opérations sont “coûteuses” - Comment le
même matériel peut faire des choses très différentes</p>
<h2 data-number="2.6" id="vos-outils"><span class="header-section-number">2.6</span> Vos Outils</h2>
<p>Le projet est fourni avec une suite d’outils performants :</p>
<h3 data-number="2.6.1" id="les-outils-en-ligne-de-commande"><span class="header-section-number">2.6.1</span> Les Outils en Ligne de
Commande</h3>
<table>
<colgroup>
<col style="width: 31%" />
<col style="width: 27%" />
<col style="width: 40%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Outil</th>
<th style="text-align: left;">Rôle</th>
<th style="text-align: left;">Exemple</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>hdl_cli</code></td>
<td style="text-align: left;">Simule vos circuits HDL</td>
<td style="text-align: left;"><code>hdl_cli test Not.hdl</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>a32_cli</code></td>
<td style="text-align: left;">Assemble le code A32 → binaire</td>
<td style="text-align: left;"><code>a32_cli prog.s -o prog.bin</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>c32_cli</code></td>
<td style="text-align: left;">Compile le code C32 → assembleur</td>
<td style="text-align: left;"><code>c32_cli prog.c -o prog.s</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>a32_runner</code></td>
<td style="text-align: left;">Exécute le code binaire</td>
<td style="text-align: left;"><code>a32_runner prog.bin</code></td>
</tr>
</tbody>
</table>
<h3 data-number="2.6.2" id="le-simulateur-web-recommandé"><span class="header-section-number">2.6.2</span> Le Simulateur Web
(Recommandé)</h3>
<p>Pour une expérience plus visuelle et interactive, utilisez le
<strong>Simulateur Web</strong>. Il vous permet de : - Écrire et tester
votre HDL directement dans le navigateur - Voir l’état des signaux en
temps réel avec des chronogrammes - Compiler et exécuter du code C et
Assembleur - Visualiser l’écran, les registres et la mémoire</p>
<p>Pour le lancer :</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> web</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> install</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> run dev</span></code></pre></div>
<p>Ouvrez ensuite votre navigateur à l’adresse indiquée (généralement
<code>http://localhost:5173</code>).</p>
<h2 data-number="2.7" id="comment-utiliser-ce-livre"><span class="header-section-number">2.7</span> Comment Utiliser ce Livre</h2>
<h3 data-number="2.7.1" id="lapproche-recommandée"><span class="header-section-number">2.7.1</span> L’approche recommandée</h3>
<ol type="1">
<li><strong>Lisez chaque chapitre en entier</strong> avant de commencer
les exercices</li>
<li><strong>Faites les exercices dans l’ordre</strong> — chaque exercice
prépare le suivant</li>
<li><strong>Ne regardez pas les solutions</strong> avant d’avoir
vraiment essayé</li>
<li><strong>Utilisez le simulateur web</strong> pour visualiser ce qui
se passe</li>
<li><strong>Reliez toujours à l’ensemble</strong> — demandez-vous “où
cela s’insère-t-il ?”</li>
</ol>
<h3 data-number="2.7.2" id="si-vous-êtes-bloqué"><span class="header-section-number">2.7.2</span> Si vous êtes bloqué</h3>
<ul>
<li>Relisez la section correspondante du chapitre</li>
<li>Vérifiez que vous avez bien compris les exercices précédents</li>
<li>Utilisez le débogueur visuel du simulateur web</li>
<li>Les erreurs les plus fréquentes sont des problèmes de câblage
(mauvaises connexions)</li>
</ul>
<h2 data-number="2.8" id="la-grande-aventure-commence"><span class="header-section-number">2.8</span> La Grande Aventure
Commence</h2>
<p>Vous êtes sur le point d’entreprendre un voyage fascinant. Chaque
chapitre vous rapprochera un peu plus de la compréhension totale de la
machine.</p>
<p>Quand vous aurez terminé, vous regarderez votre ordinateur
différemment. Ce ne sera plus une boîte noire mystérieuse, mais une
symphonie d’abstractions que vous pouvez comprendre, modifier, et même
reconstruire.</p>
<p>Prêt ? Passons à la première brique élémentaire : la logique
booléenne.</p>
<hr />
<p><strong>Rappel important</strong> : Chaque chapitre de ce livre
construit sur les précédents. Résistez à la tentation de sauter des
étapes — la compréhension profonde vient de la construction
progressive.</p>
<h1 data-number="3" id="logique-booléenne"><span class="header-section-number">3</span> Logique Booléenne</h1>
<blockquote>
<p>“Au commencement était le NAND.”</p>
</blockquote>
<p>Tout ordinateur numérique, aussi complexe soit-il, est construit à
partir de concepts incroyablement simples : le Vrai (<code>1</code>) et
le Faux (<code>0</code>). Ce chapitre traite de la construction de
portes logiques élémentaires à partir d’une brique fondamentale : la
porte NAND.</p>
<hr />
<h2 data-number="3.1" id="où-en-sommes-nous"><span class="header-section-number">3.1</span> Où en sommes-nous ?</h2>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                     COUCHE 7: Applications                       │
├─────────────────────────────────────────────────────────────────┤
│                  COUCHE 6: Système d&#39;Exploitation                │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 5: Langage de Haut Niveau (C32)           │
├─────────────────────────────────────────────────────────────────┤
│                      COUCHE 4: Compilateur                       │
├─────────────────────────────────────────────────────────────────┤
│                   COUCHE 3: Assembleur (A32 ASM)                 │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 2: Architecture Machine (ISA)             │
├─────────────────────────────────────────────────────────────────┤
│                    COUCHE 1: Logique Matérielle                  │
│               (Portes logiques, ALU, RAM, CPU)                   │
├─────────────────────────────────────────────────────────────────┤
│  ══════════════► COUCHE 0: La Porte NAND ◄══════════════        │
│                    (Vous êtes ici !)                             │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<p>Nous commençons tout en bas de la pyramide. C’est ici que nous posons
les fondations de tout l’édifice. Chaque porte que vous construirez dans
ce chapitre sera utilisée dans les chapitres suivants pour construire
des circuits de plus en plus complexes, jusqu’au CPU complet.</p>
<hr />
<h2 data-number="3.2" id="pourquoi-le-binaire"><span class="header-section-number">3.2</span> Pourquoi le Binaire ?</h2>
<h3 data-number="3.2.1" id="la-question-fondamentale"><span class="header-section-number">3.2.1</span> La question fondamentale</h3>
<p>Avant de construire des portes logiques, posons-nous une question
essentielle : <strong>pourquoi les ordinateurs utilisent-ils le binaire
(0 et 1) plutôt que le système décimal (0-9) que nous utilisons au
quotidien ?</strong></p>
<p>La réponse est d’ordre <strong>physique et pratique</strong> :</p>
<ol type="1">
<li><p><strong>Fiabilité</strong> : Distinguer entre deux états (tension
haute/basse, courant/pas courant) est beaucoup plus fiable que de
distinguer entre dix niveaux différents. Le bruit électrique peut
facilement transformer un “7” en “8”, mais rarement un “1” en
“0”.</p></li>
<li><p><strong>Simplicité</strong> : Les circuits qui ne gèrent que deux
états sont beaucoup plus simples à concevoir et à fabriquer. Un
transistor peut facilement agir comme un interrupteur (on/off).</p></li>
<li><p><strong>Universalité</strong> : George Boole a prouvé au 19ème
siècle que toute la logique peut être exprimée avec seulement deux
valeurs : Vrai et Faux.</p></li>
</ol>
<h3 data-number="3.2.2" id="du-voltage-au-bit"><span class="header-section-number">3.2.2</span> Du voltage au bit</h3>
<p>Dans le monde physique, nos ordinateurs utilisent des tensions
électriques :</p>
<table>
<thead>
<tr class="header">
<th>Tension</th>
<th>Signification logique</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0V - 0.8V</td>
<td><code>0</code> (Faux)</td>
</tr>
<tr class="even">
<td>2.4V - 3.3V</td>
<td><code>1</code> (Vrai)</td>
</tr>
</tbody>
</table>
<p>La zone entre 0.8V et 2.4V est une “zone interdite” — les circuits
sont conçus pour ne jamais s’y trouver de manière stable. C’est cette
séparation nette qui rend le binaire si robuste.</p>
<h3 data-number="3.2.3" id="labstraction-qui-libère"><span class="header-section-number">3.2.3</span> L’abstraction qui libère</h3>
<p>En tant qu’architectes système, nous n’avons pas besoin de penser aux
voltages, aux électrons, ou aux transistors. Nous travaillons avec des
<strong>abstractions</strong> : - Un <strong>bit</strong> peut valoir 0
ou 1 - Une <strong>fonction booléenne</strong> transforme des bits en
d’autres bits</p>
<p>C’est la première de nombreuses couches d’abstraction que nous allons
traverser. Chaque couche nous permet de penser à un niveau supérieur
sans nous soucier des détails de la couche inférieure.</p>
<hr />
<h2 data-number="3.3" id="la-porte-nand-notre-axiome"><span class="header-section-number">3.3</span> La Porte NAND : Notre
Axiome</h2>
<h3 data-number="3.3.1" id="pourquoi-partir-du-nand"><span class="header-section-number">3.3.1</span> Pourquoi partir du NAND
?</h3>
<p>Il existe de nombreuses portes logiques (AND, OR, NOT, XOR…), mais
nous choisissons de tout construire à partir d’une seule : la porte
<strong>NAND</strong> (Not-AND).</p>
<p>Pourquoi ce choix ?</p>
<ol type="1">
<li><p><strong>Complétude fonctionnelle</strong> : Le NAND est dit
“fonctionnellement complet” — on peut construire TOUTES les autres
portes logiques à partir de NAND uniquement. C’est mathématiquement
prouvé !</p></li>
<li><p><strong>Réalité industrielle</strong> : La technologie CMOS
(Complementary Metal-Oxide-Semiconductor), utilisée dans tous les
processeurs modernes, implémente naturellement les portes NAND de
manière très efficace — seulement 4 transistors.</p></li>
<li><p><strong>Pédagogie</strong> : Partir d’une seule brique force à
comprendre comment les abstractions se construisent les unes sur les
autres.</p></li>
</ol>
<h3 data-number="3.3.2" id="table-de-vérité-nand"><span class="header-section-number">3.3.2</span> Table de Vérité NAND</h3>
<p>La porte NAND prend deux entrées (A et B) et produit une sortie. Son
comportement :</p>
<table>
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th style="text-align: center;">NAND(A, B)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td style="text-align: center;"><strong>1</strong></td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td style="text-align: center;"><strong>1</strong></td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td style="text-align: center;"><strong>1</strong></td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td style="text-align: center;"><strong>0</strong></td>
</tr>
</tbody>
</table>
<p><strong>Règle simple</strong> : Le résultat est <code>0</code>
<em>seulement si</em> A <strong>et</strong> B sont tous les deux à
<code>1</code>. Dans tous les autres cas, c’est <code>1</code>.</p>
<p>Le nom “NAND” vient de “Not-AND” : c’est l’inverse exact d’une porte
AND.</p>
<h3 data-number="3.3.3" id="symbole-graphique"><span class="header-section-number">3.3.3</span> Symbole graphique</h3>
<pre><code>       ┌───────┐
 A ────┤       │
       │ NAND  ├○── Y
 B ────┤       │
       └───────┘

Le petit cercle (○) indique l&#39;inversion</code></pre>
<hr />
<h2 data-number="3.4" id="construction-des-portes-élémentaires"><span class="header-section-number">3.4</span> Construction des Portes
Élémentaires</h2>
<p>Votre mission dans ce chapitre est de construire les portes
suivantes, en utilisant <strong>uniquement</strong> des NAND (et les
portes que vous aurez déjà créées).</p>
<h3 data-number="3.4.1" id="a.-not-inverseur-linversion-de-la-réalité"><span class="header-section-number">3.4.1</span> A. NOT (Inverseur) —
L’inversion de la réalité</h3>
<p><strong>Rôle dans l’ordinateur</strong> : L’inverseur est
fondamental. Il permet de créer des conditions négatives (“si PAS
égal…”), de complémenter des nombres (pour la soustraction), et
d’implémenter des bascules (pour la mémoire).</p>
<p><strong>Spécification</strong> : | in | out | |—-|—–| | 0 | 1 | | 1 |
0 |</p>
<p><strong>Le défi</strong> : Comment utiliser une porte NAND (qui prend
2 entrées) pour n’en traiter qu’une seule ?</p>
<p><strong>L’astuce</strong> : Connectez le même signal aux deux entrées
!</p>
<pre><code>         ┌───────┐
 in ─────┤       │
         │ NAND  ├──── out
 in ─────┤       │
         └───────┘</code></pre>
<p>Vérifions avec la table de vérité : - Si <code>in = 0</code> :
NAND(0, 0) = 1 ✓ - Si <code>in = 1</code> : NAND(1, 1) = 0 ✓</p>
<p>C’est exactement le comportement NOT !</p>
<hr />
<h3 data-number="3.4.2" id="b.-and-et-la-conjonction"><span class="header-section-number">3.4.2</span> B. AND (Et) — La
conjonction</h3>
<p><strong>Rôle dans l’ordinateur</strong> : La porte AND est
essentielle pour : - Extraire des bits spécifiques d’un nombre
(masquage) - Vérifier que TOUTES les conditions sont vraies - Contrôler
le passage de données (avec un signal d’activation)</p>
<p><strong>Spécification</strong> : | A | B | AND(A, B) | |—|—|:———:| |
0 | 0 | 0 | | 0 | 1 | 0 | | 1 | 0 | 0 | | 1 | 1 | 1 |</p>
<p><strong>La sortie vaut 1 seulement si A ET B valent 1.</strong></p>
<p><strong>L’insight</strong> : Le NAND est un “Not-AND”. Si on inverse
le résultat d’un NAND… on obtient un AND !</p>
<pre><code>         ┌───────┐      ┌─────┐
 A ──────┤       │      │     │
         │ NAND  ├──────┤ NOT ├──── out
 B ──────┤       │      │     │
         └───────┘      └─────┘</code></pre>
<p>Formule : <code>AND(A, B) = NOT(NAND(A, B))</code></p>
<hr />
<h3 data-number="3.4.3" id="c.-or-ou-lalternative"><span class="header-section-number">3.4.3</span> C. OR (Ou) —
L’alternative</h3>
<p><strong>Rôle dans l’ordinateur</strong> : La porte OR permet de : -
Combiner plusieurs signaux de contrôle - Vérifier qu’AU MOINS UNE
condition est vraie - Créer des priorités (interruptions, erreurs)</p>
<p><strong>Spécification</strong> : | A | B | OR(A, B) | |—|—|:——–:| | 0
| 0 | 0 | | 0 | 1 | 1 | | 1 | 0 | 1 | | 1 | 1 | 1 |</p>
<p><strong>La sortie vaut 1 si au moins une entrée vaut 1.</strong></p>
<p><strong>Le Théorème de De Morgan</strong> : Ce théorème fondamental
nous donne la clé :</p>
<pre><code>A OR B = NOT( (NOT A) AND (NOT B) )</code></pre>
<p>En utilisant uniquement des NAND :</p>
<pre><code>A OR B = (NOT A) NAND (NOT B)</code></pre>
<pre><code>         ┌─────┐
 A ──────┤ NOT ├──────┐
         └─────┘      │    ┌───────┐
                      ├────┤       │
                           │ NAND  ├──── out
                      ├────┤       │
         ┌─────┐      │    └───────┘
 B ──────┤ NOT ├──────┘
         └─────┘</code></pre>
<hr />
<h3 data-number="3.4.4" id="d.-xor-ou-exclusif-la-différence"><span class="header-section-number">3.4.4</span> D. XOR (Ou Exclusif) — La
différence</h3>
<p><strong>Rôle dans l’ordinateur</strong> : XOR est crucial pour : -
<strong>L’addition binaire</strong> : XOR calcule la somme de deux bits
(sans la retenue) - <strong>La comparaison</strong> : XOR détecte si
deux bits sont différents - <strong>Le cryptage</strong> : XOR est au
cœur de nombreux algorithmes de chiffrement - <strong>La détection
d’erreurs</strong> : Calcul de parité</p>
<p><strong>Spécification</strong> : | A | B | XOR(A, B) | |—|—|:———:| |
0 | 0 | 0 | | 0 | 1 | 1 | | 1 | 0 | 1 | | 1 | 1 | 0 |</p>
<p><strong>La sortie vaut 1 si les entrées sont
<em>différentes</em>.</strong></p>
<p><strong>Formule algébrique</strong> :</p>
<pre><code>XOR(A, B) = (A AND NOT B) OR (NOT A AND B)</code></pre>
<p>En mots : “A est vrai et B est faux” OU “A est faux et B est
vrai”.</p>
<hr />
<h3 data-number="3.4.5" id="e.-multiplexeur-mux-laiguilleur"><span class="header-section-number">3.4.5</span> E. Multiplexeur (Mux) —
L’aiguilleur</h3>
<p><strong>Rôle dans l’ordinateur</strong> : Le multiplexeur est l’un
des composants les plus importants ! Il permet de : - <strong>Choisir
entre plusieurs sources de données</strong> : Comme un aiguillage de
train - <strong>Implémenter les conditions</strong> :
<code>if (sel) then b else a</code> - <strong>Construire la
mémoire</strong> : Sélectionner quelle cellule lire</p>
<p><strong>Spécification</strong> : - Si <code>sel == 0</code> alors
<code>out = a</code> - Si <code>sel == 1</code> alors
<code>out = b</code></p>
<pre><code>           ┌─────────┐
     a ────┤         │
           │   MUX   ├──── out
     b ────┤         │
           └────┬────┘
                │
              sel</code></pre>
<p><strong>L’insight</strong> : On peut voir le Mux comme : “soit (a ET
non-sel) soit (b ET sel)”.</p>
<pre><code>out = (a AND NOT sel) OR (b AND sel)</code></pre>
<p><strong>Pourquoi le Mux est-il si important ?</strong></p>
<p>Imaginez que vous construisez un CPU. À chaque cycle, le CPU doit
choisir : - D’où vient l’opérande ? De la mémoire ou d’un registre ? -
Où va le résultat ? Vers la mémoire ou un registre ? - Quelle
instruction exécuter ?</p>
<p>Chacun de ces choix est implémenté par un multiplexeur !</p>
<hr />
<h3 data-number="3.4.6" id="f.-démultiplexeur-dmux-linverse-de-laiguilleur"><span class="header-section-number">3.4.6</span> F. Démultiplexeur (DMux) —
L’inverse de l’aiguilleur</h3>
<p><strong>Rôle dans l’ordinateur</strong> : Le DMux fait l’inverse du
Mux — il prend UNE entrée et la dirige vers UNE des sorties possibles.
Utile pour : - <strong>L’adressage mémoire</strong> : Activer la bonne
cellule - <strong>La distribution de signaux</strong> : Envoyer une
commande au bon périphérique</p>
<p><strong>Spécification</strong> : - Si <code>sel == 0</code> alors
<code>a = in, b = 0</code> - Si <code>sel == 1</code> alors
<code>a = 0, b = in</code></p>
<pre><code>              ┌─────────┐
              │         ├──── a
     in ──────┤  DMUX   │
              │         ├──── b
              └────┬────┘
                   │
                 sel</code></pre>
<hr />
<h2 data-number="3.5" id="le-lien-avec-lordinateur-complet"><span class="header-section-number">3.5</span> Le Lien avec l’Ordinateur
Complet</h2>
<p>Prenons du recul. Pourquoi construisons-nous ces portes ?</p>
<h3 data-number="3.5.1" id="du-nand-au-cpu-la-feuille-de-route"><span class="header-section-number">3.5.1</span> Du NAND au CPU : La feuille
de route</h3>
<pre><code>CHAPITRE 1 (Ici)     CHAPITRE 2          CHAPITRE 3         CHAPITRE 5
     ↓                    ↓                   ↓                  ↓
   NAND             Half Adder            DFF (Flip-Flop)       CPU
     ↓                    ↓                   ↓                  ↓
NOT, AND, OR  →    Full Adder      →    Registres      →    Ordinateur
XOR, Mux, DMux          ↓                   ↓                complet !
                      ALU              RAM (Mémoire)</code></pre>
<p><strong>Chaque porte a un rôle précis</strong> : -
<strong>NOT</strong> : Permet la soustraction (via le complément à 2) -
<strong>AND</strong> : Masquage de bits, conditions ET -
<strong>OR</strong> : Combinaison de signaux, conditions OU -
<strong>XOR</strong> : Addition bit à bit, comparaisons -
<strong>Mux</strong> : Tous les choix du CPU (quelle donnée ? quelle
opération ?) - <strong>DMux</strong> : Adressage mémoire, routage des
résultats</p>
<p>Quand vous jouerez à un jeu sur votre ordinateur Codex au Chapitre 9,
chaque pixel affiché à l’écran aura été calculé par des millions
d’opérations utilisant ces portes élémentaires !</p>
<hr />
<h2 data-number="3.6" id="description-matérielle-codex-hdl"><span class="header-section-number">3.6</span> Description Matérielle (Codex
HDL)</h2>
<p>Pour décrire nos circuits, nous utilisons un langage appelé
<strong>HDL</strong> (Hardware Description Language). C’est un langage
<strong>déclaratif</strong> : on décrit QUELS composants existent et
COMMENT ils sont connectés, pas DANS QUEL ORDRE les exécuter.</p>
<h3 data-number="3.6.1" id="pourquoi-un-langage-de-description"><span class="header-section-number">3.6.1</span> Pourquoi un langage de
description ?</h3>
<p>En électronique réelle, on dessine des schémas. Mais les schémas
deviennent illisibles pour des circuits complexes (un CPU contient des
millions de portes !). Le HDL permet de : 1. <strong>Décrire</strong>
des circuits de manière textuelle 2. <strong>Simuler</strong> leur
comportement avant fabrication 3. <strong>Synthétiser</strong> le
circuit vers du matériel réel</p>
<p>Notre HDL est inspiré du <strong>VHDL</strong> (Very High-Speed
Integrated Circuit HDL), utilisé dans l’industrie.</p>
<h3 data-number="3.6.2" id="structure-dun-fichier-.hdl"><span class="header-section-number">3.6.2</span> Structure d’un fichier
<code>.hdl</code></h3>
<p>Un fichier HDL se compose de deux parties :</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ============================================================</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1. L&#39;ENTITÉ : L&#39;interface externe (les &quot;broches&quot; de la puce)</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- ============================================================</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="cf">entity</span> <span class="dv">NomDeLaPuce</span> <span class="kw">is</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">port</span>(</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>;     <span class="co">-- Entrée de 1 bit</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>;     <span class="co">-- Autre entrée</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">:</span> <span class="kw">out</span> <span class="dt">bit</span>     <span class="co">-- Sortie (pas de point-virgule sur la dernière)</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  );</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end entity;</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- ============================================================</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- 2. L&#39;ARCHITECTURE : Le contenu interne (le câblage)</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- ============================================================</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="cf">architecture</span> <span class="dv">rtl</span> <span class="kw">of</span> <span class="fu">NomDeLaPuce</span> <span class="kw">is</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Déclaration des composants utilisés</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">component</span> <span class="dv">Nand</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">port</span>(a <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>; b <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>; y <span class="ot">:</span> <span class="kw">out</span> <span class="dt">bit</span>);</span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end component;</span></span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Déclaration des signaux internes (fils)</span></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> fil_interne <span class="ot">:</span> <span class="dt">bit</span>;</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a><span class="cf">begin</span></span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Instanciation et connexion des composants</span></span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u1</span><span class="ot">:</span> <span class="kw">Nand</span> <span class="kw">port</span> <span class="kw">map</span> (a <span class="ot">=&gt;</span> a<span class="ot">,</span> b <span class="ot">=&gt;</span> b<span class="ot">,</span> y <span class="ot">=&gt;</span> fil_interne);</span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Assignation directe (optionnel)</span></span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;=</span> fil_interne;</span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-31"><a href="#cb15-31" aria-hidden="true" tabindex="-1"></a><span class="cf">end architecture;</span></span></code></pre></div>
<h3 data-number="3.6.3" id="vocabulaire-essentiel"><span class="header-section-number">3.6.3</span> Vocabulaire essentiel</h3>
<table>
<thead>
<tr class="header">
<th>Terme</th>
<th>Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>entity</code></td>
<td>L’interface externe — quelles sont les entrées/sorties</td>
</tr>
<tr class="even">
<td><code>architecture</code></td>
<td>Le contenu — comment c’est câblé à l’intérieur</td>
</tr>
<tr class="odd">
<td><code>component</code></td>
<td>Une puce qu’on veut utiliser (il faut la déclarer)</td>
</tr>
<tr class="even">
<td><code>signal</code></td>
<td>Un fil interne (pour connecter des composants entre eux)</td>
</tr>
<tr class="odd">
<td><code>port map</code></td>
<td>“Brancher” les fils aux broches d’un composant</td>
</tr>
<tr class="even">
<td><code>=&gt;</code></td>
<td>“est connecté à” (broche =&gt; signal)</td>
</tr>
<tr class="odd">
<td><code>&lt;=</code></td>
<td>Assignation (sortie &lt;= signal)</td>
</tr>
</tbody>
</table>
<h3 data-number="3.6.4" id="règles-de-connexion"><span class="header-section-number">3.6.4</span> Règles de connexion</h3>
<ol type="1">
<li><strong>À gauche du <code>=&gt;</code></strong> : Le nom de la
broche du composant que vous utilisez</li>
<li><strong>À droite du <code>=&gt;</code></strong> : Le signal de VOTRE
architecture que vous y connectez</li>
<li><strong>Les signaux doivent être déclarés</strong> avant le
<code>begin</code></li>
<li><strong>Chaque instance a un nom unique</strong> (<code>u1</code>,
<code>u2</code>, etc.)</li>
</ol>
<h3 data-number="3.6.5" id="bus-vecteurs-de-bits"><span class="header-section-number">3.6.5</span> Bus (Vecteurs de bits)</h3>
<p>Pour manipuler plusieurs bits simultanément (ex: un nombre de 32
bits), on utilise <code>bits(MSB downto LSB)</code> :</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Un bus de 32 bits</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>data_bus <span class="ot">:</span> <span class="kw">in</span> bits(<span class="dv">31</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Accéder à un bit spécifique</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>data_bus(<span class="dv">0</span>)   <span class="co">-- Le bit de poids faible (LSB)</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>data_bus(<span class="dv">31</span>)  <span class="co">-- Le bit de poids fort (MSB)</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Extraire une tranche</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>data_bus(<span class="dv">7</span> <span class="ot">downto</span> <span class="dv">0</span>)  <span class="co">-- Les 8 bits de poids faible</span></span></code></pre></div>
<h3 data-number="3.6.6" id="exemple-complet-xor-en-hdl"><span class="header-section-number">3.6.6</span> Exemple complet : XOR en
HDL</h3>
<div class="sourceCode" id="cb17"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- La porte XOR : sortie = 1 si les entrées sont différentes</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- XOR(a,b) = (a AND NOT b) OR (NOT a AND b)</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="cf">entity</span> <span class="dv">Xor2</span> <span class="kw">is</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">port</span>(</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>;</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>;</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">:</span> <span class="kw">out</span> <span class="dt">bit</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>  );</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="cf">end entity;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="cf">architecture</span> <span class="dv">rtl</span> <span class="kw">of</span> <span class="fu">Xor2</span> <span class="kw">is</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Composants utilisés</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">component</span> <span class="dv">Inv</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">port</span>(a <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>; y <span class="ot">:</span> <span class="kw">out</span> <span class="dt">bit</span>);</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end component;</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">component</span> <span class="dv">And2</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">port</span>(a <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>; b <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>; y <span class="ot">:</span> <span class="kw">out</span> <span class="dt">bit</span>);</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end component;</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">component</span> <span class="dv">Or2</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">port</span>(a <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>; b <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>; y <span class="ot">:</span> <span class="kw">out</span> <span class="dt">bit</span>);</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">end component;</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Signaux internes</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> not_a<span class="ot">,</span> not_b <span class="ot">:</span> <span class="dt">bit</span>;  <span class="co">-- Les inversions de a et b</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> w1<span class="ot">,</span> w2 <span class="ot">:</span> <span class="dt">bit</span>;        <span class="co">-- Résultats intermédiaires</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a><span class="cf">begin</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- NOT a et NOT b</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u_nota</span><span class="ot">:</span> <span class="fu">Inv</span> <span class="kw">port map </span>(a <span class="ot">=&gt;</span> a<span class="ot">,</span> y <span class="ot">=&gt;</span> not_a);</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u_notb</span><span class="ot">:</span> <span class="fu">Inv</span> <span class="kw">port map </span>(a <span class="ot">=&gt;</span> b<span class="ot">,</span> y <span class="ot">=&gt;</span> not_b);</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (a AND NOT b)</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u_and1</span><span class="ot">:</span> <span class="fu">And2</span> <span class="kw">port map </span>(a <span class="ot">=&gt;</span> a<span class="ot">,</span> b <span class="ot">=&gt;</span> not_b<span class="ot">,</span> y <span class="ot">=&gt;</span> w1);</span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- (NOT a AND b)</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u_and2</span><span class="ot">:</span> <span class="fu">And2</span> <span class="kw">port map </span>(a <span class="ot">=&gt;</span> not_a<span class="ot">,</span> b <span class="ot">=&gt;</span> b<span class="ot">,</span> y <span class="ot">=&gt;</span> w2);</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Résultat final : OR des deux termes</span></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u_or</span><span class="ot">:</span> <span class="fu">Or2</span> <span class="kw">port map </span>(a <span class="ot">=&gt;</span> w1<span class="ot">,</span> b <span class="ot">=&gt;</span> w2<span class="ot">,</span> y <span class="ot">=&gt;</span> y);</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a><span class="cf">end architecture;</span></span></code></pre></div>
<hr />
<h2 data-number="3.7" id="exercices-pratiques"><span class="header-section-number">3.7</span> Exercices Pratiques</h2>
<h3 data-number="3.7.1" id="exercices-sur-le-simulateur-web"><span class="header-section-number">3.7.1</span> Exercices sur le Simulateur
Web</h3>
<p>Le <strong>Simulateur Web</strong> vous permet de construire et
tester vos portes de manière interactive. Lancez-le et allez dans la
section <strong>HDL Progression</strong>.</p>
<table>
<thead>
<tr class="header">
<th>Exercice</th>
<th>Description</th>
<th style="text-align: center;">Difficulté</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Inv</code></td>
<td>Inverseur (NOT) — Votre première porte</td>
<td style="text-align: center;">⭐</td>
</tr>
<tr class="even">
<td><code>And2</code></td>
<td>Porte AND à 2 entrées</td>
<td style="text-align: center;">⭐</td>
</tr>
<tr class="odd">
<td><code>Or2</code></td>
<td>Porte OR à 2 entrées</td>
<td style="text-align: center;">⭐</td>
</tr>
<tr class="even">
<td><code>Xor2</code></td>
<td>Porte XOR (Ou exclusif)</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="odd">
<td><code>Mux</code></td>
<td>Multiplexeur 2 vers 1</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="even">
<td><code>DMux</code></td>
<td>Démultiplexeur 1 vers 2</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
</tbody>
</table>
<p><strong>Pour chaque exercice</strong> : 1. Lisez la spécification et
la table de vérité 2. Réfléchissez à comment combiner les portes
disponibles 3. Écrivez votre code HDL 4. Testez — le simulateur vous
montrera un chronogramme des signaux 5. Si un test échoue, analysez
quelle entrée produit le mauvais résultat</p>
<h3 data-number="3.7.2" id="comment-lancer-le-simulateur-web"><span class="header-section-number">3.7.2</span> Comment lancer le simulateur
web ?</h3>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="bu">cd</span> web</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> install    <span class="co"># (première fois uniquement)</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="ex">npm</span> run dev</span></code></pre></div>
<p>Puis ouvrez votre navigateur à l’adresse indiquée (généralement
<code>http://localhost:5173</code>).</p>
<h3 data-number="3.7.3" id="alternative-tests-en-ligne-de-commande"><span class="header-section-number">3.7.3</span> Alternative : Tests en ligne
de commande</h3>
<p>Si vous préférez travailler dans les fichiers du répertoire
<code>hdl_lib/01_gates/</code> :</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Tester une porte spécifique</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> hdl_cli <span class="at">--</span> test hdl_lib/01_gates/Not.hdl</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Tester toutes les portes du projet 1</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> hdl_cli <span class="at">--</span> test hdl_lib/01_gates/</span></code></pre></div>
<hr />
<h2 data-number="3.8" id="défis-supplémentaires"><span class="header-section-number">3.8</span> Défis Supplémentaires</h2>
<h3 data-number="3.8.1" id="défi-1-minimiser-le-nombre-de-nand"><span class="header-section-number">3.8.1</span> Défi 1 : Minimiser le nombre
de NAND</h3>
<p>Construisez la porte XOR en utilisant <strong>seulement 4 portes
NAND</strong> (c’est le minimum théorique !). La solution classique en
utilise 5.</p>
<h3 data-number="3.8.2" id="défi-2-implémenter-implies"><span class="header-section-number">3.8.2</span> Défi 2 : Implémenter
IMPLIES</h3>
<p>La fonction “implication” (<code>A → B</code>) vaut FAUX seulement si
A est VRAI et B est FAUX.</p>
<table>
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th style="text-align: center;">A → B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>Construisez cette porte en utilisant les portes élémentaires.</p>
<h3 data-number="3.8.3" id="défi-3-mux-à-4-entrées"><span class="header-section-number">3.8.3</span> Défi 3 : Mux à 4 entrées</h3>
<p>Construisez un Mux qui choisit parmi 4 entrées (<code>a</code>,
<code>b</code>, <code>c</code>, <code>d</code>) avec 2 bits de sélection
(<code>sel[1:0]</code>).</p>
<hr />
<h2 data-number="3.9" id="ce-quil-faut-retenir"><span class="header-section-number">3.9</span> Ce qu’il faut retenir</h2>
<ol type="1">
<li><strong>Le binaire simplifie</strong> : Deux états sont plus fiables
que dix</li>
<li><strong>NAND est universel</strong> : Toutes les portes peuvent être
construites à partir de NAND</li>
<li><strong>L’abstraction est puissante</strong> : On construit des
couches les unes sur les autres</li>
<li><strong>Chaque porte a un rôle</strong> :
<ul>
<li>NOT → Inversion, complément</li>
<li>AND → Masquage, condition “et”</li>
<li>OR → Combinaison, condition “ou”</li>
<li>XOR → Addition, comparaison</li>
<li>Mux → Choix, sélection</li>
<li>DMux → Routage, adressage</li>
</ul></li>
</ol>
<p><strong>Prochaine étape</strong> : Au Chapitre 2, nous utiliserons
ces portes pour construire des circuits qui font de
l’<strong>arithmétique</strong> — addition, soustraction, et une ALU
(Unité Arithmétique et Logique) complète.</p>
<hr />
<p><strong>Conseil</strong> : Ne passez pas au chapitre suivant avant
d’avoir réussi tous les exercices de ce chapitre. Chaque porte que vous
construisez sera réutilisée dans les chapitres suivants !</p>
<h1 data-number="4" id="arithmétique-binaire"><span class="header-section-number">4</span> Arithmétique Binaire</h1>
<blockquote>
<p>“Les mathématiques sont le langage avec lequel Dieu a écrit
l’univers.” — Galilée</p>
</blockquote>
<p>Dans le chapitre précédent, nous avons appris à manipuler des bits
individuels avec des portes logiques. Mais un ordinateur doit savoir
compter ! Comment passer de simples portes logiques à une calculatrice
capable d’additionner des nombres à 32 bits ?</p>
<hr />
<h2 data-number="4.1" id="où-en-sommes-nous-1"><span class="header-section-number">4.1</span> Où en sommes-nous ?</h2>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                     COUCHE 7: Applications                       │
├─────────────────────────────────────────────────────────────────┤
│                  COUCHE 6: Système d&#39;Exploitation                │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 5: Langage de Haut Niveau (C32)           │
├─────────────────────────────────────────────────────────────────┤
│                      COUCHE 4: Compilateur                       │
├─────────────────────────────────────────────────────────────────┤
│                   COUCHE 3: Assembleur (A32 ASM)                 │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 2: Architecture Machine (ISA)             │
├─────────────────────────────────────────────────────────────────┤
│  ══════════════► COUCHE 1: Logique Matérielle ◄══════════════   │
│              (Portes logiques → ALU, RAM, CPU)                   │
│                    (Vous êtes ici !)                             │
├─────────────────────────────────────────────────────────────────┤
│                     COUCHE 0: La Porte NAND                      │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<p>Nous sommes toujours dans la couche matérielle, mais nous montons
d’un niveau. Nous allons combiner les portes logiques du Chapitre 1 pour
construire des circuits arithmétiques, culminant avec
l’<strong>ALU</strong> (Arithmetic Logic Unit) — le composant qui
effectue TOUS les calculs du processeur.</p>
<hr />
<h2 data-number="4.2" id="pourquoi-larithmétique-est-elle-si-importante"><span class="header-section-number">4.2</span> Pourquoi l’Arithmétique
est-elle si Importante ?</h2>
<h3 data-number="4.2.1" id="au-cœur-de-tout-calcul"><span class="header-section-number">4.2.1</span> Au cœur de tout calcul</h3>
<p>Regardez ce que fait un ordinateur : - <strong>Afficher une
image</strong> : Calculer la couleur de chaque pixel (additions,
multiplications) - <strong>Jouer un son</strong> : Mélanger des formes
d’onde (additions) - <strong>Naviguer sur le web</strong> : Calculer des
checksums, décompresser des données - <strong>Exécuter un
programme</strong> : Calculer l’adresse de la prochaine instruction
(addition)</p>
<p>Même les opérations les plus “abstraites” se réduisent finalement à
des opérations arithmétiques sur des nombres binaires. L’ALU que vous
allez construire est le moteur qui fait tourner TOUT.</p>
<h3 data-number="4.2.2" id="ce-que-nous-allons-construire"><span class="header-section-number">4.2.2</span> Ce que nous allons
construire</h3>
<pre><code>Chapitre 1          Ce chapitre              Chapitre 5
    ↓                    ↓                       ↓
  XOR, AND          Half Adder                  CPU
     ↓                   ↓                       ↓
  Portes  ────→  Full Adder  ────→  Additionneur 32-bits  ────→  ALU  ────→  CPU</code></pre>
<p>À la fin de ce chapitre, vous aurez construit une ALU capable
d’effectuer : - Addition et soustraction - ET, OU, XOR logiques -
Comparaisons (via les drapeaux)</p>
<hr />
<h2 data-number="4.3" id="représentation-des-nombres"><span class="header-section-number">4.3</span> Représentation des Nombres</h2>
<h3 data-number="4.3.1" id="le-système-binaire-base-2"><span class="header-section-number">4.3.1</span> Le Système Binaire (Base
2)</h3>
<p>Avant de construire des additionneurs, comprenons comment les nombres
sont représentés.</p>
<p>En décimal (base 10), chaque position représente une puissance de 10
:</p>
<pre><code>  4   2   7
  ↓   ↓   ↓
10² 10¹ 10⁰  →  4×100 + 2×10 + 7×1 = 427</code></pre>
<p>En binaire (base 2), chaque position représente une puissance de 2
:</p>
<pre><code>Position :   3    2    1    0
Poids    :  2³   2²   2¹   2⁰
Valeur   :   8    4    2    1

Exemple : 1011₂ = 1×8 + 0×4 + 1×2 + 1×1 = 11₁₀</code></pre>
<h3 data-number="4.3.2" id="taille-des-nombres-dans-codex"><span class="header-section-number">4.3.2</span> Taille des nombres dans
Codex</h3>
<p>Notre ordinateur Codex travaille sur <strong>32 bits</strong>. Cela
signifie : - <strong>Plage non-signée</strong> : 0 à 2³² - 1 = 4 294 967
295 (≈ 4 milliards) - <strong>Plage signée</strong> : -2 147 483 648 à 2
147 483 647 (≈ ±2 milliards)</p>
<p>C’est suffisant pour : - Adresser 4 Go de mémoire (chaque octet a une
adresse unique) - Représenter des coordonnées d’écran, des scores de
jeux, des compteurs</p>
<h3 data-number="4.3.3" id="les-nombres-négatifs-le-complément-à-2"><span class="header-section-number">4.3.3</span> Les Nombres Négatifs : Le
Complément à 2</h3>
<p>Comment représenter des nombres négatifs avec seulement des 0 et des
1 ?</p>
<p><strong>Le problème</strong> : On pourrait utiliser un bit de signe
(0 = positif, 1 = négatif), mais alors on aurait besoin de circuits
différents pour l’addition et la soustraction, et on aurait deux
représentations du zéro (+0 et -0).</p>
<p><strong>La solution brillante</strong> : Le <strong>Complément à
2</strong>.</p>
<p>Le bit le plus à gauche (bit 31, le MSB) est le “bit de signe” : -
<code>0</code> → le nombre est positif ou nul - <code>1</code> → le
nombre est négatif</p>
<p>Mais attention, ce n’est pas un simple bit de signe ! Le système est
conçu pour que <strong>l’addition fonctionne de la même manière</strong>
que le nombre soit positif ou négatif.</p>
<h3 data-number="4.3.4" id="comment-obtenir-le-complément-à-2-la-valeur-négative"><span class="header-section-number">4.3.4</span> Comment obtenir le complément
à 2 (la valeur négative) ?</h3>
<p>Pour obtenir -X à partir de X : 1. <strong>Inverser</strong> tous les
bits de X (0→1, 1→0) 2. <strong>Ajouter 1</strong> au résultat</p>
<p><strong>Exemple sur 4 bits</strong> : Calculons -5</p>
<pre><code>  5 en binaire :   0101
  Inversion    :   1010
  Ajouter 1    : + 0001
                 ──────
  -5           :   1011</code></pre>
<p><strong>Vérification</strong> : 5 + (-5) devrait donner 0</p>
<pre><code>    0101   (5)
  + 1011   (-5)
  ──────
   10000   → Les 4 bits de poids faible sont 0000 ✓
            (La retenue &quot;1&quot; est ignorée car on travaille sur 4 bits)</code></pre>
<h3 data-number="4.3.5" id="pourquoi-le-complément-à-2-est-il-génial"><span class="header-section-number">4.3.5</span> Pourquoi le complément à 2
est-il génial ?</h3>
<ol type="1">
<li><strong>Un seul zéro</strong> : 0000 est le seul zéro (pas de +0 et
-0)</li>
<li><strong>L’addition fonctionne universellement</strong> : Le même
circuit additionne les positifs et les négatifs</li>
<li><strong>La soustraction devient une addition</strong> : A - B = A +
(-B) = A + NOT(B) + 1</li>
</ol>
<p>C’est grâce au complément à 2 que notre ALU peut être relativement
simple !</p>
<hr />
<h2 data-number="4.4" id="laddition-binaire"><span class="header-section-number">4.4</span> L’Addition Binaire</h2>
<p>L’addition binaire suit les mêmes règles que l’addition décimale
qu’on apprend à l’école : on additionne colonne par colonne, de droite à
gauche, en propageant les retenues.</p>
<h3 data-number="4.4.1" id="les-règles-de-base-sur-1-bit"><span class="header-section-number">4.4.1</span> Les règles de base (sur 1
bit)</h3>
<pre><code>0 + 0 = 0  (pas de retenue)
0 + 1 = 1  (pas de retenue)
1 + 0 = 1  (pas de retenue)
1 + 1 = 10 (c&#39;est-à-dire 0 avec une retenue de 1)</code></pre>
<h3 data-number="4.4.2" id="exemple-daddition-sur-4-bits"><span class="header-section-number">4.4.2</span> Exemple d’addition sur 4
bits</h3>
<p>Calculons 5 + 3 = 8 :</p>
<pre><code>  Retenues :   1 1 1
              ─────
     5     :   0 1 0 1
  +  3     : + 0 0 1 1
            ─────────
     8     :   1 0 0 0</code></pre>
<p>Détail colonne par colonne (de droite à gauche) : - Colonne 0 : 1 + 1
= 0, retenue 1 - Colonne 1 : 0 + 1 + 1(retenue) = 0, retenue 1 - Colonne
2 : 1 + 0 + 1(retenue) = 0, retenue 1 - Colonne 3 : 0 + 0 + 1(retenue) =
1</p>
<p>Résultat : 1000₂ = 8₁₀ ✓</p>
<hr />
<h2 data-number="4.5" id="le-demi-additionneur-half-adder"><span class="header-section-number">4.5</span> Le Demi-Additionneur (Half
Adder)</h2>
<p>Le demi-additionneur est le circuit le plus simple pour additionner
deux bits. Il produit : - <strong>sum</strong> : La somme (bit de poids
faible) - <strong>carry</strong> : La retenue (bit de poids fort)</p>
<h3 data-number="4.5.1" id="table-de-vérité"><span class="header-section-number">4.5.1</span> Table de vérité</h3>
<table>
<thead>
<tr class="header">
<th>a</th>
<th>b</th>
<th style="text-align: center;">sum</th>
<th style="text-align: center;">carry</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<h3 data-number="4.5.2" id="linsight-clé"><span class="header-section-number">4.5.2</span> L’insight clé</h3>
<p>Regardez attentivement les colonnes : - <strong>sum</strong>
correspond exactement à <strong>XOR(a, b)</strong> — différent = 1,
identique = 0 - <strong>carry</strong> correspond exactement à
<strong>AND(a, b)</strong> — les deux à 1 = retenue</p>
<p>C’est pour cela que nous avons construit XOR et AND au Chapitre 1
!</p>
<h3 data-number="4.5.3" id="schéma-du-circuit"><span class="header-section-number">4.5.3</span> Schéma du circuit</h3>
<pre><code>         ┌─────┐
    a ───┤     │
         │ XOR ├────── sum
    b ───┤     │
         └─────┘

         ┌─────┐
    a ───┤     │
         │ AND ├────── carry
    b ───┤     │
         └─────┘</code></pre>
<h3 data-number="4.5.4" id="limitation"><span class="header-section-number">4.5.4</span> Limitation</h3>
<p>Le demi-additionneur ne peut pas recevoir de retenue d’une colonne
précédente. Il ne fonctionne donc que pour le bit de poids faible (la
première colonne).</p>
<hr />
<h2 data-number="4.6" id="ladditionneur-complet-full-adder"><span class="header-section-number">4.6</span> L’Additionneur Complet (Full
Adder)</h2>
<p>Pour additionner des nombres de plusieurs bits, chaque colonne (sauf
la première) doit pouvoir accepter une retenue venant de la colonne
précédente.</p>
<h3 data-number="4.6.1" id="interface"><span class="header-section-number">4.6.1</span> Interface</h3>
<pre><code>         cin (retenue entrante)
          │
      ┌───┴───────┐
a ────┤           ├──── sum
      │ Full Adder│
b ────┤           ├──── cout (retenue sortante)
      └───────────┘</code></pre>
<h3 data-number="4.6.2" id="table-de-vérité-1"><span class="header-section-number">4.6.2</span> Table de vérité</h3>
<table>
<thead>
<tr class="header">
<th>a</th>
<th>b</th>
<th style="text-align: center;">cin</th>
<th style="text-align: center;">sum</th>
<th style="text-align: center;">cout</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>0</td>
<td>0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td>0</td>
<td>1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>0</td>
<td>1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td>1</td>
<td>0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td>1</td>
<td>1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td>1</td>
<td>1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<h3 data-number="4.6.3" id="comment-le-construire"><span class="header-section-number">4.6.3</span> Comment le construire ?</h3>
<p>Un Full Adder peut être construit avec <strong>deux Half Adders et
une porte OR</strong> :</p>
<ol type="1">
<li>Le premier Half Adder additionne <code>a</code> et
<code>b</code></li>
<li>Le second Half Adder additionne le résultat avec
<code>cin</code></li>
<li>Si l’un des deux Half Adders produit une retenue, on a une retenue
finale</li>
</ol>
<pre><code>          ┌──────────┐          ┌──────────┐
    a ────┤          │   s1     │          ├──── sum
          │ HalfAdder├──────────┤ HalfAdder│
    b ────┤          │          │          │
          └────┬─────┘     cin ─┤          │
               │c1              └────┬─────┘
               │                     │c2
               │      ┌─────┐        │
               └──────┤     │────────┘
                      │ OR  ├──────────────── cout
                      │     │
                      └─────┘</code></pre>
<p>Formules : - <code>s1 = XOR(a, b)</code> -
<code>sum = XOR(s1, cin)</code> - <code>c1 = AND(a, b)</code> -
<code>c2 = AND(s1, cin)</code> - <code>cout = OR(c1, c2)</code></p>
<hr />
<h2 data-number="4.7" id="ladditionneur-32-bits-ripple-carry-adder"><span class="header-section-number">4.7</span> L’Additionneur 32-bits (Ripple
Carry Adder)</h2>
<p>Pour additionner des nombres de 32 bits, nous connectons 32 Full
Adders en cascade. La retenue de sortie de chaque additionneur devient
la retenue d’entrée du suivant.</p>
<h3 data-number="4.7.1" id="schéma-simplifié"><span class="header-section-number">4.7.1</span> Schéma simplifié</h3>
<pre><code>     a[31] b[31]     a[1] b[1]     a[0] b[0]
       │    │          │    │        │    │
       ▼    ▼          ▼    ▼        ▼    ▼
     ┌───────┐       ┌───────┐     ┌───────┐
cout─┤  FA   │← ··· ─┤  FA   │← ───┤  FA   │← cin(0)
     │  31   │       │   1   │     │   0   │
     └───┬───┘       └───┬───┘     └───┬───┘
         │               │             │
         ▼               ▼             ▼
       y[31]           y[1]          y[0]</code></pre>
<p><strong>Note</strong> : Le premier Full Adder (position 0) a une
retenue d’entrée de 0 pour une addition normale. Mais on peut y injecter
un 1 pour implémenter la soustraction (A + NOT(B) + 1).</p>
<h3 data-number="4.7.2" id="le-compromis-du-ripple-carry"><span class="header-section-number">4.7.2</span> Le compromis du Ripple
Carry</h3>
<p><strong>Avantage</strong> : Très simple à comprendre et à
implémenter.</p>
<p><strong>Inconvénient</strong> : Les retenues se propagent d’un bout à
l’autre. Pour 32 bits, la retenue doit traverser 32 étages. C’est lent
!</p>
<p>Dans les vrais processeurs, on utilise des techniques comme le “Carry
Lookahead Adder” pour accélérer la propagation. Mais pour notre projet
pédagogique, le Ripple Carry est parfait.</p>
<hr />
<h2 data-number="4.8" id="lalu-arithmetic-logic-unit"><span class="header-section-number">4.8</span> L’ALU (Arithmetic Logic
Unit)</h2>
<p>L’ALU est le <strong>cœur calculatoire</strong> du processeur. C’est
elle qui effectue TOUTES les opérations arithmétiques et logiques.</p>
<h3 data-number="4.8.1" id="pourquoi-combiner-arithmétique-et-logique"><span class="header-section-number">4.8.1</span> Pourquoi combiner
arithmétique et logique ?</h3>
<p>Plutôt que d’avoir des circuits séparés pour l’addition, la
soustraction, le AND, le OR, etc., l’ALU combine tout en un seul
composant. Un signal de contrôle (<code>op</code>) lui dit quelle
opération effectuer.</p>
<h3 data-number="4.8.2" id="interface-de-lalu-codex"><span class="header-section-number">4.8.2</span> Interface de l’ALU Codex</h3>
<pre><code>         a (32 bits)     b (32 bits)
              │               │
              ▼               ▼
         ┌────────────────────────┐
         │                        │
  op ───►│         ALU            ├───► y (32 bits : résultat)
(4 bits) │                        │
         │                        ├───► n_flag (Negative)
         │                        ├───► z_flag (Zero)
         │                        ├───► c_flag (Carry)
         └────────────────────────┴───► v_flag (oVerflow)</code></pre>
<h3 data-number="4.8.3" id="les-opérations-de-lalu"><span class="header-section-number">4.8.3</span> Les Opérations de l’ALU</h3>
<p>Le signal <code>op</code> (4 bits) définit l’opération à effectuer
:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">op (binaire)</th>
<th style="text-align: center;">Nom</th>
<th style="text-align: center;">Opération</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0000</td>
<td style="text-align: center;">AND</td>
<td style="text-align: center;"><code>a &amp; b</code></td>
<td style="text-align: left;">ET logique bit à bit</td>
</tr>
<tr class="even">
<td style="text-align: center;">0001</td>
<td style="text-align: center;">EOR</td>
<td style="text-align: center;"><code>a ^ b</code></td>
<td style="text-align: left;">OU exclusif bit à bit</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0010</td>
<td style="text-align: center;">SUB</td>
<td style="text-align: center;"><code>a - b</code></td>
<td style="text-align: left;">Soustraction</td>
</tr>
<tr class="even">
<td style="text-align: center;">0011</td>
<td style="text-align: center;">ADD</td>
<td style="text-align: center;"><code>a + b</code></td>
<td style="text-align: left;">Addition</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0100</td>
<td style="text-align: center;">ORR</td>
<td style="text-align: center;"><code>a \| b</code></td>
<td style="text-align: left;">OU logique bit à bit</td>
</tr>
<tr class="even">
<td style="text-align: center;">0101</td>
<td style="text-align: center;">MOV</td>
<td style="text-align: center;"><code>b</code></td>
<td style="text-align: left;">Copie de b (ignore a)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0110</td>
<td style="text-align: center;">MVN</td>
<td style="text-align: center;"><code>~b</code></td>
<td style="text-align: left;">Inversion de b (NOT)</td>
</tr>
</tbody>
</table>
<h3 data-number="4.8.4" id="comment-implémenter-la-soustraction"><span class="header-section-number">4.8.4</span> Comment implémenter la
soustraction ?</h3>
<p>Grâce au complément à 2, la soustraction devient une addition :</p>
<pre><code>A - B = A + (-B) = A + (NOT B) + 1</code></pre>
<p>En pratique : 1. Inverser tous les bits de B (avec des portes NOT) 2.
Additionner A et NOT(B) avec une retenue d’entrée de 1</p>
<p>C’est pour cela que notre additionneur a une entrée <code>cin</code>
!</p>
<h3 data-number="4.8.5" id="les-drapeaux-flags"><span class="header-section-number">4.8.5</span> Les Drapeaux (Flags)</h3>
<p>Les drapeaux sont des informations supplémentaires sur le résultat
:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Drapeau</th>
<th style="text-align: left;">Nom</th>
<th style="text-align: left;">Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><strong>N</strong></td>
<td style="text-align: left;">Negative</td>
<td style="text-align: left;">1 si le résultat est négatif (bit 31 =
1)</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>Z</strong></td>
<td style="text-align: left;">Zero</td>
<td style="text-align: left;">1 si le résultat est exactement 0</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><strong>C</strong></td>
<td style="text-align: left;">Carry</td>
<td style="text-align: left;">1 s’il y a eu une retenue (dépassement
non-signé)</td>
</tr>
<tr class="even">
<td style="text-align: center;"><strong>V</strong></td>
<td style="text-align: left;">Overflow</td>
<td style="text-align: left;">1 s’il y a eu un dépassement signé</td>
</tr>
</tbody>
</table>
<p><strong>À quoi servent ces drapeaux ?</strong></p>
<p>Ils permettent au CPU de prendre des décisions : - <code>BEQ</code>
(Branch if Equal) teste si Z = 1 - <code>BLT</code> (Branch if Less
Than) teste une combinaison de N et V - <code>BCS</code> (Branch if
Carry Set) teste si C = 1</p>
<p>Sans les drapeaux, il serait impossible d’implémenter les conditions
<code>if</code>, les boucles <code>while</code>, etc. !</p>
<h3 data-number="4.8.6" id="comment-calculer-les-drapeaux"><span class="header-section-number">4.8.6</span> Comment calculer les drapeaux
?</h3>
<ul>
<li><strong>N (Negative)</strong> : C’est simplement le bit 31 du
résultat</li>
<li><strong>Z (Zero)</strong> : NOR de tous les bits du résultat (tous à
0 ?)</li>
<li><strong>C (Carry)</strong> : La retenue de sortie de
l’additionneur</li>
<li><strong>V (Overflow)</strong> : Se produit quand :
<ul>
<li>Deux positifs donnent un négatif</li>
<li>Deux négatifs donnent un positif</li>
<li>Formule : <code>V = (a[31] == b[31]) AND (a[31] != y[31])</code>
(pour l’addition)</li>
</ul></li>
</ul>
<hr />
<h2 data-number="4.9" id="architecture-de-lalu"><span class="header-section-number">4.9</span> Architecture de l’ALU</h2>
<p>Voici comment l’ALU est structurée en interne :</p>
<pre><code>                        ┌─────────────────────────────────────┐
                        │                ALU                   │
                        │                                      │
    a ─────────────────►│  ┌─────┐                            │
                        │  │ AND ├──────┐                     │
    b ─────────────────►│  └─────┘      │                     │
                        │               │                     │
                        │  ┌─────┐      │    ┌───────────┐    │
    a ─────────────────►│  │ XOR ├──────┼───►│           │    │
                        │  └─────┘      │    │           │    │
    b ─────────────────►│               │    │    MUX    ├───►│───► y
                        │  ┌─────┐      │    │  (sélection│    │
    a ─────────────────►│  │ ADD ├──────┼───►│   par op)  │    │
                        │  └─────┘      │    │           │    │
    b ─────────────────►│               │    │           │    │
         (ou NOT b      │  ┌─────┐      │    └─────┬─────┘    │
          pour SUB)     │  │ ORR ├──────┘          │          │
                        │  └─────┘                 │          │
                        │                         op          │
                        │                                      │
                        │  ┌─────────────────────────────────┐│
                        │  │ Calcul des drapeaux N, Z, C, V  ││
                        │  └─────────────────────────────────┘│
                        └─────────────────────────────────────┘</code></pre>
<p>L’idée clé : calculer TOUS les résultats possibles en parallèle, puis
utiliser un multiplexeur pour sélectionner le bon selon
<code>op</code>.</p>
<hr />
<h2 data-number="4.10" id="exercices-pratiques-1"><span class="header-section-number">4.10</span> Exercices Pratiques</h2>
<h3 data-number="4.10.1" id="exercices-sur-le-simulateur-web-1"><span class="header-section-number">4.10.1</span> Exercices sur le Simulateur
Web</h3>
<p>Lancez le <strong>Simulateur Web</strong> et allez dans <strong>HDL
Progression</strong> → <strong>Projet 3 : Arithmétique</strong>.</p>
<table>
<thead>
<tr class="header">
<th>Exercice</th>
<th>Description</th>
<th style="text-align: center;">Difficulté</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>HalfAdder</code></td>
<td>Demi-additionneur (XOR + AND)</td>
<td style="text-align: center;">⭐</td>
</tr>
<tr class="even">
<td><code>FullAdder</code></td>
<td>Additionneur complet (2 Half Adders + OR)</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="odd">
<td><code>Add16</code></td>
<td>Additionneur 16 bits en cascade</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="even">
<td><code>Inc16</code></td>
<td>Incrémenteur (+1) — cas spécial utile</td>
<td style="text-align: center;">⭐</td>
</tr>
<tr class="odd">
<td><code>Sub16</code></td>
<td>Soustracteur (via complément à 2)</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="even">
<td><code>ALU</code></td>
<td>L’ALU complète avec drapeaux</td>
<td style="text-align: center;">⭐⭐⭐</td>
</tr>
</tbody>
</table>
<h3 data-number="4.10.2" id="conseils-pour-lalu"><span class="header-section-number">4.10.2</span> Conseils pour l’ALU</h3>
<ol type="1">
<li><p><strong>Commencez par les opérations simples</strong> : AND, OR,
XOR sont juste des portes appliquées bit à bit</p></li>
<li><p><strong>Pour la soustraction</strong> :</p>
<pre><code>sub = a + (NOT b) + 1</code></pre>
<p>Utilisez un inverseur sur b et une retenue d’entrée de 1</p></li>
<li><p><strong>Utilisez les Mux</strong> : Un Mux4Way ou Mux8Way
sélectionne parmi plusieurs résultats</p></li>
<li><p><strong>Les drapeaux</strong> :</p>
<ul>
<li>N : bit 31 du résultat</li>
<li>Z : tous les bits sont à 0 ? (utilisez un grand OR puis NOT)</li>
<li>C : retenue de sortie de l’additionneur</li>
<li>V : comparez les signes des entrées et du résultat</li>
</ul></li>
</ol>
<h3 data-number="4.10.3" id="tests-en-ligne-de-commande"><span class="header-section-number">4.10.3</span> Tests en ligne de
commande</h3>
<div class="sourceCode" id="cb36"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Tester le Half Adder</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> hdl_cli <span class="at">--</span> test hdl_lib/03_arith/HalfAdder.hdl</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Tester l&#39;ALU complète</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> hdl_cli <span class="at">--</span> test hdl_lib/03_arith/ALU.hdl</span></code></pre></div>
<hr />
<h2 data-number="4.11" id="défis-supplémentaires-1"><span class="header-section-number">4.11</span> Défis Supplémentaires</h2>
<h3 data-number="4.11.1" id="défi-1-carry-lookahead"><span class="header-section-number">4.11.1</span> Défi 1 : Carry
Lookahead</h3>
<p>Le Ripple Carry est lent car les retenues se propagent
séquentiellement. Implémentez un “Carry Lookahead Adder” sur 4 bits qui
calcule les retenues en parallèle.</p>
<h3 data-number="4.11.2" id="défi-2-multiplicateur"><span class="header-section-number">4.11.2</span> Défi 2 : Multiplicateur</h3>
<p>Construisez un circuit qui multiplie deux nombres de 4 bits. Indice :
la multiplication est une série d’additions décalées.</p>
<h3 data-number="4.11.3" id="défi-3-comparateur"><span class="header-section-number">4.11.3</span> Défi 3 : Comparateur</h3>
<p>Construisez un circuit qui compare deux nombres 32 bits et produit
trois sorties : - <code>lt</code> : a &lt; b - <code>eq</code> : a == b
- <code>gt</code> : a &gt; b</p>
<p>Indice : Vous pouvez utiliser la soustraction et regarder les
drapeaux !</p>
<hr />
<h2 data-number="4.12" id="le-lien-avec-le-cpu"><span class="header-section-number">4.12</span> Le Lien avec le CPU</h2>
<p>L’ALU que vous venez de construire sera utilisée à CHAQUE cycle
d’horloge du CPU :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Instruction</th>
<th style="text-align: left;">Utilisation de l’ALU</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ADD R1, R2, R3</code></td>
<td style="text-align: left;">Additionne R2 et R3, stocke dans R1</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SUB R1, R2, R3</code></td>
<td style="text-align: left;">Soustrait R3 de R2</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>CMP R1, R2</code></td>
<td style="text-align: left;">Soustrait et met à jour les drapeaux (sans
stocker)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>AND R1, R2, R3</code></td>
<td style="text-align: left;">ET logique</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>LDR R1, [R2]</code></td>
<td style="text-align: left;">Calcule l’adresse mémoire (R2 +
offset)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>B label</code></td>
<td style="text-align: left;">Calcule la nouvelle adresse (PC +
offset)</td>
</tr>
</tbody>
</table>
<p>Même les sauts conditionnels (<code>BEQ</code>, <code>BNE</code>,
etc.) dépendent des drapeaux produits par l’ALU !</p>
<hr />
<h2 data-number="4.13" id="ce-quil-faut-retenir-1"><span class="header-section-number">4.13</span> Ce qu’il faut retenir</h2>
<ol type="1">
<li><p><strong>Le binaire est naturel pour les circuits</strong> :
Addition = XOR pour le bit, AND pour la retenue</p></li>
<li><p><strong>Le complément à 2 est magique</strong> : Un seul
additionneur pour addition ET soustraction</p></li>
<li><p><strong>L’ALU est le cœur du calcul</strong> : Toutes les
opérations passent par elle</p></li>
<li><p><strong>Les drapeaux permettent les décisions</strong> : Sans
eux, pas de <code>if</code>, pas de boucles</p></li>
<li><p><strong>La hiérarchie continue</strong> :</p>
<ul>
<li>Portes → Half Adder → Full Adder → Additionneur 32-bits → ALU</li>
</ul></li>
</ol>
<p><strong>Prochaine étape</strong> : Au Chapitre 3, nous aborderons la
<strong>mémoire</strong>. Comment l’ordinateur peut-il “se souvenir” de
données ? Nous construirons des flip-flops, des registres, et de la
RAM.</p>
<hr />
<p><strong>Conseil</strong> : L’ALU est l’un des composants les plus
complexes du projet. Prenez le temps de bien comprendre chaque étape. Si
vous avez réussi l’ALU, le reste du projet sera beaucoup plus accessible
!</p>
<h1 data-number="5" id="logique-séquentielle-et-mémoire"><span class="header-section-number">5</span> Logique Séquentielle et
Mémoire</h1>
<blockquote>
<p>“Le temps est ce qui empêche tout d’arriver en même temps.” — John
Wheeler</p>
</blockquote>
<p>Jusqu’à présent, nos circuits étaient <strong>combinatoires</strong>
: la sortie dépendait uniquement des entrées instantanées, comme une
fonction mathématique pure <code>y = f(x)</code>. Si vous coupez le
courant, ils “oublient” tout.</p>
<p>Pour construire un véritable ordinateur, nous devons pouvoir
<strong>stocker de l’information</strong> et la récupérer plus tard.
C’est le rôle de la <strong>logique séquentielle</strong>.</p>
<hr />
<h2 data-number="5.1" id="où-en-sommes-nous-2"><span class="header-section-number">5.1</span> Où en sommes-nous ?</h2>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                     COUCHE 7: Applications                       │
├─────────────────────────────────────────────────────────────────┤
│                  COUCHE 6: Système d&#39;Exploitation                │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 5: Langage de Haut Niveau (C32)           │
├─────────────────────────────────────────────────────────────────┤
│                      COUCHE 4: Compilateur                       │
├─────────────────────────────────────────────────────────────────┤
│                   COUCHE 3: Assembleur (A32 ASM)                 │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 2: Architecture Machine (ISA)             │
├─────────────────────────────────────────────────────────────────┤
│  ══════════════► COUCHE 1: Logique Matérielle ◄══════════════   │
│              (Portes → ALU → MÉMOIRE → CPU)                      │
│                    (Vous êtes ici !)                             │
├─────────────────────────────────────────────────────────────────┤
│                     COUCHE 0: La Porte NAND                      │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<p>Nous continuons à construire la couche matérielle. Après les portes
logiques (Chapitre 1) et l’ALU (Chapitre 2), nous abordons maintenant la
<strong>mémoire</strong> — le composant qui permet à l’ordinateur de “se
souvenir”.</p>
<hr />
<h2 data-number="5.2" id="pourquoi-la-mémoire-est-elle-fondamentale"><span class="header-section-number">5.2</span> Pourquoi la Mémoire est-elle
Fondamentale ?</h2>
<h3 data-number="5.2.1" id="le-problème-de-létat"><span class="header-section-number">5.2.1</span> Le problème de l’état</h3>
<p>Imaginez un programme simple :</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span></code></pre></div>
<p>Pour exécuter cette instruction, l’ordinateur doit : 1.
<strong>Lire</strong> la valeur actuelle de <code>x</code> 2.
<strong>Calculer</strong> <code>x + 1</code> (avec l’ALU) 3.
<strong>Écrire</strong> le résultat dans <code>x</code></p>
<p>Sans mémoire, il n’y a pas de “valeur actuelle de x” à lire. Sans
mémoire, le résultat du calcul disparaît immédiatement après avoir été
produit.</p>
<h3 data-number="5.2.2" id="ce-que-stocke-la-mémoire"><span class="header-section-number">5.2.2</span> Ce que stocke la mémoire</h3>
<p>Un ordinateur en fonctionnement stocke : - <strong>Le
programme</strong> : Les instructions à exécuter (le code machine) -
<strong>Les données</strong> : Les variables, les tableaux, les objets -
<strong>L’état du CPU</strong> : Les registres, le compteur de programme
- <strong>La pile d’appels</strong> : Pour les fonctions et les
retours</p>
<p>Toutes ces informations vivent dans différentes formes de
mémoire.</p>
<h3 data-number="5.2.3" id="combinatoire-vs-séquentiel"><span class="header-section-number">5.2.3</span> Combinatoire vs
Séquentiel</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Circuits Combinatoires</th>
<th style="text-align: left;">Circuits Séquentiels</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Sortie = f(entrées)</td>
<td style="text-align: left;">Sortie = f(entrées, <strong>état
précédent</strong>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pas de mémoire</td>
<td style="text-align: left;">A de la mémoire</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Pas d’horloge</td>
<td style="text-align: left;">Synchronisé par une horloge</td>
</tr>
<tr class="even">
<td style="text-align: left;">Exemples : AND, OR, ALU</td>
<td style="text-align: left;">Exemples : Registres, RAM, CPU</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="5.3" id="le-temps-et-lhorloge-clock"><span class="header-section-number">5.3</span> Le Temps et l’Horloge
(Clock)</h2>
<h3 data-number="5.3.1" id="le-problème-de-la-synchronisation"><span class="header-section-number">5.3.1</span> Le problème de la
synchronisation</h3>
<p>Dans un circuit combinatoire, les signaux se propagent à travers les
portes avec un léger délai. Si on essaie de lire un résultat avant qu’il
soit stable, on obtient des valeurs incorrectes.</p>
<p><strong>La solution</strong> : L’<strong>horloge</strong>
(<code>clk</code>).</p>
<p>L’horloge est un signal qui oscille perpétuellement entre 0 et 1 à
une fréquence fixe :</p>
<pre><code>      ┌───┐   ┌───┐   ┌───┐   ┌───┐
clk ──┘   └───┘   └───┘   └───┘   └──
      │       │       │       │
      └─ Cycle 1 ─┘   └─ Cycle 2 ─┘</code></pre>
<h3 data-number="5.3.2" id="front-montant-rising-edge"><span class="header-section-number">5.3.2</span> Front montant (Rising
Edge)</h3>
<p>Le moment crucial est le <strong>front montant</strong> : le passage
de 0 à 1.</p>
<p>Dans le système Codex, les changements d’état se produisent sur le
front montant. Cela signifie : - Pendant que l’horloge est à 0, les
circuits combinatoires calculent - Quand l’horloge passe à 1, les
résultats sont capturés dans les registres</p>
<p>C’est comme dire : “Tout le monde calcule… et maintenant, on fige les
résultats !”</p>
<h3 data-number="5.3.3" id="fréquence-dhorloge"><span class="header-section-number">5.3.3</span> Fréquence d’horloge</h3>
<p>La fréquence de l’horloge détermine la vitesse du processeur : - Un
processeur à 1 GHz = 1 milliard de cycles par seconde - À chaque cycle,
le CPU peut exécuter (une partie d’)une instruction</p>
<p>Plus vite bat l’horloge, plus l’ordinateur est rapide — mais aussi
plus il chauffe !</p>
<hr />
<h2 data-number="5.4" id="la-bascule-d-d-flip-flop-dff"><span class="header-section-number">5.4</span> La Bascule D (D Flip-Flop /
DFF)</h2>
<p>La <strong>DFF</strong> (Data Flip-Flop) est l’atome de la mémoire.
C’est le plus petit circuit capable de mémoriser un bit.</p>
<h3 data-number="5.4.1" id="interface-1"><span class="header-section-number">5.4.1</span> Interface</h3>
<pre><code>         ┌───────┐
    d ───┤       │
         │  DFF  ├─── q
   clk ──┤       │
         └───────┘</code></pre>
<ul>
<li><code>d</code> : La donnée à mémoriser (entrée)</li>
<li><code>q</code> : La donnée mémorisée (sortie)</li>
<li><code>clk</code> : L’horloge (parfois implicite)</li>
</ul>
<h3 data-number="5.4.2" id="comportement"><span class="header-section-number">5.4.2</span> Comportement</h3>
<p><strong>Règle fondamentale</strong> : <code>q(t) = d(t-1)</code></p>
<p>La sortie à l’instant <em>t</em> est égale à ce qu’était l’entrée au
cycle précédent.</p>
<pre><code>         Cycle 1    Cycle 2    Cycle 3    Cycle 4
clk      ───┐ ┌───  ───┐ ┌───  ───┐ ┌───  ───┐ ┌───
            └─┘        └─┘        └─┘        └─┘
d        ═══1═══════0═════════1═════════1═══════
q        ═══?═══════1═════════0═════════1═══════
                    ↑         ↑         ↑
                La sortie prend la valeur de d
                du cycle précédent</code></pre>
<h3 data-number="5.4.3" id="pourquoi-est-ce-utile"><span class="header-section-number">5.4.3</span> Pourquoi est-ce utile ?</h3>
<p>La DFF introduit un <strong>délai d’un cycle</strong>. Ce délai
permet : 1. De stocker une valeur pour le prochain cycle 2. De casser
les boucles (éviter les oscillations infinies) 3. De synchroniser tous
les composants sur l’horloge</p>
<h3 data-number="5.4.4" id="comment-fonctionne-une-dff-en-interne"><span class="header-section-number">5.4.4</span> Comment fonctionne une DFF en
interne ?</h3>
<p>Une DFF peut être construite à partir de deux verrous (latches) en
série, eux-mêmes construits à partir de portes NAND. C’est un sujet
fascinant mais hors de notre scope — nous considérons la DFF comme une
primitive fournie par le simulateur.</p>
<hr />
<h2 data-number="5.5" id="le-registre-1-bit-bit"><span class="header-section-number">5.5</span> Le Registre 1-bit (Bit)</h2>
<p>La DFF mémorise pendant UN cycle, puis elle prend la nouvelle valeur
d’entrée. Comment garder une valeur <strong>indéfiniment</strong> ?</p>
<h3 data-number="5.5.1" id="le-problème"><span class="header-section-number">5.5.1</span> Le problème</h3>
<p>On veut un circuit qui : - Si <code>load = 1</code> : stocke la
nouvelle valeur <code>in</code> - Si <code>load = 0</code> : conserve
l’ancienne valeur</p>
<h3 data-number="5.5.2" id="la-solution-la-rétroaction"><span class="header-section-number">5.5.2</span> La solution : la
rétroaction</h3>
<p>On utilise un <strong>Mux</strong> pour choisir entre : - L’ancienne
valeur (sortie de la DFF) - La nouvelle valeur (<code>in</code>)</p>
<pre><code>                 ┌───────┐
         ┌──────►│ sel=0 │
         │       │       │      ┌─────┐
         │ out ──┤  MUX  ├─────►│     │
         │       │       │      │ DFF ├───┬──► out
     in ─────────┤ sel=1 │      │     │   │
                 └───┬───┘      └─────┘   │
                     │                    │
                   load                   │
                                          │
         ┌────────────────────────────────┘
         │        (boucle de rétroaction)
         └───────────────────────────────────►</code></pre>
<p><strong>Fonctionnement</strong> : - Si <code>load = 0</code> : Le Mux
sélectionne la sortie de la DFF. La DFF ré-enregistre sa propre valeur.
La valeur est <strong>maintenue</strong>. - Si <code>load = 1</code> :
Le Mux sélectionne <code>in</code>. La DFF enregistre la nouvelle
valeur.</p>
<h3 data-number="5.5.3" id="cest-magique"><span class="header-section-number">5.5.3</span> C’est magique !</h3>
<p>Cette petite boucle de rétroaction transforme un délai d’un cycle en
une mémoire permanente. C’est le principe fondamental de toute mémoire
électronique.</p>
<hr />
<h2 data-number="5.6" id="le-registre-32-bits"><span class="header-section-number">5.6</span> Le Registre 32-bits</h2>
<h3 data-number="5.6.1" id="du-bit-au-mot"><span class="header-section-number">5.6.1</span> Du bit au mot</h3>
<p>Un registre 32-bits est simplement <strong>32 registres 1-bit en
parallèle</strong>, partageant le même signal <code>load</code>.</p>
<pre><code>              ┌─────────────────────────────────────┐
              │           Register 32-bit           │
              │                                      │
 in[31:0] ────┤  [Bit] [Bit] [Bit] ... [Bit] [Bit]  ├──── out[31:0]
              │    31    30    29        1     0    │
    load  ────┤────────────────────────────────────►│
              └─────────────────────────────────────┘</code></pre>
<p>Quand <code>load = 1</code>, les 32 bits sont capturés simultanément.
C’est atomique.</p>
<h3 data-number="5.6.2" id="le-rôle-des-registres-dans-le-cpu"><span class="header-section-number">5.6.2</span> Le rôle des registres dans le
CPU</h3>
<p>Le CPU Codex dispose de <strong>16 registres</strong> nommés R0 à R15
:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Registre</th>
<th style="text-align: left;">Rôle typique</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">R0-R12</td>
<td style="text-align: left;">Registres généraux (calculs,
variables)</td>
</tr>
<tr class="even">
<td style="text-align: center;">R13 (SP)</td>
<td style="text-align: left;">Stack Pointer (pointeur de pile)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">R14 (LR)</td>
<td style="text-align: left;">Link Register (adresse de retour)</td>
</tr>
<tr class="even">
<td style="text-align: center;">R15 (PC)</td>
<td style="text-align: left;">Program Counter (adresse de l’instruction
courante)</td>
</tr>
</tbody>
</table>
<p>Les registres sont la mémoire la plus rapide du CPU — ils sont
directement connectés à l’ALU et peuvent être lus/écrits en un seul
cycle.</p>
<hr />
<h2 data-number="5.7" id="la-ram-random-access-memory"><span class="header-section-number">5.7</span> La RAM (Random Access
Memory)</h2>
<h3 data-number="5.7.1" id="du-registre-à-la-mémoire"><span class="header-section-number">5.7.1</span> Du registre à la mémoire</h3>
<p>Un registre stocke UN mot de 32 bits. Pour stocker des millions de
mots, nous construisons une <strong>RAM</strong> (Random Access
Memory).</p>
<p>“Random Access” signifie qu’on peut accéder à n’importe quelle
cellule directement, sans parcourir les autres. Contrairement à une
bande magnétique où il faut rembobiner !</p>
<h3 data-number="5.7.2" id="interface-de-la-ram"><span class="header-section-number">5.7.2</span> Interface de la RAM</h3>
<pre><code>              ┌─────────────────────────┐
   in[31:0] ──┤                         │
              │                         ├──── out[31:0]
address[n:0] ─┤         RAM             │
              │                         │
    load ─────┤                         │
     clk ─────┤                         │
              └─────────────────────────┘</code></pre>
<ul>
<li><code>in</code> : La donnée à écrire</li>
<li><code>address</code> : L’adresse de la cellule à lire/écrire</li>
<li><code>load</code> : Si 1, écrire <code>in</code> à
<code>address</code>. Si 0, ne rien écrire.</li>
<li><code>out</code> : La valeur stockée à <code>address</code>
(toujours disponible en lecture)</li>
</ul>
<h3 data-number="5.7.3" id="comment-ça-marche"><span class="header-section-number">5.7.3</span> Comment ça marche ?</h3>
<p>La RAM utilise les composants que nous avons construits :</p>
<ol type="1">
<li><strong>DMux</strong> (Démultiplexeur) : Route le signal
<code>load</code> vers UN SEUL registre — celui correspondant à
l’adresse</li>
<li><strong>Registres</strong> : Stockent les données</li>
<li><strong>Mux</strong> (Multiplexeur) : Sélectionne la sortie du
registre correspondant à l’adresse</li>
</ol>
<h3 data-number="5.7.4" id="exemple-ram8-8-mots-de-32-bits"><span class="header-section-number">5.7.4</span> Exemple : RAM8 (8 mots de 32
bits)</h3>
<pre><code>address[2:0]     ┌────────────────────────────────────┐
                 │                                     │
    ┌────────────┤  DMux8Way (distribue le load)      │
    │            │                                     │
    │            └──┬────┬────┬────┬────┬────┬────┬───┘
    │               │    │    │    │    │    │    │
    │  load         ▼    ▼    ▼    ▼    ▼    ▼    ▼
    │            ┌────┬────┬────┬────┬────┬────┬────┬────┐
    │            │Reg0│Reg1│Reg2│Reg3│Reg4│Reg5│Reg6│Reg7│
    │            └─┬──┴─┬──┴─┬──┴─┬──┴─┬──┴─┬──┴─┬──┴─┬──┘
    │              │    │    │    │    │    │    │    │
    │              ▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼
    │            ┌────────────────────────────────────┐
    └────────────┤  Mux8Way32 (sélectionne la sortie) │
                 │                                     │
                 └──────────────────┬─────────────────┘
                                    │
                                    ▼
                                   out[31:0]</code></pre>
<h3 data-number="5.7.5" id="construction-hiérarchique-de-grandes-rams"><span class="header-section-number">5.7.5</span> Construction hiérarchique de
grandes RAMs</h3>
<p>Comment construire une RAM64 (64 mots) à partir de RAM8 ?</p>
<pre><code>address[5:0] = address[5:3] (3 bits supérieurs) + address[2:0] (3 bits inférieurs)
               ↓                                  ↓
        Sélectionne laquelle des 8 RAM8    Sélectionne le mot dans cette RAM8</code></pre>
<p>On utilise 8 RAM8 : - Les 3 bits de poids fort
(<code>address[5:3]</code>) choisissent <strong>quelle RAM8</strong> -
Les 3 bits de poids faible (<code>address[2:0]</code>) choisissent
<strong>quel mot dans la RAM8</strong></p>
<p>C’est un pattern récursif qui permet de construire des mémoires de
n’importe quelle taille !</p>
<hr />
<h2 data-number="5.8" id="le-compteur-de-programme-pc"><span class="header-section-number">5.8</span> Le Compteur de Programme
(PC)</h2>
<p>Le <strong>Program Counter</strong> (PC) est peut-être le registre le
plus important du CPU. Il contient l’adresse de la prochaine instruction
à exécuter.</p>
<h3 data-number="5.8.1" id="pourquoi-est-il-spécial"><span class="header-section-number">5.8.1</span> Pourquoi est-il spécial
?</h3>
<p>Après chaque instruction, le PC doit passer à l’instruction suivante.
Mais parfois : - On veut <strong>sauter</strong> à une autre adresse
(boucles, conditions) - On veut <strong>revenir à 0</strong>
(redémarrage)</p>
<h3 data-number="5.8.2" id="les-trois-modes-du-pc"><span class="header-section-number">5.8.2</span> Les trois modes du PC</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Priorité</th>
<th style="text-align: left;">Mode</th>
<th style="text-align: left;">Condition</th>
<th style="text-align: left;">Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: left;"><strong>Reset</strong></td>
<td style="text-align: left;"><code>reset = 1</code></td>
<td style="text-align: left;"><code>PC ← 0</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: left;"><strong>Jump</strong></td>
<td style="text-align: left;"><code>load = 1</code></td>
<td style="text-align: left;"><code>PC ← in</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;">3</td>
<td style="text-align: left;"><strong>Increment</strong></td>
<td style="text-align: left;"><code>inc = 1</code></td>
<td style="text-align: left;"><code>PC ← PC + 1</code></td>
</tr>
<tr class="even">
<td style="text-align: center;">4</td>
<td style="text-align: left;"><strong>Hold</strong></td>
<td style="text-align: left;">sinon</td>
<td style="text-align: left;"><code>PC ← PC</code></td>
</tr>
</tbody>
</table>
<h3 data-number="5.8.3" id="schéma-simplifié-1"><span class="header-section-number">5.8.3</span> Schéma simplifié</h3>
<pre><code>              ┌───────┐
    0 ────────┤       │
              │       │     ┌──────────┐
   in ────────┤  MUX  ├────►│          │
              │       │     │ Register ├────┬────► out (PC)
PC+1 ─────────┤       │     │          │    │
              └───┬───┘     └──────────┘    │
                  │                         │
           (contrôle)                       │
        reset/load/inc                      │
                                            │
                    ┌───────────────────────┘
                    │
                    ▼
              ┌──────────┐
              │  Add 1   │ (Incrémenteur)
              └──────────┘
                    │
                    └─────────────────────────► PC+1</code></pre>
<h3 data-number="5.8.4" id="le-lien-avec-lexécution-du-programme"><span class="header-section-number">5.8.4</span> Le lien avec l’exécution du
programme</h3>
<p>À chaque cycle d’horloge : 1. Le CPU lit l’instruction à l’adresse
<code>PC</code> 2. Il décode et exécute l’instruction 3. Il met à jour
le PC (incrément ou saut) 4. Le cycle recommence</p>
<p>C’est le cœur battant de l’ordinateur !</p>
<hr />
<h2 data-number="5.9" id="les-différents-types-de-mémoire"><span class="header-section-number">5.9</span> Les Différents Types de
Mémoire</h2>
<p>Dans un vrai ordinateur, il y a plusieurs niveaux de mémoire :</p>
<pre><code>        Rapidité        ┌─────────────┐
            ▲           │  Registres  │  16 × 32 bits = 64 octets
            │           ├─────────────┤
            │           │   Cache L1  │  32 Ko
            │           ├─────────────┤
            │           │   Cache L2  │  256 Ko
            │           ├─────────────┤
            │           │     RAM     │  16 Go
            │           ├─────────────┤
            ▼           │    Disque   │  1 To
        Capacité        └─────────────┘</code></pre>
<p>Plus on monte dans la pyramide : - Plus c’est rapide - Plus c’est
cher par octet - Plus la capacité est faible</p>
<p>Dans le Codex, nous implémentons les registres et la RAM. Les caches
et les disques sont des concepts plus avancés.</p>
<hr />
<h2 data-number="5.10" id="exercices-pratiques-2"><span class="header-section-number">5.10</span> Exercices Pratiques</h2>
<h3 data-number="5.10.1" id="exercices-sur-le-simulateur-web-2"><span class="header-section-number">5.10.1</span> Exercices sur le Simulateur
Web</h3>
<p>Lancez le <strong>Simulateur Web</strong> et allez dans <strong>HDL
Progression</strong> → <strong>Projet 4 : Séquentiel</strong>.</p>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 37%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th>Exercice</th>
<th>Description</th>
<th style="text-align: center;">Difficulté</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>DFF1</code></td>
<td>Bascule D (fournie comme primitive)</td>
<td style="text-align: center;">—</td>
</tr>
<tr class="even">
<td><code>BitReg</code></td>
<td>Registre 1-bit (Mux + DFF)</td>
<td style="text-align: center;">⭐</td>
</tr>
<tr class="odd">
<td><code>Register16</code></td>
<td>Registre 16-bits (16 BitReg en parallèle)</td>
<td style="text-align: center;">⭐</td>
</tr>
<tr class="even">
<td><code>PC</code></td>
<td>Compteur de programme avec reset/load/inc</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="odd">
<td><code>RAM8</code></td>
<td>RAM de 8 mots (DMux + 8 Registres + Mux)</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="even">
<td><code>RAM64</code></td>
<td>RAM de 64 mots (8 RAM8)</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="odd">
<td><code>RegFile</code></td>
<td>Banc de registres (lecture double, écriture simple)</td>
<td style="text-align: center;">⭐⭐⭐</td>
</tr>
</tbody>
</table>
<h3 data-number="5.10.2" id="ordre-de-progression-recommandé"><span class="header-section-number">5.10.2</span> Ordre de progression
recommandé</h3>
<ol type="1">
<li><strong>BitReg</strong> : La brique de base. Un Mux et une DFF.</li>
<li><strong>Register16</strong> : 16 BitReg en parallèle. Vérifiez que
tous les bits sont synchronisés.</li>
<li><strong>PC</strong> : Attention à la priorité ! reset &gt; load &gt;
inc &gt; hold</li>
<li><strong>RAM8</strong> : Utilisez DMux8Way et Mux8Way16</li>
<li><strong>RAM64</strong> : Composition de 8 RAM8</li>
</ol>
<h3 data-number="5.10.3" id="prérequis"><span class="header-section-number">5.10.3</span> Prérequis</h3>
<p>Avant de construire les RAMs, assurez-vous d’avoir terminé les
composants multi-bits du Projet 2 : - <code>Mux8Way16</code> :
Sélectionne parmi 8 entrées de 16 bits - <code>DMux8Way</code> :
Distribue 1 entrée vers 8 sorties</p>
<h3 data-number="5.10.4" id="tests-en-ligne-de-commande-1"><span class="header-section-number">5.10.4</span> Tests en ligne de
commande</h3>
<div class="sourceCode" id="cb49"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Tester le registre 1-bit</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> hdl_cli <span class="at">--</span> test hdl_lib/04_seq/BitReg.hdl</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Tester la RAM8</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> hdl_cli <span class="at">--</span> test hdl_lib/04_seq/RAM8.hdl</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Tester le PC</span></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> hdl_cli <span class="at">--</span> test hdl_lib/04_seq/PC.hdl</span></code></pre></div>
<hr />
<h2 data-number="5.11" id="défis-supplémentaires-2"><span class="header-section-number">5.11</span> Défis Supplémentaires</h2>
<h3 data-number="5.11.1" id="défi-1-ram-avec-deux-ports-de-lecture"><span class="header-section-number">5.11.1</span> Défi 1 : RAM avec deux ports
de lecture</h3>
<p>Construisez une RAM qui permet de lire DEUX adresses différentes
simultanément (utile pour le CPU qui doit lire deux opérandes).</p>
<h3 data-number="5.11.2" id="défi-2-compteur-avec-valeur-maximale"><span class="header-section-number">5.11.2</span> Défi 2 : Compteur avec
valeur maximale</h3>
<p>Modifiez le PC pour qu’il s’arrête à une valeur maximale au lieu de
continuer à compter (overflow protection).</p>
<h3 data-number="5.11.3" id="défi-3-registre-à-décalage-shift-register"><span class="header-section-number">5.11.3</span> Défi 3 : Registre à décalage
(Shift Register)</h3>
<p>Construisez un registre où les bits se décalent d’une position à
chaque cycle. Utilisé pour : - Les communications série - La
multiplication/division par 2 - Les générateurs de nombres
aléatoires</p>
<hr />
<h2 data-number="5.12" id="le-lien-avec-la-suite"><span class="header-section-number">5.12</span> Le Lien avec la Suite</h2>
<p>La mémoire que vous venez de construire sera utilisée partout dans
l’ordinateur :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Composant</th>
<th style="text-align: left;">Utilisation de la mémoire</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Registres R0-R15</strong></td>
<td style="text-align: left;">16 registres 32-bits pour les calculs</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>RAM</strong></td>
<td style="text-align: left;">Stockage du programme et des données</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>PC</strong></td>
<td style="text-align: left;">Adresse de l’instruction courante</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Pile (Stack)</strong></td>
<td style="text-align: left;">Zone de RAM pour les appels de
fonction</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Écran</strong></td>
<td style="text-align: left;">Zone de RAM mappée aux pixels (MMIO)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Clavier</strong></td>
<td style="text-align: left;">Registre mappé en mémoire (MMIO)</td>
</tr>
</tbody>
</table>
<p>Au Chapitre 4, nous verrons comment le CPU accède à la mémoire et aux
périphériques via le <strong>Memory-Mapped I/O</strong> (MMIO).</p>
<hr />
<h2 data-number="5.13" id="ce-quil-faut-retenir-2"><span class="header-section-number">5.13</span> Ce qu’il faut retenir</h2>
<ol type="1">
<li><p><strong>L’horloge synchronise tout</strong> : Les changements se
font sur le front montant</p></li>
<li><p><strong>La DFF est l’atome de mémoire</strong> :
<code>q(t) = d(t-1)</code></p></li>
<li><p><strong>La rétroaction crée la persistance</strong> : Mux + DFF =
mémoire permanente</p></li>
<li><p><strong>La RAM est un tableau de registres</strong> : Accès par
adresse</p></li>
<li><p><strong>Le PC guide l’exécution</strong> : Il pointe vers
l’instruction courante</p></li>
<li><p><strong>Hiérarchie de mémoire</strong> :</p>
<ul>
<li>Registres → Cache → RAM → Disque</li>
<li>Rapidité vs Capacité</li>
</ul></li>
</ol>
<p><strong>Prochaine étape</strong> : Au Chapitre 4, nous définissons
l’<strong>Architecture Machine</strong> (ISA). C’est le “contrat” entre
le matériel et le logiciel : quelles instructions le CPU comprend-il ?
Comment accède-t-il à la mémoire ?</p>
<hr />
<p><strong>Conseil</strong> : Prenez le temps de bien comprendre la
boucle de rétroaction du registre 1-bit. C’est un concept fondamental
qui revient constamment en informatique !</p>
<h1 data-number="6" id="architecture-machine-isa-a32"><span class="header-section-number">6</span> Architecture Machine (ISA
A32)</h1>
<blockquote>
<p>“Le langage est la limite de mon monde.” — Wittgenstein</p>
</blockquote>
<p>Nous avons maintenant des portes logiques, des additionneurs, et de
la mémoire. Mais comment <strong>commander</strong> tout cela ? C’est le
rôle de l’<strong>Architecture de Jeu d’Instructions</strong> (ISA -
Instruction Set Architecture).</p>
<p>L’ISA est le <strong>contrat</strong> entre le matériel et le
logiciel. C’est la liste de toutes les instructions que le CPU sait
exécuter.</p>
<hr />
<h2 data-number="6.1" id="où-en-sommes-nous-3"><span class="header-section-number">6.1</span> Où en sommes-nous ?</h2>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                     COUCHE 7: Applications                       │
├─────────────────────────────────────────────────────────────────┤
│                  COUCHE 6: Système d&#39;Exploitation                │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 5: Langage de Haut Niveau (C32)           │
├─────────────────────────────────────────────────────────────────┤
│                      COUCHE 4: Compilateur                       │
├─────────────────────────────────────────────────────────────────┤
│                   COUCHE 3: Assembleur (A32 ASM)                 │
├─────────────────────────────────────────────────────────────────┤
│  ══════════════► COUCHE 2: Architecture Machine (ISA) ◄════════ │
│          (Jeu d&#39;instructions, Registres, Mémoire)                │
│                    (Vous êtes ici !)                             │
├─────────────────────────────────────────────────────────────────┤
│                    COUCHE 1: Logique Matérielle                  │
├─────────────────────────────────────────────────────────────────┤
│                     COUCHE 0: La Porte NAND                      │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<p>Ce chapitre marque une transition importante. Nous quittons
temporairement le monde du matériel pour définir
<strong>l’interface</strong> entre matériel et logiciel. L’ISA que nous
définissons ici sera : - <strong>Implémentée</strong> par le CPU au
Chapitre 5 - <strong>Utilisée</strong> par l’assembleur au Chapitre 6 -
<strong>Ciblée</strong> par le compilateur au Chapitre 7</p>
<hr />
<h2 data-number="6.2" id="quest-ce-quune-architecture"><span class="header-section-number">6.2</span> Qu’est-ce qu’une Architecture
?</h2>
<h3 data-number="6.2.1" id="le-contrat-fondamental"><span class="header-section-number">6.2.1</span> Le contrat fondamental</h3>
<p>L’architecture d’un processeur définit : 1. <strong>Les
registres</strong> : Combien ? Quelle taille ? Quel rôle ? 2.
<strong>Les instructions</strong> : Quelles opérations le CPU peut-il
faire ? 3. <strong>L’encodage</strong> : Comment les instructions
sont-elles représentées en binaire ? 4. <strong>Le modèle
mémoire</strong> : Comment le CPU voit-il la mémoire ?</p>
<p>C’est un <strong>contrat</strong> : - Le matériel
<strong>promet</strong> d’exécuter les instructions comme spécifié - Le
logiciel <strong>s’engage</strong> à n’utiliser que les instructions
définies</p>
<h3 data-number="6.2.2" id="codex-a32-une-architecture-risc-moderne"><span class="header-section-number">6.2.2</span> Codex A32 : Une architecture
RISC moderne</h3>
<p>L’architecture <strong>Codex A32</strong> est inspirée de ARM,
l’architecture qui équipe la plupart des smartphones et le Raspberry Pi.
Elle est : - <strong>RISC</strong> (Reduced Instruction Set Computer) :
Instructions simples et rapides - <strong>32 bits</strong> : Registres
et adresses sur 32 bits - <strong>Load/Store</strong> : Le CPU ne
calcule jamais directement en mémoire</p>
<hr />
<h2 data-number="6.3" id="pourquoi-risc-larchitecture-loadstore"><span class="header-section-number">6.3</span> Pourquoi RISC ? L’architecture
Load/Store</h2>
<h3 data-number="6.3.1" id="cisc-vs-risc"><span class="header-section-number">6.3.1</span> CISC vs RISC</h3>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">CISC (x86, Intel)</th>
<th style="text-align: left;">RISC (ARM, Codex)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Instructions complexes</td>
<td style="text-align: left;">Instructions simples</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ADD [mem], reg</code> possible</td>
<td style="text-align: left;">Calcul uniquement entre registres</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Vitesse variable par instruction</td>
<td style="text-align: left;">1 instruction ≈ 1 cycle</td>
</tr>
<tr class="even">
<td style="text-align: left;">Plus facile à programmer directement</td>
<td style="text-align: left;">Plus facile à implémenter en matériel</td>
</tr>
</tbody>
</table>
<h3 data-number="6.3.2" id="la-règle-dor-loadstore"><span class="header-section-number">6.3.2</span> La règle d’or Load/Store</h3>
<p>En architecture RISC, le CPU ne peut <strong>jamais</strong> calculer
directement sur la mémoire. Toute opération suit le schéma :</p>
<pre><code>1. LOAD  : Charger les données de la mémoire vers les registres
2. COMPUTE : Effectuer le calcul dans les registres
3. STORE : Stocker le résultat de retour en mémoire</code></pre>
<p><strong>Exemple</strong> : Incrémenter une variable en mémoire</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>LDR R0<span class="op">,</span> <span class="op">[</span>R1<span class="op">]</span>      <span class="co">; 1. Charger la valeur depuis l&#39;adresse R1</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="bu">ADD</span> R0<span class="op">,</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">1</span>    <span class="co">; 2. Ajouter 1</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="bu">STR</span> R0<span class="op">,</span> <span class="op">[</span>R1<span class="op">]</span>      <span class="co">; 3. Stocker le résultat</span></span></code></pre></div>
<p>En x86 (CISC), on pourrait écrire <code>ADD [mem], 1</code> en une
seule instruction. Mais le CPU RISC est plus simple à construire et peut
aller plus vite.</p>
<hr />
<h2 data-number="6.4" id="le-cycle-de-vie-dune-instruction"><span class="header-section-number">6.4</span> Le Cycle de Vie d’une
Instruction</h2>
<p>Chaque instruction traverse trois phases :</p>
<pre><code>┌──────────────────────────────────────────────────────────────────┐
│                                                                   │
│   ┌─────────┐      ┌─────────┐      ┌─────────┐                  │
│   │  FETCH  │ ──── │ DECODE  │ ──── │ EXECUTE │ ←────────────┐   │
│   │         │      │         │      │         │              │   │
│   │ Lire    │      │ Décoder │      │ Exécuter│              │   │
│   │ l&#39;inst. │      │ les bits│      │ l&#39;opér. │              │   │
│   │ à PC    │      │         │      │         │              │   │
│   └─────────┘      └─────────┘      └─────────┘              │   │
│                                           │                   │   │
│                                           └───────────────────┘   │
│                                             (cycle suivant)       │
└──────────────────────────────────────────────────────────────────┘</code></pre>
<ol type="1">
<li><strong>Fetch</strong> (Récupération)
<ul>
<li>Le CPU lit l’instruction à l’adresse contenue dans PC</li>
<li>PC est incrémenté pour pointer vers l’instruction suivante</li>
</ul></li>
<li><strong>Decode</strong> (Décodage)
<ul>
<li>Les 32 bits de l’instruction sont analysés</li>
<li>Le CPU identifie : quel opération ? quels registres ? quelle valeur
immédiate ?</li>
</ul></li>
<li><strong>Execute</strong> (Exécution)
<ul>
<li>L’ALU effectue le calcul</li>
<li>Le résultat est stocké dans le registre de destination</li>
<li>Si c’est un branchement, PC peut être modifié</li>
</ul></li>
</ol>
<hr />
<h2 data-number="6.5" id="les-registres-le-plan-de-travail"><span class="header-section-number">6.5</span> Les Registres : Le Plan de
Travail</h2>
<p>Le CPU dispose de <strong>16 registres</strong> de 32 bits, nommés R0
à R15.</p>
<h3 data-number="6.5.1" id="vue-densemble"><span class="header-section-number">6.5.1</span> Vue d’ensemble</h3>
<pre><code>┌────────────────────────────────────────────────────────────────┐
│                    Banc de Registres (32 bits × 16)            │
├────────┬────────┬────────┬────────┬────────┬────────┬────────┤
│   R0   │   R1   │   R2   │   R3   │   R4   │   R5   │   R6   │
│  Arg0  │  Arg1  │  Arg2  │  Arg3  │  Var   │  Var   │  Var   │
├────────┼────────┼────────┼────────┼────────┼────────┼────────┤
│   R7   │   R8   │   R9   │  R10   │  R11   │  R12   │  R13   │
│  Var   │  Var   │  Var   │  Var   │  Var   │  Temp  │   SP   │
├────────┼────────┴────────┴────────┴────────┴────────┴────────┤
│  R14   │  R15                                                 │
│   LR   │   PC (Program Counter)                               │
└────────┴─────────────────────────────────────────────────────┘</code></pre>
<h3 data-number="6.5.2" id="rôles-des-registres"><span class="header-section-number">6.5.2</span> Rôles des registres</h3>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 18%" />
<col style="width: 54%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Registre</th>
<th style="text-align: left;">Alias</th>
<th style="text-align: left;">Rôle conventionnel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>R0-R3</strong></td>
<td style="text-align: left;">—</td>
<td style="text-align: left;">Arguments des fonctions et valeurs de
retour</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>R4-R11</strong></td>
<td style="text-align: left;">—</td>
<td style="text-align: left;">Variables locales (préservées par les
fonctions)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>R12</strong></td>
<td style="text-align: left;">IP</td>
<td style="text-align: left;">Registre temporaire (Intra-Procedure
call)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>R13</strong></td>
<td style="text-align: left;"><strong>SP</strong></td>
<td style="text-align: left;">Stack Pointer — Pointe vers le sommet de
la pile</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>R14</strong></td>
<td style="text-align: left;"><strong>LR</strong></td>
<td style="text-align: left;">Link Register — Adresse de retour après
<code>BL</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>R15</strong></td>
<td style="text-align: left;"><strong>PC</strong></td>
<td style="text-align: left;">Program Counter — Adresse de l’instruction
courante</td>
</tr>
</tbody>
</table>
<h3 data-number="6.5.3" id="le-cas-spécial-de-r15-pc"><span class="header-section-number">6.5.3</span> Le cas spécial de R15
(PC)</h3>
<p>Le PC est accessible comme n’importe quel registre. Si vous écrivez
dedans, vous forcez un saut !</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> PC<span class="op">,</span> <span class="kw">R14</span>    <span class="co">; Équivalent à &quot;return&quot; : saute à l&#39;adresse dans LR</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="bu">ADD</span> PC<span class="op">,</span> PC<span class="op">,</span> <span class="op">#</span><span class="dv">8</span> <span class="co">; Saute de 8 octets plus loin</span></span></code></pre></div>
<p>C’est puissant mais dangereux — une erreur de calcul et le CPU saute
n’importe où !</p>
<hr />
<h2 data-number="6.6" id="la-carte-mémoire-memory-map"><span class="header-section-number">6.6</span> La Carte Mémoire (Memory
Map)</h2>
<p>La mémoire est un espace linéaire de 4 Go (2³² octets), mais toutes
les adresses ne sont pas utilisables.</p>
<h3 data-number="6.6.1" id="organisation-de-la-mémoire-codex"><span class="header-section-number">6.6.1</span> Organisation de la mémoire
Codex</h3>
<pre><code>0xFFFFFFFF ┌────────────────────────────────┐
           │     MMIO (Entrées/Sorties)    │ ← Adresses spéciales (HALT, etc.)
0xFFFF0000 ├────────────────────────────────┤
           │                                │
           │          (Non utilisé)         │
           │                                │
0x00402600 ├────────────────────────────────┤
           │     Clavier (4 octets)        │ ← Lecture de la touche pressée
0x00402600 ├────────────────────────────────┤
           │                                │
           │     Écran (9600 octets)       │ ← 320×240 pixels, 1 bit par pixel
           │     (320×240/8 × 1 bit)       │   Écrire ici allume des pixels !
           │                                │
0x00400000 ├────────────────────────────────┤
           │                                │
           │       RAM Système             │ ← Code + Données + Pile
           │       (4 Mo)                  │
           │                                │
0x00000000 └────────────────────────────────┘</code></pre>
<h3 data-number="6.6.2" id="le-memory-mapped-io-mmio"><span class="header-section-number">6.6.2</span> Le Memory-Mapped I/O
(MMIO)</h3>
<p>En Codex (comme en ARM), les périphériques sont accessibles
<strong>comme de la mémoire</strong>. Il n’y a pas d’instructions
spéciales <code>IN</code>/<code>OUT</code>.</p>
<p><strong>L’écran</strong> : - Adresse : <code>0x00400000</code> à
<code>0x00402580</code> - Format : 1 bit par pixel, 40 octets par ligne
- Écrire un <code>1</code> à un bit = pixel blanc</p>
<p><strong>Le clavier</strong> : - Adresse : <code>0x00402600</code> -
Lire cette adresse donne le code ASCII de la touche pressée (ou 0)</p>
<p><strong>Exemple</strong> : Allumer le premier pixel</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>LDR R0<span class="op">,</span> <span class="op">=</span><span class="bn">0x00400000</span>   <span class="co">; Adresse de l&#39;écran</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> R1<span class="op">,</span> <span class="op">#</span><span class="bn">0x80</span>         <span class="co">; Bit 7 = premier pixel de la ligne</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>STRB R1<span class="op">,</span> <span class="op">[</span>R0<span class="op">]</span>         <span class="co">; Écrire un octet</span></span></code></pre></div>
<hr />
<h2 data-number="6.7" id="le-format-des-instructions"><span class="header-section-number">6.7</span> Le Format des Instructions</h2>
<p>Chaque instruction est encodée sur <strong>32 bits</strong>. La
structure générale :</p>
<pre><code>31   28 27   25 24                                             0
┌──────┬───────┬───────────────────────────────────────────────┐
│ Cond │ Class │              Données de l&#39;instruction         │
└──────┴───────┴───────────────────────────────────────────────┘</code></pre>
<h3 data-number="6.7.1" id="les-bits-de-condition-31-28"><span class="header-section-number">6.7.1</span> Les bits de condition
(31-28)</h3>
<p><strong>Fonctionnalité unique de ARM/Codex</strong> : Toute
instruction peut être conditionnelle !</p>
<p>Au lieu de :</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="bu">CMP</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">0</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>BNE skip</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> R1<span class="op">,</span> <span class="op">#</span><span class="dv">1</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="fu">skip:</span></span></code></pre></div>
<p>On peut écrire :</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="bu">CMP</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">0</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span><span class="op">.</span>EQ R1<span class="op">,</span> <span class="op">#</span><span class="dv">1</span>   <span class="co">; Exécuté SEULEMENT si Z=1 (égal)</span></span></code></pre></div>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Code</th>
<th style="text-align: left;">Suffixe</th>
<th style="text-align: left;">Condition</th>
<th style="text-align: left;">Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0000</td>
<td style="text-align: left;">EQ</td>
<td style="text-align: left;">Z = 1</td>
<td style="text-align: left;">Égal (Equal)</td>
</tr>
<tr class="even">
<td style="text-align: center;">0001</td>
<td style="text-align: left;">NE</td>
<td style="text-align: left;">Z = 0</td>
<td style="text-align: left;">Différent (Not Equal)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">0010</td>
<td style="text-align: left;">CS/HS</td>
<td style="text-align: left;">C = 1</td>
<td style="text-align: left;">Retenue (Carry Set)</td>
</tr>
<tr class="even">
<td style="text-align: center;">0011</td>
<td style="text-align: left;">CC/LO</td>
<td style="text-align: left;">C = 0</td>
<td style="text-align: left;">Pas de retenue (Carry Clear)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1010</td>
<td style="text-align: left;">GE</td>
<td style="text-align: left;">N = V</td>
<td style="text-align: left;">Plus grand ou égal (signé)</td>
</tr>
<tr class="even">
<td style="text-align: center;">1011</td>
<td style="text-align: left;">LT</td>
<td style="text-align: left;">N ≠ V</td>
<td style="text-align: left;">Plus petit (signé)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1100</td>
<td style="text-align: left;">GT</td>
<td style="text-align: left;">Z=0 et N=V</td>
<td style="text-align: left;">Plus grand (signé)</td>
</tr>
<tr class="even">
<td style="text-align: center;">1101</td>
<td style="text-align: left;">LE</td>
<td style="text-align: left;">Z=1 ou N≠V</td>
<td style="text-align: left;">Plus petit ou égal (signé)</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1110</td>
<td style="text-align: left;">AL</td>
<td style="text-align: left;">(toujours)</td>
<td style="text-align: left;">Toujours exécuter (défaut)</td>
</tr>
</tbody>
</table>
<h3 data-number="6.7.2" id="les-classes-dinstructions-27-25"><span class="header-section-number">6.7.2</span> Les classes d’instructions
(27-25)</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Bits 27-25</th>
<th style="text-align: left;">Classe</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">000</td>
<td style="text-align: left;">Data Processing (reg)</td>
<td style="text-align: left;">Opérations ALU avec registre</td>
</tr>
<tr class="even">
<td style="text-align: left;">001</td>
<td style="text-align: left;">Data Processing (imm)</td>
<td style="text-align: left;">Opérations ALU avec immédiat</td>
</tr>
<tr class="odd">
<td style="text-align: left;">010</td>
<td style="text-align: left;">Load/Store</td>
<td style="text-align: left;">Accès mémoire (LDR, STR)</td>
</tr>
<tr class="even">
<td style="text-align: left;">011</td>
<td style="text-align: left;">Branch</td>
<td style="text-align: left;">Branchements (B, BL)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">100</td>
<td style="text-align: left;">Block Transfer</td>
<td style="text-align: left;">Push/Pop multiple (LDM, STM)</td>
</tr>
<tr class="even">
<td style="text-align: left;">111</td>
<td style="text-align: left;">System</td>
<td style="text-align: left;">Instructions système (SVC, HALT)</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="6.8" id="les-instructions-en-détail"><span class="header-section-number">6.8</span> Les Instructions en Détail</h2>
<h3 data-number="6.8.1" id="a.-opérations-arithmétiques-et-logiques"><span class="header-section-number">6.8.1</span> A. Opérations Arithmétiques
et Logiques</h3>
<p><strong>Format général</strong> :
<code>OP{cond}{S} Rd, Rn, Operand2</code></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Instruction</th>
<th style="text-align: left;">Opération</th>
<th style="text-align: left;">Exemple</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ADD</code></td>
<td style="text-align: left;">Addition</td>
<td style="text-align: left;"><code>ADD R1, R2, R3</code> → R1 = R2 +
R3</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SUB</code></td>
<td style="text-align: left;">Soustraction</td>
<td style="text-align: left;"><code>SUB R1, R2, #5</code> → R1 = R2 -
5</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>AND</code></td>
<td style="text-align: left;">ET logique</td>
<td style="text-align: left;"><code>AND R1, R2, R3</code> → R1 = R2
&amp; R3</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>ORR</code></td>
<td style="text-align: left;">OU logique</td>
<td style="text-align: left;"><code>ORR R1, R2, R3</code> → R1 = R2 |
R3</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>EOR</code></td>
<td style="text-align: left;">XOR</td>
<td style="text-align: left;"><code>EOR R1, R2, R3</code> → R1 = R2 ^
R3</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>MOV</code></td>
<td style="text-align: left;">Copie</td>
<td style="text-align: left;"><code>MOV R1, R2</code> → R1 = R2</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>MVN</code></td>
<td style="text-align: left;">Copie inversée</td>
<td style="text-align: left;"><code>MVN R1, R2</code> → R1 = ~R2</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>CMP</code></td>
<td style="text-align: left;">Comparaison</td>
<td style="text-align: left;"><code>CMP R1, R2</code> → met à jour les
flags</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>TST</code></td>
<td style="text-align: left;">Test bits</td>
<td style="text-align: left;"><code>TST R1, R2</code> → AND sans
stocker</td>
</tr>
</tbody>
</table>
<p><strong>Le suffixe <code>S</code></strong> : Ajouter <code>S</code>
met à jour les drapeaux NZCV.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>ADDS R1<span class="op">,</span> R2<span class="op">,</span> R3   <span class="co">; Met à jour les flags</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="bu">ADD</span> R1<span class="op">,</span> R2<span class="op">,</span> R3    <span class="co">; Ne touche pas aux flags</span></span></code></pre></div>
<h3 data-number="6.8.2" id="b.-accès-mémoire-loadstore"><span class="header-section-number">6.8.2</span> B. Accès Mémoire
(Load/Store)</h3>
<p><strong>Format général</strong> :
<code>LDR/STR{B} Rd, [Rn, #offset]</code></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Instruction</th>
<th style="text-align: left;">Action</th>
<th style="text-align: left;">Exemple</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>LDR</code></td>
<td style="text-align: left;">Charger 32 bits</td>
<td style="text-align: left;"><code>LDR R0, [R1]</code> → R0 =
MEM[R1]</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>STR</code></td>
<td style="text-align: left;">Stocker 32 bits</td>
<td style="text-align: left;"><code>STR R0, [R1]</code> → MEM[R1] =
R0</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>LDRB</code></td>
<td style="text-align: left;">Charger 8 bits</td>
<td style="text-align: left;"><code>LDRB R0, [R1]</code> → R0 = MEM[R1]
(1 octet)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>STRB</code></td>
<td style="text-align: left;">Stocker 8 bits</td>
<td style="text-align: left;"><code>STRB R0, [R1]</code> → MEM[R1] = R0
(1 octet)</td>
</tr>
</tbody>
</table>
<p><strong>Modes d’adressage</strong> :</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>LDR R0<span class="op">,</span> <span class="op">[</span>R1<span class="op">]</span>        <span class="co">; Simple : adresse = R1</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>LDR R0<span class="op">,</span> <span class="op">[</span>R1<span class="op">,</span> <span class="op">#</span><span class="dv">4</span><span class="op">]</span>    <span class="co">; Offset : adresse = R1 + 4</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>LDR R0<span class="op">,</span> <span class="op">[</span>R1<span class="op">,</span> R2<span class="op">]</span>    <span class="co">; Registre : adresse = R1 + R2</span></span></code></pre></div>
<h3 data-number="6.8.3" id="c.-branchements"><span class="header-section-number">6.8.3</span> C. Branchements</h3>
<p><strong>Format</strong> : <code>B{cond} label</code> ou
<code>BL{cond} label</code></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Instruction</th>
<th style="text-align: left;">Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>B label</code></td>
<td style="text-align: left;">Saut inconditionnel</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>BL label</code></td>
<td style="text-align: left;">Branch with Link (appel de fonction)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>BEQ label</code></td>
<td style="text-align: left;">Saut si égal (Z=1)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>BNE label</code></td>
<td style="text-align: left;">Saut si différent (Z=0)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>BLT label</code></td>
<td style="text-align: left;">Saut si plus petit (signé)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>BGT label</code></td>
<td style="text-align: left;">Saut si plus grand (signé)</td>
</tr>
</tbody>
</table>
<p><strong>Le mystère de <code>BL</code></strong> :</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="fu">main:</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    BL ma_fonction    <span class="co">; 1. Sauvegarde PC+4 dans LR</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>                      <span class="co">; 2. Saute à ma_fonction</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">; ... (on revient ici après le retour)</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a><span class="fu">ma_fonction:</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">; ... faire quelque chose ...</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">MOV</span> PC<span class="op">,</span> LR        <span class="co">; Retour : saute à l&#39;adresse dans LR</span></span></code></pre></div>
<hr />
<h2 data-number="6.9" id="la-pile-stack"><span class="header-section-number">6.9</span> La Pile (Stack)</h2>
<p>La pile est une zone de mémoire utilisée pour : - Sauvegarder les
registres - Stocker les variables locales - Passer des arguments aux
fonctions</p>
<h3 data-number="6.9.1" id="fonctionnement"><span class="header-section-number">6.9.1</span> Fonctionnement</h3>
<p>La pile <strong>grandit vers le bas</strong> (des adresses hautes
vers les basses) :</p>
<pre><code>       Adresses hautes
           │
           ▼
┌──────────────────┐
│  (données)       │
├──────────────────┤
│  (données)       │
├──────────────────┤ ← SP (Stack Pointer)
│                  │
│   (espace libre) │
│                  │
└──────────────────┘
       Adresses basses</code></pre>
<h3 data-number="6.9.2" id="push-et-pop-manuel"><span class="header-section-number">6.9.2</span> Push et Pop (manuel)</h3>
<p>Codex n’a pas d’instructions <code>PUSH</code>/<code>POP</code>
natives. On les simule :</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co">; PUSH R0 (empiler R0)</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="bu">SUB</span> <span class="kw">SP</span><span class="op">,</span> <span class="kw">SP</span><span class="op">,</span> <span class="op">#</span><span class="dv">4</span>     <span class="co">; Faire de la place (pile descend)</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="bu">STR</span> R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">]</span>       <span class="co">; Stocker R0 au sommet</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span class="co">; POP R0 (dépiler dans R0)</span></span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a>LDR R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">]</span>       <span class="co">; Lire depuis le sommet</span></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a><span class="bu">ADD</span> <span class="kw">SP</span><span class="op">,</span> <span class="kw">SP</span><span class="op">,</span> <span class="op">#</span><span class="dv">4</span>     <span class="co">; Libérer l&#39;espace</span></span></code></pre></div>
<hr />
<h2 data-number="6.10" id="exemples-de-programmes"><span class="header-section-number">6.10</span> Exemples de Programmes</h2>
<h3 data-number="6.10.1" id="exemple-1-somme-de-1-à-n"><span class="header-section-number">6.10.1</span> Exemple 1 : Somme de 1 à
N</h3>
<div class="sourceCode" id="cb66"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Calcule 1 + 2 + ... + 10</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>.text</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>.global _start</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="fu">_start:</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">MOV</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">0</span>       <span class="co">; sum = 0</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">MOV</span> R1<span class="op">,</span> <span class="op">#</span><span class="dv">1</span>       <span class="co">; i = 1</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a><span class="fu">loop:</span></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">CMP</span> R1<span class="op">,</span> <span class="op">#</span><span class="dv">10</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a>    BGT done         <span class="co">; si i &gt; 10, sortir</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">ADD</span> R0<span class="op">,</span> R0<span class="op">,</span> R1   <span class="co">; sum += i</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">ADD</span> R1<span class="op">,</span> R1<span class="op">,</span> <span class="op">#</span><span class="dv">1</span>   <span class="co">; i++</span></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>    B loop</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a><span class="fu">done:</span></span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">; R0 contient 55</span></span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>    HALT</span></code></pre></div>
<h3 data-number="6.10.2" id="exemple-2-maximum-de-deux-nombres-avec-prédication"><span class="header-section-number">6.10.2</span> Exemple 2 : Maximum de deux
nombres (avec prédication)</h3>
<div class="sourceCode" id="cb67"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co">; R2 = max(R0, R1) sans branchement</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a><span class="bu">CMP</span> R0<span class="op">,</span> R1</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span><span class="op">.</span>GE R2<span class="op">,</span> R0     <span class="co">; Si R0 &gt;= R1, R2 = R0</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span><span class="op">.</span>LT R2<span class="op">,</span> R1     <span class="co">; Si R0 &lt; R1, R2 = R1</span></span></code></pre></div>
<h3 data-number="6.10.3" id="exemple-3-dessiner-un-pixel"><span class="header-section-number">6.10.3</span> Exemple 3 : Dessiner un
pixel</h3>
<div class="sourceCode" id="cb68"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Allumer le pixel (10, 20)</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="co">; Adresse = 0x00400000 + (y * 40) + (x / 8)</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="co">; Bit = 7 - (x % 8)</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>LDR R0<span class="op">,</span> <span class="op">=</span><span class="bn">0x00400000</span>  <span class="co">; Base de l&#39;écran</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> R1<span class="op">,</span> <span class="op">#</span><span class="dv">20</span>          <span class="co">; y = 20</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> R2<span class="op">,</span> <span class="op">#</span><span class="dv">40</span>          <span class="co">; octets par ligne</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="bu">MUL</span> R1<span class="op">,</span> R1<span class="op">,</span> R2       <span class="co">; offset_y = y * 40</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a><span class="bu">ADD</span> R0<span class="op">,</span> R0<span class="op">,</span> R1       <span class="co">; adresse_ligne</span></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> R1<span class="op">,</span> <span class="op">#</span><span class="dv">10</span>          <span class="co">; x = 10</span></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> R2<span class="op">,</span> R1<span class="op">,</span> LSR <span class="op">#</span><span class="dv">3</span>   <span class="co">; x / 8</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a><span class="bu">ADD</span> R0<span class="op">,</span> R0<span class="op">,</span> R2       <span class="co">; adresse finale</span></span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a><span class="bu">AND</span> R1<span class="op">,</span> R1<span class="op">,</span> <span class="op">#</span><span class="dv">7</span>       <span class="co">; x % 8</span></span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>RSB R1<span class="op">,</span> R1<span class="op">,</span> <span class="op">#</span><span class="dv">7</span>       <span class="co">; 7 - (x % 8)</span></span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> R2<span class="op">,</span> <span class="op">#</span><span class="dv">1</span></span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a><span class="bu">LSL</span> R2<span class="op">,</span> R2<span class="op">,</span> R1       <span class="co">; masque = 1 &lt;&lt; bit_pos</span></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>LDRB R3<span class="op">,</span> <span class="op">[</span>R0<span class="op">]</span>        <span class="co">; Lire l&#39;octet actuel</span></span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a>ORR R3<span class="op">,</span> R3<span class="op">,</span> R2       <span class="co">; Allumer le bit</span></span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>STRB R3<span class="op">,</span> <span class="op">[</span>R0<span class="op">]</span>        <span class="co">; Écrire l&#39;octet</span></span></code></pre></div>
<hr />
<h2 data-number="6.11" id="gestion-des-erreurs-traps"><span class="header-section-number">6.11</span> Gestion des Erreurs
(Traps)</h2>
<p>Si le CPU rencontre une situation invalide, il déclenche une
<strong>trap</strong> :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Trap</th>
<th style="text-align: left;">Cause</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ILLEGAL</code></td>
<td style="text-align: left;">Instruction invalide (opcode inconnu)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>MEM_FAULT</code></td>
<td style="text-align: left;">Accès à une adresse non mappée</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>MISALIGNED</code></td>
<td style="text-align: left;">Accès 32-bits à une adresse non alignée
(ex: 0x3)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>DIV_ZERO</code></td>
<td style="text-align: left;">Division par zéro</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="6.12" id="exercices-pratiques-3"><span class="header-section-number">6.12</span> Exercices Pratiques</h2>
<h3 data-number="6.12.1" id="exercices-sur-le-simulateur-web-3"><span class="header-section-number">6.12.1</span> Exercices sur le Simulateur
Web</h3>
<p>Lancez le <strong>Simulateur Web</strong> et allez dans <strong>A32
Assembly</strong>.</p>
<table>
<thead>
<tr class="header">
<th>Exercice</th>
<th>Description</th>
<th style="text-align: center;">Difficulté</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Hello World</code></td>
<td>Afficher du texte</td>
<td style="text-align: center;">⭐</td>
</tr>
<tr class="even">
<td><code>Addition</code></td>
<td>Additionner deux registres</td>
<td style="text-align: center;">⭐</td>
</tr>
<tr class="odd">
<td><code>Soustraction</code></td>
<td>Soustraire avec le drapeau</td>
<td style="text-align: center;">⭐</td>
</tr>
<tr class="even">
<td><code>Logique</code></td>
<td>Opérations AND, OR, XOR</td>
<td style="text-align: center;">⭐</td>
</tr>
<tr class="odd">
<td><code>Conditions</code></td>
<td>Utiliser les branches conditionnelles</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="even">
<td><code>Boucles</code></td>
<td>Implémenter une boucle while</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="odd">
<td><code>Multiplication</code></td>
<td>Multiplier par additions successives</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="even">
<td><code>Fibonacci</code></td>
<td>Calculer la suite de Fibonacci</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="odd">
<td><code>Tableaux</code></td>
<td>Parcourir un tableau en mémoire</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="even">
<td><code>Maximum Tableau</code></td>
<td>Trouver le max dans un tableau</td>
<td style="text-align: center;">⭐⭐⭐</td>
</tr>
<tr class="odd">
<td><code>Fonctions</code></td>
<td>Appeler des fonctions avec BL</td>
<td style="text-align: center;">⭐⭐⭐</td>
</tr>
<tr class="even">
<td><code>Pixel</code></td>
<td>Allumer un pixel à l’écran</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="odd">
<td><code>Ligne</code></td>
<td>Dessiner une ligne</td>
<td style="text-align: center;">⭐⭐⭐</td>
</tr>
<tr class="even">
<td><code>Rectangle</code></td>
<td>Dessiner un rectangle</td>
<td style="text-align: center;">⭐⭐⭐</td>
</tr>
<tr class="odd">
<td><code>Lire un Caractère</code></td>
<td>Lire le clavier</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
</tbody>
</table>
<h3 data-number="6.12.2" id="tests-en-ligne-de-commande-2"><span class="header-section-number">6.12.2</span> Tests en ligne de
commande</h3>
<div class="sourceCode" id="cb69"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Assembler un fichier</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> a32_cli <span class="at">--</span> assemble mon_prog.s <span class="at">-o</span> mon_prog.bin</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécuter un binaire</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> a32_runner <span class="at">--</span> mon_prog.bin</span></code></pre></div>
<hr />
<h2 data-number="6.13" id="ce-quil-faut-retenir-3"><span class="header-section-number">6.13</span> Ce qu’il faut retenir</h2>
<ol type="1">
<li><p><strong>L’ISA est un contrat</strong> : Entre le matériel et le
logiciel</p></li>
<li><p><strong>RISC = Simple</strong> : Load, Compute, Store — jamais de
calcul direct en mémoire</p></li>
<li><p><strong>16 registres</strong> : R0-R12 généraux, R13=SP, R14=LR,
R15=PC</p></li>
<li><p><strong>Tout est conditionnel</strong> : <code>ADD.EQ</code>,
<code>MOV.GT</code> évitent les branchements</p></li>
<li><p><strong>Memory-Mapped I/O</strong> : L’écran et le clavier sont
des adresses mémoire</p></li>
<li><p><strong>Le cycle Fetch-Decode-Execute</strong> : Le cœur battant
du CPU</p></li>
</ol>
<p><strong>Prochaine étape</strong> : Au Chapitre 5, nous construirons
le CPU qui <strong>implémente</strong> cette architecture. Vous verrez
comment les circuits du Chapitre 1-3 sont combinés pour exécuter ces
instructions.</p>
<hr />
<p><strong>Conseil</strong> : Passez du temps sur le simulateur web à
écrire des programmes en assembleur. Comprendre l’assembleur vous aidera
énormément à comprendre le compilateur plus tard !</p>
<h1 data-number="7" id="le-processeur-cpu"><span class="header-section-number">7</span> Le Processeur (CPU)</h1>
<blockquote>
<p>“Si vous ne pouvez pas le construire, vous ne le comprenez pas.” —
Richard Feynman</p>
</blockquote>
<p>C’est le grand moment. Nous allons assembler toutes les pièces du
puzzle — portes logiques, ALU, registres, mémoire — pour construire le
<strong>cœur de l’ordinateur</strong> : le CPU A32.</p>
<hr />
<h2 data-number="7.1" id="où-en-sommes-nous-4"><span class="header-section-number">7.1</span> Où en sommes-nous ?</h2>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                     COUCHE 7: Applications                       │
├─────────────────────────────────────────────────────────────────┤
│                  COUCHE 6: Système d&#39;Exploitation                │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 5: Langage de Haut Niveau (C32)           │
├─────────────────────────────────────────────────────────────────┤
│                      COUCHE 4: Compilateur                       │
├─────────────────────────────────────────────────────────────────┤
│                   COUCHE 3: Assembleur (A32 ASM)                 │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 2: Architecture Machine (ISA)             │
├─────────────────────────────────────────────────────────────────┤
│  ══════════════► COUCHE 1: CPU - L&#39;Aboutissement ◄══════════════│
│          (Nous assemblons tout : ALU + RAM + Registres)          │
│                    (Vous êtes ici !)                             │
├─────────────────────────────────────────────────────────────────┤
│                     COUCHE 0: La Porte NAND                      │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<p>Ce chapitre est le <strong>point culminant</strong> de tout le
travail matériel. Après ce chapitre, vous aurez construit un ordinateur
complet capable d’exécuter du vrai code !</p>
<hr />
<h2 data-number="7.2" id="quest-ce-quun-cpu"><span class="header-section-number">7.2</span> Qu’est-ce qu’un CPU ?</h2>
<h3 data-number="7.2.1" id="le-chef-dorchestre"><span class="header-section-number">7.2.1</span> Le chef d’orchestre</h3>
<p>Le CPU (Central Processing Unit) est le composant qui : 1.
<strong>Lit</strong> les instructions depuis la mémoire 2.
<strong>Décode</strong> ces instructions pour comprendre quoi faire 3.
<strong>Exécute</strong> les opérations (calculs, accès mémoire,
branchements) 4. <strong>Répète</strong> à l’infini (jusqu’à HALT)</p>
<p>C’est une machine à états qui exécute une instruction après l’autre,
inlassablement.</p>
<h3 data-number="7.2.2" id="ce-que-nous-avons-construit-jusquici"><span class="header-section-number">7.2.2</span> Ce que nous avons construit
jusqu’ici</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Chapitre</th>
<th style="text-align: left;">Composant</th>
<th style="text-align: left;">Rôle dans le CPU</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1</td>
<td style="text-align: left;">Portes logiques</td>
<td style="text-align: left;">Briques de base de tout circuit</td>
</tr>
<tr class="even">
<td style="text-align: left;">2</td>
<td style="text-align: left;">ALU</td>
<td style="text-align: left;">Effectue les calculs (ADD, SUB, AND…)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: left;">Registres</td>
<td style="text-align: left;">Stockent les données du CPU (R0-R15)</td>
</tr>
<tr class="even">
<td style="text-align: left;">3</td>
<td style="text-align: left;">PC</td>
<td style="text-align: left;">Pointe vers l’instruction courante</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3</td>
<td style="text-align: left;">RAM</td>
<td style="text-align: left;">Stocke le programme et les données</td>
</tr>
<tr class="even">
<td style="text-align: left;">4</td>
<td style="text-align: left;">ISA</td>
<td style="text-align: left;">Définit les instructions à supporter</td>
</tr>
</tbody>
</table>
<h3 data-number="7.2.3" id="ce-quil-reste-à-construire"><span class="header-section-number">7.2.3</span> Ce qu’il reste à
construire</h3>
<ul>
<li><strong>Décodeur</strong> : Analyse les bits de l’instruction</li>
<li><strong>Unité de contrôle</strong> : Décide quoi activer</li>
<li><strong>Multiplexeurs de données</strong> : Routent les données
entre composants</li>
<li><strong>Le CPU lui-même</strong> : L’assemblage final</li>
</ul>
<hr />
<h2 data-number="7.3" id="architecture-du-cpu-data-path"><span class="header-section-number">7.3</span> Architecture du CPU (Data
Path)</h2>
<p>Voici le schéma complet du CPU. Chaque flèche est un fil (ou un bus
de 32 fils). Chaque boîte est un composant que vous avez construit ou
que vous allez construire.</p>
<pre><code>                            ┌──────────────────────────────────────────┐
                            │           UNITÉ DE CONTRÔLE              │
                            │  (génère tous les signaux de contrôle)   │
                            └──────────────────┬───────────────────────┘
                                               │
          Signaux de contrôle : reg_write, mem_read, mem_write, alu_op, etc.
                                               │
    ┌──────────────────────────────────────────┼──────────────────────────────┐
    │                                          │                              │
    │   ┌───────┐     ┌──────────────┐        │        ┌──────────────┐      │
    │   │       │     │   MÉMOIRE    │        │        │   DÉCODEUR   │      │
    │   │  PC   ├────►│ INSTRUCTIONS ├───────────────►│  (analyse    │      │
    │   │       │     │              │        │        │  les bits)   │      │
    │   └───┬───┘     └──────────────┘        │        └──────┬───────┘      │
    │       │              │                  │               │              │
    │       │              │ instruction      │               │              │
    │       ▼              ▼                  │               ▼              │
    │   ┌───────┐                             │         Rd, Rn, Rm, Imm      │
    │   │ ADD 4 │                             │               │              │
    │   └───┬───┘                             │               ▼              │
    │       │                                 │        ┌─────────────┐       │
    │       │ PC+4                            │        │  REGISTRES  │       │
    │       │                                 │        │   (R0-R15)  │       │
    │       ▼                                 │        └──────┬──────┘       │
    │   ┌───────┐                             │               │              │
    │   │  MUX  │ ← (Branch ou PC+4?)         │         Rn    │    Rm        │
    │   └───┬───┘                             │          │    │    │         │
    │       │                                 │          ▼    │    ▼         │
    │       │ Nouvelle valeur de PC           │        ┌──────┴────────┐     │
    │       │                                 │        │      MUX      │     │
    │       └─────────────────────────────────┼───────►│  (Rm ou Imm?) │     │
    │                                         │        └───────┬───────┘     │
    │                                         │                │             │
    │                                         │                ▼             │
    │                                         │        ┌───────────────┐     │
    │                                         │        │      ALU      │     │
    │                                         │        │  (ADD, SUB...)│     │
    │                                         │        └───────┬───────┘     │
    │                                         │                │             │
    │                                         │          Résultat + Flags    │
    │                                         │                │             │
    │                                         │                ▼             │
    │                                         │        ┌───────────────┐     │
    │                                         │        │   MÉMOIRE     │     │
    │                                         │        │   DONNÉES     │     │
    │                                         │        │ (LDR/STR)     │     │
    │                                         │        └───────┬───────┘     │
    │                                         │                │             │
    │                                         │                ▼             │
    │                                         │        ┌───────────────┐     │
    │                                         │        │      MUX      │     │
    │                                         └───────►│ (ALU ou MEM?) │     │
    │                                                  └───────┬───────┘     │
    │                                                          │             │
    │                                                          ▼             │
    │                                                  Valeur à écrire       │
    │                                                  dans le registre Rd   │
    │                                                                        │
    └────────────────────────────────────────────────────────────────────────┘</code></pre>
<h3 data-number="7.3.1" id="les-flux-de-données"><span class="header-section-number">7.3.1</span> Les flux de données</h3>
<ol type="1">
<li><strong>Fetch</strong> : PC → Mémoire Instructions → Instruction (32
bits)</li>
<li><strong>Decode</strong> : Instruction → Décodeur → (Rd, Rn, Rm, Imm,
opcode)</li>
<li><strong>Register Read</strong> : Rn, Rm → Banc de Registres →
Valeurs</li>
<li><strong>Execute</strong> : Valeurs → ALU → Résultat</li>
<li><strong>Memory</strong> : Résultat → Mémoire Données (si
LDR/STR)</li>
<li><strong>Writeback</strong> : Résultat → Registre Rd</li>
</ol>
<hr />
<h2 data-number="7.4" id="les-composants-du-cpu"><span class="header-section-number">7.4</span> Les Composants du CPU</h2>
<h3 data-number="7.4.1" id="le-compteur-de-programme-pc-1"><span class="header-section-number">7.4.1</span> 1. Le Compteur de Programme
(PC)</h3>
<p>Vous l’avez déjà construit au Chapitre 3 ! Le PC contient l’adresse
de l’instruction courante.</p>
<p><strong>Modes de fonctionnement</strong> : - <code>inc = 1</code> :
PC ← PC + 4 (instruction suivante) - <code>load = 1</code> : PC ←
adresse de branchement - <code>reset = 1</code> : PC ← 0
(redémarrage)</p>
<h3 data-number="7.4.2" id="le-décodeur-decoder"><span class="header-section-number">7.4.2</span> 2. Le Décodeur (Decoder)</h3>
<p>Le décodeur est un circuit <strong>purement combinatoire</strong> qui
“découpe” les 32 bits de l’instruction.</p>
<pre><code>                    Instruction (32 bits)
                           │
              ┌────────────┴────────────┐
              │                         │
              │        DÉCODEUR         │
              │                         │
              └─┬──┬──┬──┬──┬──┬──┬──┬──┘
                │  │  │  │  │  │  │  │
               cond class op S Rn Rd Rm imm12 imm24</code></pre>
<p><strong>Sorties du décodeur</strong> : | Signal | Bits | Description
| |:——-|:—–|:————| | <code>cond</code> | 31-28 | Code de condition (EQ,
NE, LT…) | | <code>class</code> | 27-25 | Classe d’instruction (ALU,
MEM, BRANCH) | | <code>op</code> | 24-21 | Opération ALU (ADD, SUB,
AND…) | | <code>S</code> | 20 | Mettre à jour les drapeaux ? | |
<code>Rn</code> | 19-16 | Registre source 1 | | <code>Rd</code> | 15-12
| Registre destination | | <code>Rm</code> | 3-0 | Registre source 2 | |
<code>imm12</code> | 11-0 | Valeur immédiate (12 bits) | |
<code>imm24</code> | 23-0 | Offset de branchement (24 bits) |</p>
<p>Le décodeur ne fait que du <strong>câblage</strong> — il ne calcule
rien, il ne fait que router les bits vers les bonnes sorties.</p>
<h3 data-number="7.4.3" id="lunité-de-contrôle-control"><span class="header-section-number">7.4.3</span> 3. L’Unité de Contrôle
(Control)</h3>
<p>L’unité de contrôle est le <strong>chef d’orchestre</strong>. Elle
regarde la classe et l’opcode, et décide quels signaux activer.</p>
<pre><code>                  ┌────────────────────────────────┐
                  │       UNITÉ DE CONTRÔLE        │
      class ─────►│                                │
      opcode ────►│   (Grande table de vérité)     │
      cond ──────►│                                │
      flags ─────►│                                │
                  └─┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┘
                    │  │  │  │  │  │  │  │  │  │
              reg_write  │  │  │  │  │  │  │  │
                 mem_read│  │  │  │  │  │  │  │
                 mem_write  │  │  │  │  │  │  │
                   alu_src  │  │  │  │  │  │  │
                     branch │  │  │  │  │  │  │
                       ...   ...</code></pre>
<p><strong>Exemples de signaux de contrôle</strong> :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Instruction</th>
<th style="text-align: center;">reg_write</th>
<th style="text-align: center;">mem_read</th>
<th style="text-align: center;">mem_write</th>
<th style="text-align: center;">alu_src</th>
<th style="text-align: center;">branch</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">ADD</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0 (reg)</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">ADD #imm</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1 (imm)</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">LDR</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1 (imm)</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: left;">STR</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1 (imm)</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: left;">B</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">X</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">CMP</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
</tr>
</tbody>
</table>
<h3 data-number="7.4.4" id="le-vérificateur-de-condition-condcheck"><span class="header-section-number">7.4.4</span> 4. Le Vérificateur de
Condition (CondCheck)</h3>
<p>Ce petit circuit vérifie si la condition est satisfaite.</p>
<p><strong>Entrées</strong> : - <code>cond</code> : Le code de condition
(4 bits, ex: 0000 = EQ) - <code>flags</code> : Les drapeaux NZCV</p>
<p><strong>Sortie</strong> : - <code>ok</code> : 1 si la condition est
vraie, 0 sinon</p>
<pre><code>  cond = 0000 (EQ) et Z = 1  →  ok = 1
  cond = 0000 (EQ) et Z = 0  →  ok = 0
  cond = 1110 (AL)           →  ok = 1 (toujours)</code></pre>
<p><strong>Pourquoi est-ce important ?</strong></p>
<p>Si <code>ok = 0</code>, l’instruction est “annulée” — on n’écrit pas
dans le registre, on ne fait pas le branchement. C’est la
<strong>prédication</strong> en action !</p>
<h3 data-number="7.4.5" id="le-banc-de-registres-regfile"><span class="header-section-number">7.4.5</span> 5. Le Banc de Registres
(RegFile)</h3>
<p>Vous l’avez construit au Chapitre 3 (RAM8, RAM16…). Le banc de
registres est une RAM spéciale avec : - <strong>2 ports de
lecture</strong> : Lire Rn ET Rm simultanément - <strong>1 port
d’écriture</strong> : Écrire dans Rd</p>
<pre><code>               ┌─────────────────────────────┐
    Rn (4b) ──►│                             ├───► Data_A (32b)
    Rm (4b) ──►│       BANC DE REGISTRES     ├───► Data_B (32b)
               │          (16 × 32 bits)     │
    Rd (4b) ──►│                             │
   Data_W ────►│                             │
    we ───────►│                             │
               └─────────────────────────────┘</code></pre>
<h3 data-number="7.4.6" id="les-multiplexeurs"><span class="header-section-number">7.4.6</span> 6. Les Multiplexeurs</h3>
<p>Les multiplexeurs routent les données entre les composants :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Mux</th>
<th style="text-align: left;">Choix</th>
<th style="text-align: left;">Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>ALU_src</strong></td>
<td style="text-align: left;">0: Rm, 1: Imm</td>
<td style="text-align: left;">Deuxième opérande de l’ALU</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Writeback</strong></td>
<td style="text-align: left;">0: ALU, 1: MEM</td>
<td style="text-align: left;">Source de la valeur à écrire</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>PC_src</strong></td>
<td style="text-align: left;">0: PC+4, 1: Branch</td>
<td style="text-align: left;">Prochaine valeur du PC</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="7.5" id="le-cycle-dexécution-en-détail"><span class="header-section-number">7.5</span> Le Cycle d’Exécution en
Détail</h2>
<p>Notre CPU est <strong>single-cycle</strong> : chaque instruction
s’exécute en un seul cycle d’horloge.</p>
<h3 data-number="7.5.1" id="phase-1-fetch-récupération"><span class="header-section-number">7.5.1</span> Phase 1 : Fetch
(Récupération)</h3>
<pre><code>PC ──► Mémoire Instructions ──► instruction (32 bits)</code></pre>
<p>Le PC envoie son adresse à la mémoire d’instructions. La mémoire
renvoie les 32 bits de l’instruction.</p>
<h3 data-number="7.5.2" id="phase-2-decode-décodage"><span class="header-section-number">7.5.2</span> Phase 2 : Decode
(Décodage)</h3>
<pre><code>instruction ──► Décodeur ──► cond, class, op, Rn, Rd, Rm, imm
                   │
                   └──► Unité de Contrôle ──► signaux</code></pre>
<p>Le décodeur découpe l’instruction. L’unité de contrôle décide quoi
activer.</p>
<h3 data-number="7.5.3" id="phase-3-register-read-lecture-des-registres"><span class="header-section-number">7.5.3</span> Phase 3 : Register Read
(Lecture des registres)</h3>
<pre><code>Rn, Rm ──► Banc de Registres ──► Data_A, Data_B</code></pre>
<p>Les valeurs des registres sources sont lues.</p>
<h3 data-number="7.5.4" id="phase-4-execute-exécution"><span class="header-section-number">7.5.4</span> Phase 4 : Execute
(Exécution)</h3>
<pre><code>Data_A ──────────────────┐
                         ├──► ALU ──► Résultat, Flags
Data_B ou Imm ──► MUX ───┘</code></pre>
<p>L’ALU effectue l’opération. Les drapeaux sont mis à jour (si
S=1).</p>
<h3 data-number="7.5.5" id="phase-5-memory-accès-mémoire"><span class="header-section-number">7.5.5</span> Phase 5 : Memory (Accès
mémoire)</h3>
<pre><code>                    ┌─── Si LDR : MEM[addr] → valeur
Résultat (adresse) ─┤
                    └─── Si STR : valeur → MEM[addr]</code></pre>
<p>Pour les instructions LDR/STR, on accède à la mémoire de données.</p>
<h3 data-number="7.5.6" id="phase-6-writeback-écriture"><span class="header-section-number">7.5.6</span> Phase 6 : Writeback
(Écriture)</h3>
<pre><code>Résultat (ALU ou MEM) ──► MUX ──► Banc de Registres ──► Rd</code></pre>
<p>Si <code>reg_write = 1</code> ET <code>cond_ok = 1</code>, on écrit
dans le registre destination.</p>
<h3 data-number="7.5.7" id="phase-7-pc-update"><span class="header-section-number">7.5.7</span> Phase 7 : PC Update</h3>
<pre><code>        ┌─── Si branch : PC + (offset × 4)
PC+4 ───┤
        └─── Sinon : PC + 4</code></pre>
<p>Le PC est mis à jour pour le prochain cycle.</p>
<hr />
<h2 data-number="7.6" id="implémentation-du-cpu-en-hdl"><span class="header-section-number">7.6</span> Implémentation du CPU en
HDL</h2>
<p>Voici un squelette de l’architecture du CPU :</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="cf">entity</span> <span class="dv">CPU</span> <span class="kw">is</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">port</span>(</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>    clk      <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>;</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>    reset    <span class="ot">:</span> <span class="kw">in</span> <span class="dt">bit</span>;</span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Interface mémoire</span></span>
<span id="cb83-6"><a href="#cb83-6" aria-hidden="true" tabindex="-1"></a>    instr    <span class="ot">:</span> <span class="kw">in</span> bits(<span class="dv">31</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb83-7"><a href="#cb83-7" aria-hidden="true" tabindex="-1"></a>    mem_in   <span class="ot">:</span> <span class="kw">in</span> bits(<span class="dv">31</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb83-8"><a href="#cb83-8" aria-hidden="true" tabindex="-1"></a>    pc_out   <span class="ot">:</span> <span class="kw">out</span> bits(<span class="dv">31</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb83-9"><a href="#cb83-9" aria-hidden="true" tabindex="-1"></a>    mem_addr <span class="ot">:</span> <span class="kw">out</span> bits(<span class="dv">31</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb83-10"><a href="#cb83-10" aria-hidden="true" tabindex="-1"></a>    mem_out  <span class="ot">:</span> <span class="kw">out</span> bits(<span class="dv">31</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb83-11"><a href="#cb83-11" aria-hidden="true" tabindex="-1"></a>    mem_we   <span class="ot">:</span> <span class="kw">out</span> <span class="dt">bit</span></span>
<span id="cb83-12"><a href="#cb83-12" aria-hidden="true" tabindex="-1"></a>  );</span>
<span id="cb83-13"><a href="#cb83-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end entity;</span></span>
<span id="cb83-14"><a href="#cb83-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-15"><a href="#cb83-15" aria-hidden="true" tabindex="-1"></a><span class="cf">architecture</span> <span class="dv">rtl</span> <span class="kw">of</span> <span class="fu">CPU</span> <span class="kw">is</span></span>
<span id="cb83-16"><a href="#cb83-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Signaux internes</span></span>
<span id="cb83-17"><a href="#cb83-17" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> pc<span class="ot">,</span> pc_next <span class="ot">:</span> bits(<span class="dv">31</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb83-18"><a href="#cb83-18" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> cond<span class="ot">,</span> op <span class="ot">:</span> bits(<span class="dv">3</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb83-19"><a href="#cb83-19" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> rd<span class="ot">,</span> rn<span class="ot">,</span> rm <span class="ot">:</span> bits(<span class="dv">3</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb83-20"><a href="#cb83-20" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> imm12 <span class="ot">:</span> bits(<span class="dv">11</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb83-21"><a href="#cb83-21" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> data_a<span class="ot">,</span> data_b<span class="ot">,</span> alu_result <span class="ot">:</span> bits(<span class="dv">31</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb83-22"><a href="#cb83-22" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> reg_write<span class="ot">,</span> mem_read<span class="ot">,</span> mem_write<span class="ot">,</span> alu_src<span class="ot">,</span> branch <span class="ot">:</span> <span class="dt">bit</span>;</span>
<span id="cb83-23"><a href="#cb83-23" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> n_flag<span class="ot">,</span> z_flag<span class="ot">,</span> c_flag<span class="ot">,</span> v_flag<span class="ot">,</span> cond_ok <span class="ot">:</span> <span class="dt">bit</span>;</span>
<span id="cb83-24"><a href="#cb83-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-25"><a href="#cb83-25" aria-hidden="true" tabindex="-1"></a><span class="cf">begin</span></span>
<span id="cb83-26"><a href="#cb83-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Instanciation des composants</span></span>
<span id="cb83-27"><a href="#cb83-27" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u_decoder</span><span class="ot">:</span> <span class="fu">Decoder</span> <span class="kw">port map </span>(<span class="ot">...</span>);</span>
<span id="cb83-28"><a href="#cb83-28" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u_control</span><span class="ot">:</span> <span class="fu">Control</span> <span class="kw">port map </span>(<span class="ot">...</span>);</span>
<span id="cb83-29"><a href="#cb83-29" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u_condcheck</span><span class="ot">:</span> <span class="fu">CondCheck</span> <span class="kw">port map </span>(<span class="ot">...</span>);</span>
<span id="cb83-30"><a href="#cb83-30" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u_regfile</span><span class="ot">:</span> <span class="fu">RegFile</span> <span class="kw">port map </span>(<span class="ot">...</span>);</span>
<span id="cb83-31"><a href="#cb83-31" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u_alu</span><span class="ot">:</span> <span class="fu">ALU</span> <span class="kw">port map </span>(<span class="ot">...</span>);</span>
<span id="cb83-32"><a href="#cb83-32" aria-hidden="true" tabindex="-1"></a>  <span class="dv">u_pc</span><span class="ot">:</span> <span class="fu">PC</span> <span class="kw">port map </span>(<span class="ot">...</span>);</span>
<span id="cb83-33"><a href="#cb83-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-34"><a href="#cb83-34" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Multiplexeurs</span></span>
<span id="cb83-35"><a href="#cb83-35" aria-hidden="true" tabindex="-1"></a>  alu_b <span class="ot">&lt;=</span> imm12 <span class="kw">when</span> alu_src <span class="ot">=</span> <span class="bn">&#39;1&#39;</span> <span class="kw">else</span> data_b;</span>
<span id="cb83-36"><a href="#cb83-36" aria-hidden="true" tabindex="-1"></a>  writeback <span class="ot">&lt;=</span> mem_in <span class="kw">when</span> mem_read <span class="ot">=</span> <span class="bn">&#39;1&#39;</span> <span class="kw">else</span> alu_result;</span>
<span id="cb83-37"><a href="#cb83-37" aria-hidden="true" tabindex="-1"></a>  pc_next <span class="ot">&lt;=</span> branch_addr <span class="kw">when</span> (branch <span class="kw">and</span> cond_ok) <span class="ot">=</span> <span class="bn">&#39;1&#39;</span> <span class="kw">else</span> pc_plus_4;</span>
<span id="cb83-38"><a href="#cb83-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-39"><a href="#cb83-39" aria-hidden="true" tabindex="-1"></a><span class="cf">end architecture;</span></span></code></pre></div>
<hr />
<h2 data-number="7.7" id="exercices-pratiques-4"><span class="header-section-number">7.7</span> Exercices Pratiques</h2>
<h3 data-number="7.7.1" id="exercices-sur-le-simulateur-web-4"><span class="header-section-number">7.7.1</span> Exercices sur le Simulateur
Web</h3>
<p>Lancez le <strong>Simulateur Web</strong> et allez dans <strong>HDL
Progression</strong> → <strong>Projet 5 : CPU</strong>.</p>
<table>
<thead>
<tr class="header">
<th>Exercice</th>
<th>Description</th>
<th style="text-align: center;">Difficulté</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Decoder</code></td>
<td>Découper l’instruction en champs</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="even">
<td><code>CondCheck</code></td>
<td>Vérifier les conditions (EQ, NE, LT…)</td>
<td style="text-align: center;">⭐⭐</td>
</tr>
<tr class="odd">
<td><code>Control</code></td>
<td>Générer les signaux de contrôle</td>
<td style="text-align: center;">⭐⭐⭐</td>
</tr>
<tr class="even">
<td><code>CPU</code></td>
<td>L’assemblage final !</td>
<td style="text-align: center;">⭐⭐⭐⭐</td>
</tr>
</tbody>
</table>
<h3 data-number="7.7.2" id="ordre-de-progression"><span class="header-section-number">7.7.2</span> Ordre de progression</h3>
<ol type="1">
<li><strong>Decoder</strong> : Commencez par là. C’est du pur câblage.
<ul>
<li>Utilisez la syntaxe <code>instr(31 downto 28)</code> pour extraire
les bits</li>
</ul></li>
<li><strong>CondCheck</strong> : Table de vérité des conditions
<ul>
<li>EQ : Z = 1</li>
<li>NE : Z = 0</li>
<li>LT : N ≠ V</li>
<li>etc.</li>
</ul></li>
<li><strong>Control</strong> : La logique de commande
<ul>
<li>Pour chaque classe d’instruction, décidez les signaux</li>
<li>Attention aux cas spéciaux (CMP ne fait pas reg_write)</li>
</ul></li>
<li><strong>CPU</strong> : L’assemblage final
<ul>
<li>Suivez le schéma du data path</li>
<li>N’oubliez pas les multiplexeurs !</li>
</ul></li>
</ol>
<h3 data-number="7.7.3" id="tests-en-ligne-de-commande-3"><span class="header-section-number">7.7.3</span> Tests en ligne de
commande</h3>
<div class="sourceCode" id="cb84"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Tester le décodeur</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> hdl_cli <span class="at">--</span> test hdl_lib/05_cpu/Decoder.hdl</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Tester le CPU complet</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> hdl_cli <span class="at">--</span> test hdl_lib/05_cpu/CPU.hdl</span></code></pre></div>
<hr />
<h2 data-number="7.8" id="conseils-de-débogage"><span class="header-section-number">7.8</span> Conseils de Débogage</h2>
<h3 data-number="7.8.1" id="le-pc-reste-à-0"><span class="header-section-number">7.8.1</span> Le PC reste à 0 ?</h3>
<ul>
<li>Vérifiez que <code>inc = 1</code> par défaut</li>
<li>Vérifiez que le reset n’est pas bloqué</li>
</ul>
<h3 data-number="7.8.2" id="les-branchements-ne-marchent-pas"><span class="header-section-number">7.8.2</span> Les branchements ne marchent
pas ?</h3>
<ul>
<li>L’offset dans l’instruction est en mots (× 4 pour avoir des
octets)</li>
<li>Vérifiez que <code>cond_ok</code> est correct</li>
<li>Vérifiez le calcul de l’adresse de branchement</li>
</ul>
<h3 data-number="7.8.3" id="rien-ne-sécrit-dans-les-registres"><span class="header-section-number">7.8.3</span> Rien ne s’écrit dans les
registres ?</h3>
<ul>
<li><code>reg_write</code> doit être à 1</li>
<li><code>cond_ok</code> doit être à 1</li>
<li>Le registre destination ne doit pas être R15 (géré à part)</li>
</ul>
<h3 data-number="7.8.4" id="ldrstr-ne-fonctionne-pas"><span class="header-section-number">7.8.4</span> LDR/STR ne fonctionne pas
?</h3>
<ul>
<li>Vérifiez le calcul de l’adresse (base + offset)</li>
<li>Vérifiez les signaux <code>mem_read</code> et
<code>mem_write</code></li>
<li>Attention à l’alignement (adresses multiples de 4)</li>
</ul>
<hr />
<h2 data-number="7.9" id="aller-plus-loin-le-cpu-pipeline"><span class="header-section-number">7.9</span> Aller Plus Loin : Le CPU
Pipeline</h2>
<p>Le CPU single-cycle que nous avons construit est simple et
pédagogique. Mais dans le monde réel, il serait <strong>très
lent</strong>. Les vrais processeurs utilisent une technique appelée
<strong>pipeline</strong> pour être beaucoup plus rapides.</p>
<p>Cette section explique en détail ce qu’est un pipeline, pourquoi il
est nécessaire, et comment le construire.</p>
<hr />
<h3 data-number="7.9.1" id="pourquoi-le-cpu-single-cycle-est-lent"><span class="header-section-number">7.9.1</span> Pourquoi le CPU Single-Cycle
est Lent</h3>
<h4 data-number="7.9.1.1" id="le-problème-de-la-chaîne-critique"><span class="header-section-number">7.9.1.1</span> Le problème de la chaîne
critique</h4>
<p>Dans notre CPU single-cycle, une instruction doit traverser
<strong>tous</strong> les composants en un seul cycle :</p>
<pre><code>┌──────────────────────────────────────────────────────────────────┐
│  PC → Mémoire → Décodeur → Registres → ALU → Mémoire → Registres │
│                                                                   │
│  ←───────────────── UN SEUL CYCLE ─────────────────────────────→ │
└──────────────────────────────────────────────────────────────────┘</code></pre>
<p>Le cycle d’horloge doit être assez <strong>long</strong> pour que le
signal traverse tout ce chemin. Si chaque étape prend 1 nanoseconde, le
cycle doit faire au minimum 6 ns.</p>
<p><strong>Résultat</strong> : Même si certaines instructions n’ont pas
besoin de la mémoire de données (comme ADD), elles prennent quand même 6
ns.</p>
<h4 data-number="7.9.1.2" id="une-analogie-la-laverie"><span class="header-section-number">7.9.1.2</span> Une analogie : La
laverie</h4>
<p>Imaginez que vous avez 4 lessives à faire. Chaque lessive a 4 étapes
: 1. <strong>Laver</strong> (30 min) 2. <strong>Sécher</strong> (30 min)
3. <strong>Plier</strong> (30 min) 4. <strong>Ranger</strong> (30
min)</p>
<p><strong>Approche “single-cycle”</strong> : Attendre qu’une lessive
soit complètement terminée avant de commencer la suivante.</p>
<pre><code>Lessive 1 : |──Laver──|──Sécher──|──Plier──|──Ranger──|
Lessive 2 :                                            |──Laver──|──Sécher──|...</code></pre>
<p>Temps total : 4 lessives × 2h = <strong>8 heures</strong></p>
<p><strong>Approche “pipeline”</strong> : Dès que la machine à laver est
libre, commencer la lessive suivante !</p>
<pre><code>Lessive 1 : |──Laver──|──Sécher──|──Plier──|──Ranger──|
Lessive 2 :           |──Laver──|──Sécher──|──Plier──|──Ranger──|
Lessive 3 :                     |──Laver──|──Sécher──|──Plier──|──Ranger──|
Lessive 4 :                               |──Laver──|──Sécher──|──Plier──|──Ranger──|</code></pre>
<p>Temps total : 2h + 3 × 30min = <strong>3h30</strong></p>
<p>Le pipeline ne rend pas une lessive individuelle plus rapide, mais il
permet de traiter <strong>plus de lessives par heure</strong> !</p>
<hr />
<h3 data-number="7.9.2" id="le-pipeline-à-5-étages"><span class="header-section-number">7.9.2</span> Le Pipeline à 5 Étages</h3>
<p>Notre CPU pipeliné divise l’exécution en <strong>5 étapes</strong>,
chacune prenant exactement 1 cycle d’horloge :</p>
<pre><code>┌────────────────────────────────────────────────────────────────────────────┐
│                                                                            │
│  ┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐                     │
│  │  IF  │ → │  ID  │ → │  EX  │ → │ MEM  │ → │  WB  │                     │
│  │Fetch │   │Decode│   │Execute   │Memory│   │Write │                     │
│  └──────┘   └──────┘   └──────┘   └──────┘   └──────┘                     │
│                                                                            │
│  1 cycle    1 cycle    1 cycle    1 cycle    1 cycle                      │
│                                                                            │
└────────────────────────────────────────────────────────────────────────────┘</code></pre>
<h4 data-number="7.9.2.1" id="étape-1-if-instruction-fetch"><span class="header-section-number">7.9.2.1</span> Étape 1 : IF (Instruction
Fetch)</h4>
<p><strong>But</strong> : Aller chercher l’instruction en mémoire.</p>
<pre><code>┌─────────────────────────────────────────────┐
│  IF - Instruction Fetch                     │
│                                             │
│    PC ────► Mémoire ────► Instruction       │
│    │        Instructions    (32 bits)       │
│    │                                        │
│    └───► PC + 4 (préparé pour la suite)     │
│                                             │
└─────────────────────────────────────────────┘</code></pre>
<p><strong>Ce qui se passe</strong> : 1. Le PC (Program Counter) envoie
son adresse à la mémoire 2. La mémoire renvoie l’instruction (32 bits)
3. On calcule PC + 4 pour l’instruction suivante</p>
<p><strong>Sortie</strong> : L’instruction et PC+4 sont stockés dans le
registre IF/ID.</p>
<h4 data-number="7.9.2.2" id="étape-2-id-instruction-decode"><span class="header-section-number">7.9.2.2</span> Étape 2 : ID (Instruction
Decode)</h4>
<p><strong>But</strong> : Comprendre l’instruction et lire les registres
sources.</p>
<pre><code>┌─────────────────────────────────────────────┐
│  ID - Instruction Decode                    │
│                                             │
│    Instruction ─┬─► Décodeur ──► Signaux    │
│                 │                de contrôle│
│                 │                           │
│                 └─► Registres ──► Valeurs   │
│                      (Rn, Rm)     (A, B)    │
│                                             │
└─────────────────────────────────────────────┘</code></pre>
<p><strong>Ce qui se passe</strong> : 1. Le décodeur extrait les champs
(Rd, Rn, Rm, opcode, etc.) 2. L’unité de contrôle génère les signaux
(reg_write, mem_read, etc.) 3. On lit les valeurs des registres Rn et Rm
4. On détecte les éventuels aléas (hazards)</p>
<p><strong>Sortie</strong> : Tout est stocké dans le registre ID/EX.</p>
<h4 data-number="7.9.2.3" id="étape-3-ex-execute"><span class="header-section-number">7.9.2.3</span> Étape 3 : EX (Execute)</h4>
<p><strong>But</strong> : Effectuer le calcul.</p>
<pre><code>┌─────────────────────────────────────────────┐
│  EX - Execute                               │
│                                             │
│    Valeur A ──────┐                         │
│                   ├──► ALU ──► Résultat     │
│    Valeur B ──┬───┘            + Flags      │
│    ou Imm    MUX                            │
│                                             │
│    (Pour Branch: calcul de l&#39;adresse cible) │
│                                             │
└─────────────────────────────────────────────┘</code></pre>
<p><strong>Ce qui se passe</strong> : 1. L’ALU effectue l’opération
(ADD, SUB, AND, etc.) 2. Les flags (N, Z, C, V) sont calculés 3. Pour
les branchements, on calcule l’adresse cible 4. Le forwarding peut
injecter des valeurs ici (on verra plus tard)</p>
<p><strong>Sortie</strong> : Le résultat ALU est stocké dans le registre
EX/MEM.</p>
<h4 data-number="7.9.2.4" id="étape-4-mem-memory-access"><span class="header-section-number">7.9.2.4</span> Étape 4 : MEM (Memory
Access)</h4>
<p><strong>But</strong> : Lire ou écrire en mémoire (pour LDR/STR
seulement).</p>
<pre><code>┌─────────────────────────────────────────────┐
│  MEM - Memory Access                        │
│                                             │
│    Si LDR:  Adresse ──► Mémoire ──► Donnée  │
│                         Données             │
│                                             │
│    Si STR:  Adresse, Donnée ──► Mémoire     │
│                                             │
│    Sinon:   (le résultat ALU passe juste)   │
│                                             │
└─────────────────────────────────────────────┘</code></pre>
<p><strong>Ce qui se passe</strong> : 1. Pour LDR : on lit la mémoire à
l’adresse calculée 2. Pour STR : on écrit la valeur en mémoire 3. Pour
les autres instructions : rien (le résultat ALU est juste transmis)</p>
<p><strong>Sortie</strong> : Le résultat (ALU ou mémoire) est stocké
dans le registre MEM/WB.</p>
<h4 data-number="7.9.2.5" id="étape-5-wb-write-back"><span class="header-section-number">7.9.2.5</span> Étape 5 : WB (Write
Back)</h4>
<p><strong>But</strong> : Écrire le résultat dans le registre
destination.</p>
<pre><code>┌─────────────────────────────────────────────┐
│  WB - Write Back                            │
│                                             │
│    Résultat ──► MUX ──► Banc de Registres   │
│    (ALU ou MEM)          ↓                  │
│                         Rd                  │
│                                             │
└─────────────────────────────────────────────┘</code></pre>
<p><strong>Ce qui se passe</strong> : 1. On choisit le résultat à écrire
(ALU ou mémoire) 2. Si <code>reg_write = 1</code>, on écrit dans le
registre Rd</p>
<hr />
<h3 data-number="7.9.3" id="visualisation-du-pipeline-en-action"><span class="header-section-number">7.9.3</span> Visualisation du Pipeline en
Action</h3>
<p>Voici comment 5 instructions traversent le pipeline :</p>
<pre><code>         │ Cycle 1 │ Cycle 2 │ Cycle 3 │ Cycle 4 │ Cycle 5 │ Cycle 6 │ Cycle 7 │
─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
Instr 1  │   IF    │   ID    │   EX    │   MEM   │   WB    │         │         │
Instr 2  │         │   IF    │   ID    │   EX    │   MEM   │   WB    │         │
Instr 3  │         │         │   IF    │   ID    │   EX    │   MEM   │   WB    │
Instr 4  │         │         │         │   IF    │   ID    │   EX    │   MEM   │...
Instr 5  │         │         │         │         │   IF    │   ID    │   EX    │...
─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘</code></pre>
<p><strong>Observation clé</strong> : À partir du cycle 5, le pipeline
est “rempli” et on termine <strong>une instruction par cycle</strong>
!</p>
<p><strong>Comparaison des performances</strong> :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">CPU</th>
<th style="text-align: left;">100 instructions</th>
<th style="text-align: left;">Temps (si cycle = 1ns)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Single-cycle</td>
<td style="text-align: left;">100 cycles</td>
<td style="text-align: left;">100 ns</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pipeline 5 étages</td>
<td style="text-align: left;">104 cycles*</td>
<td style="text-align: left;">104 ns</td>
</tr>
</tbody>
</table>
<p>*Attendez… le pipeline n’est pas plus rapide ?</p>
<p>C’est parce que le cycle du pipeline est <strong>5× plus
court</strong> ! Chaque étage ne fait qu’une partie du travail.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">CPU</th>
<th style="text-align: left;">Durée cycle</th>
<th style="text-align: left;">100 instructions</th>
<th style="text-align: left;">Temps réel</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Single-cycle</td>
<td style="text-align: left;">5 ns</td>
<td style="text-align: left;">100 cycles</td>
<td style="text-align: left;"><strong>500 ns</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">Pipeline</td>
<td style="text-align: left;">1 ns</td>
<td style="text-align: left;">104 cycles</td>
<td style="text-align: left;"><strong>104 ns</strong></td>
</tr>
</tbody>
</table>
<p>Le pipeline est <strong>~5× plus rapide</strong> !</p>
<hr />
<h3 data-number="7.9.4" id="les-registres-de-pipeline"><span class="header-section-number">7.9.4</span> Les Registres de
Pipeline</h3>
<p>Pour que le pipeline fonctionne, il faut <strong>stocker</strong> les
résultats intermédiaires entre chaque étage. C’est le rôle des
<strong>registres de pipeline</strong>.</p>
<pre><code>┌──────┐   ┌───────────┐   ┌──────┐   ┌───────────┐   ┌──────┐
│  IF  │ → │  IF/ID    │ → │  ID  │ → │  ID/EX    │ → │  EX  │ → ...
│      │   │  Register │   │      │   │  Register │   │      │
└──────┘   └───────────┘   └──────┘   └───────────┘   └──────┘
                │                           │
          (instruction,              (valeurs registres,
           PC+4)                      signaux contrôle,
                                      Rd, Rn, Rm, imm)</code></pre>
<h4 data-number="7.9.4.1" id="le-registre-ifid"><span class="header-section-number">7.9.4.1</span> Le registre IF/ID</h4>
<p><strong>Stocke</strong> : - L’instruction (32 bits) - PC+4 (32
bits)</p>
<p><strong>Signaux spéciaux</strong> : - <code>stall</code> : Si 1,
garder les mêmes valeurs (ne pas avancer) - <code>flush</code> : Si 1,
mettre l’instruction à NOP (annuler)</p>
<pre><code>┌─────────────────────────────────────────────┐
│  IF/ID Register                             │
│                                             │
│  Entrées:                                   │
│    if_instr ───────────┐                    │
│    if_pc_plus4 ────────┤                    │
│    stall ──────────────┤                    │
│    flush ──────────────┘                    │
│                                             │
│  Comportement:                              │
│    Si reset OU flush:                       │
│      → instr = NOP, pc = 0                  │
│    Sinon si stall:                          │
│      → garder les valeurs actuelles         │
│    Sinon:                                   │
│      → capturer les nouvelles valeurs       │
│                                             │
│  Sorties:                                   │
│    id_instr ←──────────┘                    │
│    id_pc_plus4 ←───────                     │
│                                             │
└─────────────────────────────────────────────┘</code></pre>
<hr />
<h3 data-number="7.9.5" id="les-aléas-hazards"><span class="header-section-number">7.9.5</span> Les Aléas (Hazards)</h3>
<p>Le pipeline crée de nouveaux problèmes. Quand une instruction dépend
du résultat d’une instruction précédente qui n’est pas encore terminée,
on a un <strong>aléa</strong>.</p>
<h4 data-number="7.9.5.1" id="aléa-de-données-data-hazard"><span class="header-section-number">7.9.5.1</span> Aléa de Données (Data
Hazard)</h4>
<p><strong>Exemple problématique</strong> :</p>
<pre class="assembly"><code>ADD R1, R2, R3    ; Instruction 1: R1 = R2 + R3
SUB R4, R1, R5    ; Instruction 2: R4 = R1 - R5 (utilise R1!)</code></pre>
<p>Visualisons dans le pipeline :</p>
<pre><code>         │ Cycle 1 │ Cycle 2 │ Cycle 3 │ Cycle 4 │ Cycle 5 │
─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
ADD R1   │   IF    │   ID    │   EX    │   MEM   │   WB ←──── R1 écrit ici!
SUB R4,R1│         │   IF    │   ID ←──── R1 lu ici!         │</code></pre>
<p><strong>Le problème</strong> : SUB lit R1 au cycle 3 (étage ID), mais
ADD n’écrit R1 qu’au cycle 5 (étage WB). SUB va lire
l’<strong>ancienne</strong> valeur de R1 !</p>
<h4 data-number="7.9.5.2" id="solution-1-le-forwarding-bypass"><span class="header-section-number">7.9.5.2</span> Solution 1 : Le Forwarding
(Bypass)</h4>
<p>Au lieu d’attendre que R1 soit écrit dans le banc de registres, on
peut <strong>transférer</strong> le résultat directement depuis l’étage
EX ou MEM vers l’étage où on en a besoin.</p>
<pre><code>         │ Cycle 1 │ Cycle 2 │ Cycle 3 │ Cycle 4 │ Cycle 5 │
─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
ADD R1   │   IF    │   ID    │   EX ───┼── Résultat disponible!
SUB R4,R1│         │   IF    │   ID    │   EX ←── Forward!
                                            │
                                      (on prend le résultat
                                       directement de ADD)</code></pre>
<p><strong>Le ForwardUnit</strong> détecte ces situations et redirige
les données :</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  ForwardUnit                                                │
│                                                             │
│  Entrées:                                                   │
│    ex_rn, ex_rm  : registres sources de l&#39;instruction en EX │
│    mem_rd        : registre destination en MEM              │
│    mem_reg_write : MEM va écrire un registre?               │
│    wb_rd         : registre destination en WB               │
│    wb_reg_write  : WB va écrire un registre?                │
│                                                             │
│  Logique:                                                   │
│    Si MEM.rd = EX.rn et MEM écrit → forward depuis MEM      │
│    Sinon si WB.rd = EX.rn et WB écrit → forward depuis WB   │
│    Sinon → pas de forwarding                                │
│                                                             │
│  Sorties (2 bits chacune):                                  │
│    forward_a : 00=rien, 01=depuis MEM, 10=depuis WB         │
│    forward_b : 00=rien, 01=depuis MEM, 10=depuis WB         │
│                                                             │
└─────────────────────────────────────────────────────────────┘</code></pre>
<h4 data-number="7.9.5.3" id="solution-2-le-stall-pour-load-use"><span class="header-section-number">7.9.5.3</span> Solution 2 : Le Stall (pour
Load-Use)</h4>
<p>Le forwarding ne résout pas tous les cas. Considérons :</p>
<pre class="assembly"><code>LDR R1, [R2]      ; Charge R1 depuis la mémoire
ADD R4, R1, R5    ; Utilise R1 immédiatement!</code></pre>
<pre><code>         │ Cycle 1 │ Cycle 2 │ Cycle 3 │ Cycle 4 │ Cycle 5 │
─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
LDR R1   │   IF    │   ID    │   EX    │   MEM ←── R1 disponible ici
ADD R4,R1│         │   IF    │   ID    │   EX ←── Besoin de R1 ici!</code></pre>
<p><strong>Problème</strong> : ADD a besoin de R1 dans son étage EX
(cycle 4), mais LDR ne lit la mémoire qu’à l’étage MEM (aussi cycle 4).
On ne peut pas faire de forwarding vers le passé !</p>
<p><strong>Solution</strong> : Insérer une <strong>bulle</strong>
(stall) pour retarder ADD d’un cycle.</p>
<pre><code>         │ Cycle 1 │ Cycle 2 │ Cycle 3 │ Cycle 4 │ Cycle 5 │ Cycle 6 │
─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
LDR R1   │   IF    │   ID    │   EX    │   MEM───┼──►Forward possible!
ADD R4,R1│         │   IF    │   ID    │  STALL  │   EX ←── Forward OK!
Instr 3  │         │         │   IF    │  STALL  │   ID    │   EX    │</code></pre>
<p><strong>Le HazardDetect</strong> détecte ces situations :</p>
<pre><code>┌─────────────────────────────────────────────────────────────┐
│  HazardDetect                                               │
│                                                             │
│  Entrées:                                                   │
│    id_rn, id_rm    : registres sources en ID                │
│    id_rn_used      : Rn est utilisé par l&#39;instruction?      │
│    id_rm_used      : Rm est utilisé par l&#39;instruction?      │
│    ex_rd           : registre destination en EX             │
│    ex_mem_read     : instruction en EX est un LDR?          │
│                                                             │
│  Logique:                                                   │
│    Si EX est un load (ex_mem_read = 1)                      │
│    ET ID utilise ce registre (id_rn = ex_rd ou id_rm = ex_rd)│
│    → Déclencher un STALL                                    │
│                                                             │
│  Sortie:                                                    │
│    stall : 1 = bloquer IF et ID, insérer NOP en EX          │
│                                                             │
└─────────────────────────────────────────────────────────────┘</code></pre>
<h4 data-number="7.9.5.4" id="aléa-de-contrôle-control-hazard"><span class="header-section-number">7.9.5.4</span> Aléa de Contrôle (Control
Hazard)</h4>
<p>Les branchements posent un autre problème :</p>
<pre class="assembly"><code>BEQ label         ; Si égal, sauter à label
ADD R1, R2, R3    ; Cette instruction est-elle exécutée?
SUB R4, R5, R6    ; Et celle-ci?
label:
MOV R7, #42</code></pre>
<pre><code>         │ Cycle 1 │ Cycle 2 │ Cycle 3 │ Cycle 4 │
─────────┼─────────┼─────────┼─────────┼─────────┤
BEQ      │   IF    │   ID    │   EX ←── On sait si on branche
ADD      │         │   IF    │   ID    │  ???    │
SUB      │         │         │   IF    │  ???    │</code></pre>
<p><strong>Problème</strong> : Quand on exécute BEQ, on a déjà commencé
à chercher les instructions suivantes ! Si le branchement est pris, ADD
et SUB n’auraient jamais dû être exécutées.</p>
<p><strong>Solution</strong> : Le <strong>Flush</strong></p>
<p>Si le branchement est pris, on <strong>annule</strong> les
instructions qui n’auraient pas dû être chargées :</p>
<pre><code>         │ Cycle 1 │ Cycle 2 │ Cycle 3 │ Cycle 4 │ Cycle 5 │
─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
BEQ      │   IF    │   ID    │   EX    │   MEM   │   WB    │
ADD      │         │   IF    │   ID    │  FLUSH  │         │
SUB      │         │         │   IF    │  FLUSH  │         │
MOV R7   │         │         │         │   IF    │   ID    │...</code></pre>
<p>Le signal <code>flush</code> met les registres de pipeline à NOP
(instruction qui ne fait rien).</p>
<hr />
<h3 data-number="7.9.6" id="architecture-complète-du-cpu-pipeline"><span class="header-section-number">7.9.6</span> Architecture Complète du CPU
Pipeline</h3>
<pre><code>┌────────────────────────────────────────────────────────────────────────────────┐
│                            CPU PIPELINE 5 ÉTAGES                               │
│                                                                                │
│  ┌───────┐     ┌───────┐     ┌───────┐     ┌───────┐     ┌───────┐           │
│  │       │     │ IF/ID │     │       │     │ ID/EX │     │       │           │
│  │  IF   │────►│  Reg  │────►│  ID   │────►│  Reg  │────►│  EX   │──...      │
│  │       │     │       │     │       │     │       │     │       │           │
│  └───┬───┘     └───────┘     └───┬───┘     └───────┘     └───┬───┘           │
│      │                           │                           │               │
│      │                           │                           │               │
│      │                     ┌─────┴─────┐               ┌─────┴─────┐         │
│      │                     │  Hazard   │               │  Forward  │         │
│      │                     │  Detect   │               │   Unit    │         │
│      │                     └─────┬─────┘               └───────────┘         │
│      │                           │                                           │
│      │◄──────────────────────────┘ (stall)                                   │
│      │                                                                       │
│      │◄──────────────────────────────────────────────────── (flush si branch)│
│                                                                              │
└──────────────────────────────────────────────────────────────────────────────┘</code></pre>
<hr />
<h3 data-number="7.9.7" id="exercices-pratiques-projet-6"><span class="header-section-number">7.9.7</span> Exercices Pratiques : Projet
6</h3>
<p>Le <strong>Projet 6 : CPU Pipeline</strong> vous permet de construire
ces composants.</p>
<h4 data-number="7.9.7.1" id="exercice-1-if_id_reg"><span class="header-section-number">7.9.7.1</span> Exercice 1 : IF_ID_Reg</h4>
<p><strong>Objectif</strong> : Implémenter le registre de pipeline
IF/ID.</p>
<p><strong>Comportement</strong> : 1. Sur <code>reset=&#39;1&#39;</code> OU
<code>flush=&#39;1&#39;</code> : mettre l’instruction à NOP (0xE0000000) 2. Sur
<code>stall=&#39;1&#39;</code> : garder les valeurs actuelles 3. Sinon :
capturer les nouvelles valeurs</p>
<p><strong>Squelette</strong> :</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="cf">architecture</span> <span class="dv">rtl</span> <span class="kw">of</span> <span class="fu">IF_ID_Reg</span> <span class="kw">is</span></span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> instr_reg <span class="ot">:</span> bits(<span class="dv">31</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> pc_plus4_reg <span class="ot">:</span> bits(<span class="dv">31</span> <span class="ot">downto</span> <span class="dv">0</span>);</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a><span class="cf">begin</span></span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>  <span class="sc">process</span>(clk)</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>  <span class="sc">begin</span></span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">rising_edge</span>(clk) <span class="cf">then</span></span>
<span id="cb109-8"><a href="#cb109-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (reset <span class="ot">=</span> <span class="bn">&#39;1&#39;</span>) <span class="kw">or</span> (flush <span class="ot">=</span> <span class="bn">&#39;1&#39;</span>) <span class="cf">then</span></span>
<span id="cb109-9"><a href="#cb109-9" aria-hidden="true" tabindex="-1"></a>        instr_reg <span class="ot">&lt;=</span> x<span class="st">&quot;E0000000&quot;</span>;  <span class="co">-- NOP</span></span>
<span id="cb109-10"><a href="#cb109-10" aria-hidden="true" tabindex="-1"></a>        pc_plus4_reg <span class="ot">&lt;=</span> x<span class="st">&quot;00000000&quot;</span>;</span>
<span id="cb109-11"><a href="#cb109-11" aria-hidden="true" tabindex="-1"></a>      <span class="cf">elsif</span> stall <span class="ot">=</span> <span class="bn">&#39;0&#39;</span> <span class="cf">then</span></span>
<span id="cb109-12"><a href="#cb109-12" aria-hidden="true" tabindex="-1"></a>        instr_reg <span class="ot">&lt;=</span> if_instr;</span>
<span id="cb109-13"><a href="#cb109-13" aria-hidden="true" tabindex="-1"></a>        pc_plus4_reg <span class="ot">&lt;=</span> if_pc_plus4;</span>
<span id="cb109-14"><a href="#cb109-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">end if;</span></span>
<span id="cb109-15"><a href="#cb109-15" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Si stall=&#39;1&#39;, on ne fait rien (garde les valeurs)</span></span>
<span id="cb109-16"><a href="#cb109-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">end if;</span></span>
<span id="cb109-17"><a href="#cb109-17" aria-hidden="true" tabindex="-1"></a>  <span class="sc">end process;</span></span>
<span id="cb109-18"><a href="#cb109-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb109-19"><a href="#cb109-19" aria-hidden="true" tabindex="-1"></a>  id_instr <span class="ot">&lt;=</span> instr_reg;</span>
<span id="cb109-20"><a href="#cb109-20" aria-hidden="true" tabindex="-1"></a>  id_pc_plus4 <span class="ot">&lt;=</span> pc_plus4_reg;</span>
<span id="cb109-21"><a href="#cb109-21" aria-hidden="true" tabindex="-1"></a><span class="cf">end architecture;</span></span></code></pre></div>
<h4 data-number="7.9.7.2" id="exercice-2-hazarddetect"><span class="header-section-number">7.9.7.2</span> Exercice 2 :
HazardDetect</h4>
<p><strong>Objectif</strong> : Détecter les aléas load-use.</p>
<p><strong>Logique</strong> :</p>
<pre><code>rn_hazard = ex_mem_read AND id_rn_used AND (id_rn = ex_rd)
rm_hazard = ex_mem_read AND id_rm_used AND (id_rm = ex_rd)
stall = rn_hazard OR rm_hazard</code></pre>
<p><strong>En HDL</strong> (attention : pas de <code>when...else</code>,
utiliser la logique booléenne) :</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="cf">architecture</span> <span class="dv">rtl</span> <span class="kw">of</span> <span class="fu">HazardDetect</span> <span class="kw">is</span></span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> rn_hazard <span class="ot">:</span> <span class="dt">bit</span>;</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> rm_hazard <span class="ot">:</span> <span class="dt">bit</span>;</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="cf">begin</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>  rn_hazard <span class="ot">&lt;=</span> ex_mem_read <span class="kw">and</span> id_rn_used <span class="kw">and</span> (id_rn <span class="ot">=</span> ex_rd);</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>  rm_hazard <span class="ot">&lt;=</span> ex_mem_read <span class="kw">and</span> id_rm_used <span class="kw">and</span> (id_rm <span class="ot">=</span> ex_rd);</span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>  stall <span class="ot">&lt;=</span> rn_hazard <span class="kw">or</span> rm_hazard;</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a><span class="cf">end architecture;</span></span></code></pre></div>
<h4 data-number="7.9.7.3" id="exercice-3-forwardunit"><span class="header-section-number">7.9.7.3</span> Exercice 3 :
ForwardUnit</h4>
<p><strong>Objectif</strong> : Générer les signaux de forwarding.</p>
<p><strong>Encodage</strong> : - <code>00</code> : Pas de forwarding -
<code>01</code> : Forward depuis MEM - <code>10</code> : Forward depuis
WB</p>
<p><strong>Logique</strong> :</p>
<pre><code>mem_fwd_a = mem_reg_write AND (mem_rd = ex_rn)
wb_fwd_a = wb_reg_write AND (wb_rd = ex_rn) AND (NOT mem_fwd_a)
forward_a = wb_fwd_a &amp; mem_fwd_a   (concaténation de bits)</code></pre>
<p><strong>En HDL</strong> :</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode vhdl"><code class="sourceCode vhdl"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="cf">architecture</span> <span class="dv">rtl</span> <span class="kw">of</span> <span class="fu">ForwardUnit</span> <span class="kw">is</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> mem_fwd_a<span class="ot">,</span> wb_fwd_a <span class="ot">:</span> <span class="dt">bit</span>;</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">signal</span> mem_fwd_b<span class="ot">,</span> wb_fwd_b <span class="ot">:</span> <span class="dt">bit</span>;</span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="cf">begin</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a>  mem_fwd_a <span class="ot">&lt;=</span> mem_reg_write <span class="kw">and</span> (mem_rd <span class="ot">=</span> ex_rn);</span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>  wb_fwd_a <span class="ot">&lt;=</span> wb_reg_write <span class="kw">and</span> (wb_rd <span class="ot">=</span> ex_rn) <span class="kw">and</span> (<span class="kw">not</span> mem_fwd_a);</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a>  mem_fwd_b <span class="ot">&lt;=</span> mem_reg_write <span class="kw">and</span> (mem_rd <span class="ot">=</span> ex_rm);</span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a>  wb_fwd_b <span class="ot">&lt;=</span> wb_reg_write <span class="kw">and</span> (wb_rd <span class="ot">=</span> ex_rm) <span class="kw">and</span> (<span class="kw">not</span> mem_fwd_b);</span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a>  forward_a <span class="ot">&lt;=</span> wb_fwd_a <span class="ot">&amp;</span> mem_fwd_a;</span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a>  forward_b <span class="ot">&lt;=</span> wb_fwd_b <span class="ot">&amp;</span> mem_fwd_b;</span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a><span class="cf">end architecture;</span></span></code></pre></div>
<h4 data-number="7.9.7.4" id="exercice-4-cpu_pipeline-projet-final"><span class="header-section-number">7.9.7.4</span> Exercice 4 : CPU_Pipeline
(Projet Final)</h4>
<p>C’est le grand défi ! Assembler tous les composants en un CPU
pipeliné complet.</p>
<p><strong>Conseil</strong> : L’implémentation de référence est dans
<code>hdl_lib/05_cpu/CPU_Pipeline.hdl</code> (~450 lignes).</p>
<hr />
<h3 data-number="7.9.8" id="résumé-pipeline-vs-single-cycle"><span class="header-section-number">7.9.8</span> Résumé : Pipeline vs
Single-Cycle</h3>
<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 43%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Aspect</th>
<th style="text-align: left;">Single-Cycle</th>
<th style="text-align: left;">Pipeline</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Instructions en
parallèle</strong></td>
<td style="text-align: left;">1</td>
<td style="text-align: left;">Jusqu’à 5</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Throughput</strong></td>
<td style="text-align: left;">1 instr / 5 unités de temps</td>
<td style="text-align: left;">1 instr / 1 unité de temps</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Complexité</strong></td>
<td style="text-align: left;">Simple</td>
<td style="text-align: left;">Plus complexe</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Aléas</strong></td>
<td style="text-align: left;">Aucun</td>
<td style="text-align: left;">Data hazards, Control hazards</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Composants
supplémentaires</strong></td>
<td style="text-align: left;">Aucun</td>
<td style="text-align: left;">Registres pipeline, Hazard Detect, Forward
Unit</td>
</tr>
</tbody>
</table>
<hr />
<h3 data-number="7.9.9" id="pour-aller-encore-plus-loin"><span class="header-section-number">7.9.9</span> Pour Aller Encore Plus
Loin</h3>
<p>Les vrais processeurs modernes vont bien au-delà :</p>
<ul>
<li><strong>Superscalaire</strong> : Plusieurs pipelines en
parallèle</li>
<li><strong>Exécution dans le désordre</strong> : Réorganiser les
instructions</li>
<li><strong>Prédiction de branchement</strong> : Deviner si un
branchement sera pris</li>
<li><strong>Cache</strong> : Mémoire ultra-rapide proche du CPU</li>
</ul>
<p>Mais ces concepts dépassent le cadre de ce livre. Le pipeline à 5
étages reste la base sur laquelle tout le reste est construit !</p>
<hr />
<h2 data-number="7.10" id="le-lien-avec-la-suite-1"><span class="header-section-number">7.10</span> Le Lien avec la Suite</h2>
<p><strong>Félicitations !</strong> Vous venez de construire un
ordinateur complet.</p>
<p>Ce CPU que vous avez construit peut maintenant : - Exécuter des
programmes écrits en assembleur (Chapitre 6) - Exécuter des programmes
compilés depuis C32 (Chapitre 7-8) - Faire tourner un système
d’exploitation minimal (Chapitre 9)</p>
<h3 data-number="7.10.1" id="le-parcours-complet"><span class="header-section-number">7.10.1</span> Le parcours complet</h3>
<pre><code>Chapitre 1-5 : MATÉRIEL
    NAND → Portes → ALU → Mémoire → CPU
                              ↓
Chapitre 6-9 : LOGICIEL
    Assembleur → Compilateur → Langage C32 → OS</code></pre>
<p>À partir de maintenant, nous passons du côté
<strong>logiciel</strong>. Le matériel est terminé !</p>
<hr />
<h2 data-number="7.11" id="ce-quil-faut-retenir-4"><span class="header-section-number">7.11</span> Ce qu’il faut retenir</h2>
<ol type="1">
<li><p><strong>Le CPU orchestre tout</strong> : Fetch → Decode → Execute
→ Memory → Writeback</p></li>
<li><p><strong>Le décodeur analyse</strong> : 32 bits → signaux
individuels</p></li>
<li><p><strong>L’unité de contrôle décide</strong> : Quels composants
activer</p></li>
<li><p><strong>Les multiplexeurs routent</strong> : Les données entre
composants</p></li>
<li><p><strong>Les drapeaux permettent les conditions</strong> : NZCV →
CondCheck → ok/pas ok</p></li>
<li><p><strong>Single-cycle = simple</strong> : Tout en un cycle (mais
lent en vrai)</p></li>
</ol>
<p><strong>Prochaine étape</strong> : Au Chapitre 6, nous construirons
l’<strong>Assembleur</strong> — le programme qui traduit le code
assembleur en binaire exécutable par votre CPU.</p>
<hr />
<p><strong>Conseil</strong> : Si vous avez réussi le CPU, vous avez
accompli quelque chose de remarquable. Prenez le temps de savourer :
vous avez construit un ordinateur complet, de la porte NAND au
processeur fonctionnel !</p>
<h1 data-number="8" id="lassembleur"><span class="header-section-number">8</span> L’Assembleur</h1>
<blockquote>
<p>“Traduire, c’est trahir ?” — Pas ici.</p>
</blockquote>
<p>Dans les chapitres précédents, nous avons conçu le matériel capable
d’exécuter des instructions 32 bits. Mais écrire un programme en
hexadécimal (comme <code>0xE2801001</code>) est extrêmement pénible et
source d’erreurs.</p>
<p>L’<strong>Assembleur</strong> est l’outil logiciel qui fait le pont
entre le programmeur et la machine. Il traduit un fichier texte
contenant des mnémoniques lisibles (ex: <code>ADD R1, R1, #1</code>) en
un fichier binaire exécutable par le CPU.</p>
<hr />
<h2 data-number="8.1" id="où-en-sommes-nous-5"><span class="header-section-number">8.1</span> Où en sommes-nous ?</h2>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                     COUCHE 7: Applications                       │
├─────────────────────────────────────────────────────────────────┤
│                  COUCHE 6: Système d&#39;Exploitation                │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 5: Langage de Haut Niveau (C32)           │
├─────────────────────────────────────────────────────────────────┤
│                      COUCHE 4: Compilateur                       │
├─────────────────────────────────────────────────────────────────┤
│  ══════════════► COUCHE 3: Assembleur (A32 ASM) ◄══════════════ │
│               (Mnémoniques → Code machine binaire)               │
│                    (Vous êtes ici !)                             │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 2: Architecture Machine (ISA)             │
├─────────────────────────────────────────────────────────────────┤
│                    COUCHE 1: Logique Matérielle                  │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<p>Nous entrons maintenant dans le monde du <strong>logiciel</strong> !
L’assembleur est le premier programme que nous construisons pour notre
machine.</p>
<hr />
<h2 data-number="8.2" id="le-rôle-de-lassembleur"><span class="header-section-number">8.2</span> Le Rôle de l’Assembleur</h2>
<h3 data-number="8.2.1" id="du-texte-au-binaire"><span class="header-section-number">8.2.1</span> Du texte au binaire</h3>
<pre><code>                    Assembleur
   Code source  ──────────────►  Code machine
   (texte)                       (binaire)

   ADD R1, R2, #10     →     0xE2821010
   B loop              →     0xEAFFFFFE</code></pre>
<h3 data-number="8.2.2" id="les-trois-tâches-de-lassembleur"><span class="header-section-number">8.2.2</span> Les trois tâches de
l’assembleur</h3>
<ol type="1">
<li><p><strong>Analyse (Parsing)</strong> : Lire le code source et
comprendre les instructions, les opérandes, les labels.</p></li>
<li><p><strong>Résolution des Symboles</strong> : Transformer les
étiquettes (labels) comme <code>loop:</code> en adresses
numériques.</p></li>
<li><p><strong>Encodage</strong> : Transformer chaque instruction en son
équivalent binaire de 32 bits selon la spécification de l’ISA.</p></li>
</ol>
<hr />
<h2 data-number="8.3" id="la-stratégie-des-deux-passes"><span class="header-section-number">8.3</span> La Stratégie des Deux
Passes</h2>
<h3 data-number="8.3.1" id="pourquoi-deux-passes"><span class="header-section-number">8.3.1</span> Pourquoi deux passes ?</h3>
<p>Regardez ce code :</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a>    B suite    <span class="co">; Où est &#39;suite&#39; ? On ne le sait pas encore !</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">MOV</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">1</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a><span class="fu">suite:</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">ADD</span> R0<span class="op">,</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">1</span></span></code></pre></div>
<p>À la ligne 1, l’assembleur ne sait pas encore où est
<code>suite</code>. C’est le problème des <strong>références vers
l’avant</strong>.</p>
<h3 data-number="8.3.2" id="passe-1-construction-de-la-table-des-symboles"><span class="header-section-number">8.3.2</span> Passe 1 : Construction de la
Table des Symboles</h3>
<p>L’assembleur parcourt le fichier et note l’adresse de chaque label
:</p>
<pre><code>Adresse 0x0000 : B suite           (4 octets)
Adresse 0x0004 : MOV R0, #1        (4 octets)
Adresse 0x0008 : suite:            ← On note : suite = 0x0008
Adresse 0x0008 : ADD R0, R0, #1</code></pre>
<p><strong>Table des symboles</strong> :
<code>{ &quot;suite&quot;: 0x00000008 }</code></p>
<h3 data-number="8.3.3" id="passe-2-génération-du-code"><span class="header-section-number">8.3.3</span> Passe 2 : Génération du
Code</h3>
<p>L’assembleur reparcourt le fichier. Quand il voit
<code>B suite</code>, il regarde dans sa table et génère l’offset
correct.</p>
<pre><code>B suite → offset = (0x0008 - 0x0000 - 8) / 4 = -2 → 0xEAFFFFFE</code></pre>
<hr />
<h2 data-number="8.4" id="sections-et-directives"><span class="header-section-number">8.4</span> Sections et Directives</h2>
<h3 data-number="8.4.1" id="les-sections"><span class="header-section-number">8.4.1</span> Les Sections</h3>
<p>Un programme n’est pas fait que d’instructions. Il contient aussi des
données.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Section</th>
<th style="text-align: left;">Contenu</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>.text</code></td>
<td style="text-align: left;">Le code (les instructions) — généralement
en lecture seule</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.data</code></td>
<td style="text-align: left;">Les variables globales initialisées</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.bss</code></td>
<td style="text-align: left;">Les variables globales non initialisées
(mises à zéro)</td>
</tr>
</tbody>
</table>
<h3 data-number="8.4.2" id="les-directives"><span class="header-section-number">8.4.2</span> Les Directives</h3>
<p>Les directives (commençant par <code>.</code>) guident l’assembleur
:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Directive</th>
<th style="text-align: left;">Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>.text</code></td>
<td style="text-align: left;">Début de la section code</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.data</code></td>
<td style="text-align: left;">Début de la section données</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.global _start</code></td>
<td style="text-align: left;">Exporte le symbole
<code>_start</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.word 123</code></td>
<td style="text-align: left;">Réserve 4 octets avec la valeur 123</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.asciz &quot;Hello&quot;</code></td>
<td style="text-align: left;">Chaîne terminée par un zéro</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.align 2</code></td>
<td style="text-align: left;">Aligne sur un multiple de 4 octets</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>.ltorg</code></td>
<td style="text-align: left;">Force l’émission du literal pool</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="8.5" id="exemple-dencodage"><span class="header-section-number">8.5</span> Exemple d’Encodage</h2>
<p>Comment l’assembleur encode-t-il <code>ADD R1, R2, #10</code> ?</p>
<h3 data-number="8.5.1" id="étape-1-identifier-linstruction"><span class="header-section-number">8.5.1</span> Étape 1 : Identifier
l’instruction</h3>
<ul>
<li><strong>Mnémonique</strong> : <code>ADD</code> → opcode = 0011</li>
<li><strong>Registres</strong> : Rd = R1, Rn = R2</li>
<li><strong>Immédiat</strong> : #10</li>
</ul>
<h3 data-number="8.5.2" id="étape-2-déterminer-la-classe"><span class="header-section-number">8.5.2</span> Étape 2 : Déterminer la
classe</h3>
<ul>
<li>Classe <code>001</code> car on utilise un immédiat</li>
</ul>
<h3 data-number="8.5.3" id="étape-3-assembler-les-bits"><span class="header-section-number">8.5.3</span> Étape 3 : Assembler les
bits</h3>
<pre><code> 31-28  27-25  24-21  20   19-16  15-12  11-0
 Cond   Class   Op    S     Rn     Rd    Imm12
 1110   001    0011   0    0010   0001   000000001010

 = 0xE2821010</code></pre>
<hr />
<h2 data-number="8.6" id="la-gestion-des-grandes-constantes"><span class="header-section-number">8.6</span> La Gestion des Grandes
Constantes</h2>
<h3 data-number="8.6.1" id="le-problème-1"><span class="header-section-number">8.6.1</span> Le problème</h3>
<p>Une instruction fait 32 bits. Un immédiat fait 12 bits maximum.
Comment charger <code>0xDEADBEEF</code> (32 bits) dans un registre ?</p>
<h3 data-number="8.6.2" id="la-solution-le-literal-pool"><span class="header-section-number">8.6.2</span> La solution : Le Literal
Pool</h3>
<p>L’assembleur offre une syntaxe magique :
<code>LDR R0, =0xDEADBEEF</code></p>
<p>Ce n’est <strong>pas</strong> une vraie instruction LDR — c’est une
<strong>pseudo-instruction</strong> que l’assembleur transforme :</p>
<ol type="1">
<li>La valeur <code>0xDEADBEEF</code> est stockée dans le
<strong>literal pool</strong> (une zone de données après le code)</li>
<li>L’instruction est remplacée par <code>LDR R0, [PC, #offset]</code>
qui va chercher la valeur</li>
</ol>
<div class="sourceCode" id="cb121"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Code source</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>    LDR R0<span class="op">,</span> <span class="op">=</span><span class="bn">0xDEADBEEF</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="co">; Ce que l&#39;assembleur génère</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>    LDR R0<span class="op">,</span> <span class="op">[</span>PC<span class="op">,</span> <span class="op">#</span><span class="dv">8</span><span class="op">]</span>    <span class="co">; Va chercher la valeur 8 octets plus loin</span></span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a>    ...</span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a><span class="fu">literal_pool:</span></span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>    .<span class="dt">word</span> <span class="bn">0xDEADBEEF</span>    <span class="co">; La valeur est stockée ici</span></span></code></pre></div>
<hr />
<h2 data-number="8.7" id="exercices-pratiques-5"><span class="header-section-number">8.7</span> Exercices Pratiques</h2>
<h3 data-number="8.7.1" id="exercices-sur-le-simulateur-web-5"><span class="header-section-number">8.7.1</span> Exercices sur le Simulateur
Web</h3>
<p>Tous les exercices de la section <strong>A32 Assembly</strong> du
simulateur web vous font pratiquer l’écriture d’assembleur. L’assembleur
intégré traduit votre code en binaire automatiquement.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Catégorie</th>
<th style="text-align: left;">Exercices</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Basique</td>
<td style="text-align: left;">Hello World, Addition, Soustraction,
Logique</td>
</tr>
<tr class="even">
<td style="text-align: left;">Contrôle</td>
<td style="text-align: left;">Conditions, Boucles, Multiplication,
Fibonacci</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Mémoire</td>
<td style="text-align: left;">Tableaux, Maximum Tableau, Fonctions</td>
</tr>
<tr class="even">
<td style="text-align: left;">Graphique</td>
<td style="text-align: left;">Pixel, Ligne, Rectangle, Damier</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Avancé</td>
<td style="text-align: left;">Recherche Dichotomique, Dégradé</td>
</tr>
</tbody>
</table>
<h3 data-number="8.7.2" id="exercice-manuel-encodage"><span class="header-section-number">8.7.2</span> Exercice manuel :
Encodage</h3>
<p>Traduisez ces instructions en binaire (32 bits) :</p>
<ol type="1">
<li><code>MOV R0, #5</code></li>
<li><code>SUB R1, R1, #1</code></li>
<li><code>B -2</code> (saut de 2 instructions en arrière)</li>
</ol>
<h3 data-number="8.7.3" id="exercice-table-des-symboles"><span class="header-section-number">8.7.3</span> Exercice : Table des
symboles</h3>
<p>Calculez l’adresse de chaque label :</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>.text</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a><span class="fu">start:</span></span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">MOV</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">0</span></span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a><span class="fu">loop:</span></span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">CMP</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">10</span></span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>    BEQ end</span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">ADD</span> R0<span class="op">,</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">1</span></span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>    B loop</span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a><span class="fu">end:</span></span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>    HALT</span></code></pre></div>
<h3 data-number="8.7.4" id="utilisation-de-loutil-cli"><span class="header-section-number">8.7.4</span> Utilisation de l’outil
CLI</h3>
<div class="sourceCode" id="cb123"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Assembler un fichier</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> a32_cli <span class="at">--</span> assemble mon_prog.s <span class="at">-o</span> mon_prog.bin</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Examiner le binaire généré</span></span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a><span class="fu">hexdump</span> <span class="at">-C</span> mon_prog.bin</span></code></pre></div>
<hr />
<h2 data-number="8.8" id="ce-quil-faut-retenir-5"><span class="header-section-number">8.8</span> Ce qu’il faut retenir</h2>
<ol type="1">
<li><p><strong>L’assembleur traduit</strong> : Texte lisible → Binaire
exécutable</p></li>
<li><p><strong>Deux passes</strong> : D’abord collecter les symboles,
puis générer le code</p></li>
<li><p><strong>Les directives organisent</strong> : <code>.text</code>,
<code>.data</code>, <code>.word</code>, <code>.asciz</code></p></li>
<li><p><strong>Le literal pool résout</strong> : Les constantes 32 bits
via <code>LDR R0, =value</code></p></li>
<li><p><strong>Un symbole = une adresse</strong> : Les labels deviennent
des nombres</p></li>
</ol>
<p><strong>Prochaine étape</strong> : Au Chapitre 7, nous construirons
un <strong>Compilateur</strong> qui traduit du code C32 en assembleur.
C’est l’étape suivante vers l’abstraction !</p>
<hr />
<p><strong>Conseil</strong> : Faites beaucoup d’exercices en assembleur.
Plus vous serez à l’aise avec l’assembleur, mieux vous comprendrez ce
que fait le compilateur.</p>
<h1 data-number="9" id="construction-du-compilateur"><span class="header-section-number">9</span> Construction du Compilateur</h1>
<blockquote>
<p>“Pour comprendre la récursivité, il faut d’abord comprendre la
récursivité.”</p>
</blockquote>
<p>Dans ce chapitre, nous allons construire le <strong>pont</strong>
entre le langage de haut niveau (C32) et l’assembleur (A32). Le
compilateur est l’outil qui permet aux humains d’écrire du code lisible
tout en profitant de la vitesse du code machine.</p>
<hr />
<h2 data-number="9.1" id="où-en-sommes-nous-6"><span class="header-section-number">9.1</span> Où en sommes-nous ?</h2>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                     COUCHE 7: Applications                       │
├─────────────────────────────────────────────────────────────────┤
│                  COUCHE 6: Système d&#39;Exploitation                │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 5: Langage de Haut Niveau (C32)           │
├─────────────────────────────────────────────────────────────────┤
│  ══════════════► COUCHE 4: Compilateur ◄════════════════════════│
│               (Transforme C32 → Assembleur A32)                  │
│                    (Vous êtes ici !)                             │
├─────────────────────────────────────────────────────────────────┤
│                   COUCHE 3: Assembleur (A32 ASM)                 │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 2: Architecture Machine (ISA)             │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<p>Le compilateur est le <strong>traducteur automatique</strong> qui
transforme du code lisible par les humains en code exécutable par la
machine.</p>
<hr />
<h2 data-number="9.2" id="le-rôle-du-compilateur"><span class="header-section-number">9.2</span> Le Rôle du Compilateur</h2>
<h3 data-number="9.2.1" id="pourquoi-un-compilateur"><span class="header-section-number">9.2.1</span> Pourquoi un compilateur
?</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Assembleur</th>
<th style="text-align: left;">C32 (haut niveau)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ADD R0, R0, #1</code></td>
<td style="text-align: left;"><code>x = x + 1;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Gestion manuelle des registres</td>
<td style="text-align: left;">Variables nommées</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Sauts et labels</td>
<td style="text-align: left;"><code>if</code>, <code>while</code>,
<code>for</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Appels manuels avec conventions</td>
<td style="text-align: left;"><code>return fonction();</code></td>
</tr>
</tbody>
</table>
<p>Le compilateur traduit le second en premier, automatiquement.</p>
<h3 data-number="9.2.2" id="les-étapes-de-compilation"><span class="header-section-number">9.2.2</span> Les étapes de
compilation</h3>
<pre><code>Code C32          Analyse           Génération
  (texte)    →    (AST)      →     Assembleur
                                       │
                                       ▼
                                    Binaire</code></pre>
<ol type="1">
<li><strong>Analyse lexicale</strong> : Découpe le texte en tokens
(<code>int</code>, <code>x</code>, <code>=</code>, <code>5</code>,
<code>;</code>)</li>
<li><strong>Analyse syntaxique</strong> : Construit un arbre (AST)
représentant la structure</li>
<li><strong>Analyse sémantique</strong> : Vérifie les types, les
portées, etc.</li>
<li><strong>Génération de code</strong> : Produit l’assembleur
équivalent</li>
</ol>
<hr />
<h2 data-number="9.3" id="les-phases-du-compilateur"><span class="header-section-number">9.3</span> Les Phases du Compilateur</h2>
<h3 data-number="9.3.1" id="phase-1-lexer-analyse-lexicale"><span class="header-section-number">9.3.1</span> Phase 1 : Lexer (Analyse
Lexicale)</h3>
<p>Le lexer transforme le flux de caractères en tokens :</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span></code></pre></div>
<p>Devient :</p>
<pre><code>[INT] [ID:&quot;x&quot;] [EQUAL] [NUMBER:5] [SEMICOLON]</code></pre>
<h3 data-number="9.3.2" id="phase-2-parser-analyse-syntaxique"><span class="header-section-number">9.3.2</span> Phase 2 : Parser (Analyse
Syntaxique)</h3>
<p>Le parser construit un <strong>AST</strong> (Abstract Syntax Tree)
:</p>
<pre><code>           Declaration
              /    \
           Type    Assignment
            |        /    \
          &quot;int&quot;  &quot;x&quot;    Number
                         |
                         5</code></pre>
<h3 data-number="9.3.3" id="phase-3-génération-de-code"><span class="header-section-number">9.3.3</span> Phase 3 : Génération de
Code</h3>
<p>Le générateur parcourt l’AST et produit l’assembleur :</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="co">; int x = 5;</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">5</span></span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a><span class="bu">STR</span> R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">,</span> <span class="op">#-</span><span class="dv">4</span><span class="op">]!</span>   <span class="co">; Push x sur la pile</span></span></code></pre></div>
<hr />
<h2 data-number="9.4" id="compilation-des-structures-de-contrôle"><span class="header-section-number">9.4</span> Compilation des Structures de
Contrôle</h2>
<h3 data-number="9.4.1" id="variables-locales"><span class="header-section-number">9.4.1</span> Variables locales</h3>
<p>Les variables locales vivent sur la <strong>pile</strong> :</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> a <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> b <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb131"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Prologue</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="bu">SUB</span> <span class="kw">SP</span><span class="op">,</span> <span class="kw">SP</span><span class="op">,</span> <span class="op">#</span><span class="dv">8</span>       <span class="co">; Réserve 8 octets pour a et b</span></span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a><span class="co">; a = 10</span></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">10</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a><span class="bu">STR</span> R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">,</span> <span class="op">#</span><span class="dv">4</span><span class="op">]</span>     <span class="co">; a est à SP+4</span></span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a><span class="co">; b = 20</span></span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">20</span></span>
<span id="cb131-10"><a href="#cb131-10" aria-hidden="true" tabindex="-1"></a><span class="bu">STR</span> R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">,</span> <span class="op">#</span><span class="dv">0</span><span class="op">]</span>     <span class="co">; b est à SP+0</span></span></code></pre></div>
<h3 data-number="9.4.2" id="expressions"><span class="header-section-number">9.4.2</span> Expressions</h3>
<p>Pour <code>a + b * 2</code> :</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="co">; Évaluation de b * 2</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>LDR R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">,</span> <span class="op">#</span><span class="dv">0</span><span class="op">]</span>     <span class="co">; R0 = b</span></span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a><span class="bu">MOV</span> R1<span class="op">,</span> <span class="op">#</span><span class="dv">2</span></span>
<span id="cb132-4"><a href="#cb132-4" aria-hidden="true" tabindex="-1"></a><span class="bu">MUL</span> R0<span class="op">,</span> R0<span class="op">,</span> R1       <span class="co">; R0 = b * 2</span></span>
<span id="cb132-5"><a href="#cb132-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb132-6"><a href="#cb132-6" aria-hidden="true" tabindex="-1"></a><span class="co">; Évaluation de a + (b * 2)</span></span>
<span id="cb132-7"><a href="#cb132-7" aria-hidden="true" tabindex="-1"></a>LDR R1<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">,</span> <span class="op">#</span><span class="dv">4</span><span class="op">]</span>     <span class="co">; R1 = a</span></span>
<span id="cb132-8"><a href="#cb132-8" aria-hidden="true" tabindex="-1"></a><span class="bu">ADD</span> R0<span class="op">,</span> R1<span class="op">,</span> R0       <span class="co">; R0 = a + b*2</span></span></code></pre></div>
<h3 data-number="9.4.3" id="if-else"><span class="header-section-number">9.4.3</span> If / Else</h3>
<div class="sourceCode" id="cb133"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>x <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>    y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb134"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a>    LDR R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">,</span> <span class="op">#</span>x_offset<span class="op">]</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">CMP</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">0</span></span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>    BLE else_label</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Then branch</span></span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">MOV</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">1</span></span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">STR</span> R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">,</span> <span class="op">#</span>y_offset<span class="op">]</span></span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a>    B endif_label</span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a><span class="fu">else_label:</span></span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Else branch</span></span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">MOV</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">0</span></span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">STR</span> R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">,</span> <span class="op">#</span>y_offset<span class="op">]</span></span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a><span class="fu">endif_label:</span></span></code></pre></div>
<h3 data-number="9.4.4" id="boucle-while"><span class="header-section-number">9.4.4</span> Boucle While</h3>
<div class="sourceCode" id="cb135"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>    i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb136"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="fu">while_start:</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>    LDR R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">,</span> <span class="op">#</span>i_offset<span class="op">]</span></span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">CMP</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">10</span></span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>    BGE while_end</span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Corps de la boucle</span></span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">ADD</span> R0<span class="op">,</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">1</span></span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">STR</span> R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">,</span> <span class="op">#</span>i_offset<span class="op">]</span></span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-10"><a href="#cb136-10" aria-hidden="true" tabindex="-1"></a>    B while_start</span>
<span id="cb136-11"><a href="#cb136-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-12"><a href="#cb136-12" aria-hidden="true" tabindex="-1"></a><span class="fu">while_end:</span></span></code></pre></div>
<h3 data-number="9.4.5" id="boucle-for"><span class="header-section-number">9.4.5</span> Boucle For</h3>
<p><code>for (init; cond; incr) { body }</code> est équivalent à :</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a>init<span class="op">;</span></span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>cond<span class="op">)</span> <span class="op">{</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>    body<span class="op">;</span></span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a>    incr<span class="op">;</span></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h2 data-number="9.5" id="compilation-des-fonctions"><span class="header-section-number">9.5</span> Compilation des Fonctions</h2>
<h3 data-number="9.5.1" id="convention-dappel"><span class="header-section-number">9.5.1</span> Convention d’appel</h3>
<p>Comment passe-t-on les arguments ? Comment retourne-t-on une valeur
?</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Registre</th>
<th style="text-align: left;">Rôle</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">R0-R3</td>
<td style="text-align: left;">Arguments 1-4, valeur de retour en R0</td>
</tr>
<tr class="even">
<td style="text-align: left;">R4-R11</td>
<td style="text-align: left;">Sauvegardés par l’appelé
(callee-saved)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">R13 (SP)</td>
<td style="text-align: left;">Pointeur de pile</td>
</tr>
<tr class="even">
<td style="text-align: left;">R14 (LR)</td>
<td style="text-align: left;">Adresse de retour</td>
</tr>
</tbody>
</table>
<h3 data-number="9.5.2" id="prologue-et-épilogue"><span class="header-section-number">9.5.2</span> Prologue et Épilogue</h3>
<div class="sourceCode" id="cb138"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb139"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="fu">add:</span></span>
<span id="cb139-2"><a href="#cb139-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Prologue</span></span>
<span id="cb139-3"><a href="#cb139-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">SUB</span> <span class="kw">SP</span><span class="op">,</span> <span class="kw">SP</span><span class="op">,</span> <span class="op">#</span><span class="dv">4</span>       <span class="co">; Place pour LR</span></span>
<span id="cb139-4"><a href="#cb139-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">STR</span> LR<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">]</span>         <span class="co">; Sauvegarde LR</span></span>
<span id="cb139-5"><a href="#cb139-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-6"><a href="#cb139-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Corps : a est dans R0, b dans R1</span></span>
<span id="cb139-7"><a href="#cb139-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">ADD</span> R0<span class="op">,</span> R0<span class="op">,</span> R1       <span class="co">; Résultat dans R0</span></span>
<span id="cb139-8"><a href="#cb139-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb139-9"><a href="#cb139-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">; Épilogue</span></span>
<span id="cb139-10"><a href="#cb139-10" aria-hidden="true" tabindex="-1"></a>    LDR LR<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">]</span>         <span class="co">; Restaure LR</span></span>
<span id="cb139-11"><a href="#cb139-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">ADD</span> <span class="kw">SP</span><span class="op">,</span> <span class="kw">SP</span><span class="op">,</span> <span class="op">#</span><span class="dv">4</span></span>
<span id="cb139-12"><a href="#cb139-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">MOV</span> PC<span class="op">,</span> LR           <span class="co">; Retour</span></span></code></pre></div>
<h3 data-number="9.5.3" id="appel-de-fonction"><span class="header-section-number">9.5.3</span> Appel de fonction</h3>
<div class="sourceCode" id="cb140"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> add<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span></code></pre></div>
<div class="sourceCode" id="cb141"><pre class="sourceCode asm"><code class="sourceCode fasm"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a>    <span class="bu">MOV</span> R0<span class="op">,</span> <span class="op">#</span><span class="dv">5</span>           <span class="co">; Premier argument</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">MOV</span> R1<span class="op">,</span> <span class="op">#</span><span class="dv">3</span>           <span class="co">; Deuxième argument</span></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a>    BL add               <span class="co">; Appel (sauve PC+4 dans LR)</span></span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">STR</span> R0<span class="op">,</span> <span class="op">[</span><span class="kw">SP</span><span class="op">,</span> <span class="op">#</span>result_offset<span class="op">]</span>  <span class="co">; Sauve le résultat</span></span></code></pre></div>
<hr />
<h2 data-number="9.6" id="le-compilateur-c32"><span class="header-section-number">9.6</span> Le Compilateur C32</h2>
<p>Le compilateur C32 du projet Codex (<code>c32_cli</code>) implémente
toutes ces transformations.</p>
<h3 data-number="9.6.1" id="utilisation"><span class="header-section-number">9.6.1</span> Utilisation</h3>
<div class="sourceCode" id="cb142"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compiler un fichier C32 en assembleur</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> c32_cli <span class="at">--</span> mon_fichier.c <span class="at">-o</span> mon_fichier.s</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb142-4"><a href="#cb142-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Compiler directement en binaire</span></span>
<span id="cb142-5"><a href="#cb142-5" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> c32_cli <span class="at">--</span> mon_fichier.c <span class="at">-o</span> mon_fichier.bin</span></code></pre></div>
<h3 data-number="9.6.2" id="exemple-complet"><span class="header-section-number">9.6.2</span> Exemple complet</h3>
<div class="sourceCode" id="cb143"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="co">// fibonacci.c</span></span>
<span id="cb143-2"><a href="#cb143-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fib<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb143-3"><a href="#cb143-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb143-4"><a href="#cb143-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fib<span class="op">(</span>n<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">+</span> fib<span class="op">(</span>n<span class="op">-</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb143-5"><a href="#cb143-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb143-6"><a href="#cb143-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb143-7"><a href="#cb143-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb143-8"><a href="#cb143-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fib<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb143-9"><a href="#cb143-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Produit de l’assembleur avec : - Gestion automatique de la pile -
Appels récursifs - Sauvegarde/restauration des registres</p>
<hr />
<h2 data-number="9.7" id="construisez-votre-propre-compilateur"><span class="header-section-number">9.7</span> Construisez Votre Propre
Compilateur !</h2>
<p>Le simulateur web contient une section <strong>Compilateur:
Construction</strong> avec <strong>18 exercices progressifs</strong>
organisés en 7 phases. Vous construirez un mini-compilateur qui génère
du vrai code assembleur A32.</p>
<h3 data-number="9.7.1" id="phase-1-lexer-analyse-lexicale-1"><span class="header-section-number">9.7.1</span> Phase 1 : Lexer (Analyse
Lexicale)</h3>
<p>Le lexer transforme le texte en tokens.</p>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1.1 Reconnaître un Chiffre</td>
<td style="text-align: left;">Implémenter <code>is_digit(c)</code> pour
détecter ‘0’-‘9’</td>
</tr>
<tr class="even">
<td style="text-align: left;">1.2 Lire un Nombre</td>
<td style="text-align: left;">Parser un entier depuis une chaîne</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1.3 Compter les Tokens</td>
<td style="text-align: left;">Compter les tokens dans
<code>&quot;12 + 34 * 5&quot;</code></td>
</tr>
</tbody>
</table>
<h3 data-number="9.7.2" id="phase-2-parser-analyse-syntaxique-1"><span class="header-section-number">9.7.2</span> Phase 2 : Parser (Analyse
Syntaxique)</h3>
<p>Le parser construit une représentation structurée et évalue les
expressions.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">2.1 Précédence des Opérateurs</td>
<td style="text-align: left;">Déterminer la priorité (<code>*</code>
&gt; <code>+</code>)</td>
</tr>
<tr class="even">
<td style="text-align: left;">2.2 Évaluer une Opération</td>
<td style="text-align: left;">Évaluer <code>3 + 4</code> ou
<code>6 * 7</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">2.3 Parser avec Précédence</td>
<td style="text-align: left;">Descente récursive pour
<code>2 + 3 * 4</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">2.4 Parenthèses</td>
<td style="text-align: left;">Supporter <code>(2 + 3) * 4</code></td>
</tr>
</tbody>
</table>
<h3 data-number="9.7.3" id="phase-3-émission-asm-génération-de-code"><span class="header-section-number">9.7.3</span> Phase 3 : Émission ASM
(Génération de Code)</h3>
<p>Générer des instructions A32 sous forme de chaînes.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">3.1 Générer MOV</td>
<td style="text-align: left;">Produire <code>&quot;MOV R0, #42&quot;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">3.2 Opération Binaire</td>
<td style="text-align: left;">Mapper <code>+</code> → <code>ADD</code>,
<code>*</code> → <code>MUL</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">3.3 Comparaison</td>
<td style="text-align: left;">Générer <code>CMP</code> et codes de
condition</td>
</tr>
</tbody>
</table>
<h3 data-number="9.7.4" id="phase-4-codegen-expressions"><span class="header-section-number">9.7.4</span> Phase 4 : CodeGen
Expressions</h3>
<p>Générer du code A32 complet pour des expressions.</p>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">4.1 Constante → A32</td>
<td style="text-align: left;">Générer code pour charger une
constante</td>
</tr>
<tr class="even">
<td style="text-align: left;">4.2 Addition → A32</td>
<td style="text-align: left;"><code>a + b</code> →
<code>MOV R0, #a / MOV R1, #b / ADD R0, R0, R1</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">4.3 Expression → A32</td>
<td style="text-align: left;">Expression complète avec précédence</td>
</tr>
</tbody>
</table>
<h3 data-number="9.7.5" id="phase-5-structures-de-contrôle"><span class="header-section-number">9.7.5</span> Phase 5 : Structures de
Contrôle</h3>
<p>Générer du code pour <code>if/else</code> et <code>while</code>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">5.1 If/Else → A32</td>
<td style="text-align: left;">Générer les sauts conditionnels et
labels</td>
</tr>
<tr class="even">
<td style="text-align: left;">5.2 While → A32</td>
<td style="text-align: left;">Générer les boucles avec labels</td>
</tr>
</tbody>
</table>
<h3 data-number="9.7.6" id="phase-6-fonctions"><span class="header-section-number">9.7.6</span> Phase 6 : Fonctions</h3>
<p>Gérer les appels de fonction et la pile.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">6.1 Prologue/Épilogue</td>
<td style="text-align: left;">Sauvegarder LR, réserver la pile</td>
</tr>
<tr class="even">
<td style="text-align: left;">6.2 Appel de Fonction</td>
<td style="text-align: left;">Passer les arguments, appeler avec BL</td>
</tr>
</tbody>
</table>
<h3 data-number="9.7.7" id="phase-7-projet-final"><span class="header-section-number">9.7.7</span> Phase 7 : Projet Final</h3>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">7.1 Mini-Compilateur Complet</td>
<td style="text-align: left;">Compiler une expression en A32
exécutable</td>
</tr>
</tbody>
</table>
<p>Le projet final combine toutes les phases : lexer → parser → codegen
pour produire du code assembleur A32 fonctionnel.</p>
<h3 data-number="9.7.8" id="techniques-clés"><span class="header-section-number">9.7.8</span> Techniques Clés</h3>
<p>Ces exercices utilisent la technique de <strong>descente
récursive</strong> : - <code>parse_expr()</code> gère <code>+</code> et
<code>-</code> (basse priorité) - <code>parse_term()</code> gère
<code>*</code> et <code>/</code> (haute priorité) -
<code>parse_factor()</code> gère les nombres et les parenthèses</p>
<hr />
<h2 data-number="9.8" id="exercices-pratiques-6"><span class="header-section-number">9.8</span> Exercices Pratiques</h2>
<h3 data-number="9.8.1" id="exercices-sur-le-simulateur-web-6"><span class="header-section-number">9.8.1</span> Exercices sur le Simulateur
Web</h3>
<p>La section <strong>C32</strong> du simulateur web vous permet de
compiler et exécuter du C32.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Catégorie</th>
<th style="text-align: left;">Exercices</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Bases</td>
<td style="text-align: left;">Variables, Expressions, Modulo,
Incrémentation</td>
</tr>
<tr class="even">
<td style="text-align: left;">Contrôle</td>
<td style="text-align: left;">Conditions, Else-If, Maximum de 3</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Boucles</td>
<td style="text-align: left;">For, While, Imbriquées,
Multiplication</td>
</tr>
<tr class="even">
<td style="text-align: left;">Fonctions</td>
<td style="text-align: left;">Appels, Paramètres, Valeur Absolue,
Min/Max</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Tableaux</td>
<td style="text-align: left;">Accès, Maximum, Comptage</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pointeurs</td>
<td style="text-align: left;">Adresses, Swap, Tableaux via
pointeurs</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Récursion</td>
<td style="text-align: left;">Factorielle, Fibonacci, PGCD</td>
</tr>
<tr class="even">
<td style="text-align: left;">Algorithmes</td>
<td style="text-align: left;">Tri à Bulles, Recherche Binaire</td>
</tr>
</tbody>
</table>
<h3 data-number="9.8.2" id="exercice-traduire-manuellement"><span class="header-section-number">9.8.2</span> Exercice : Traduire
manuellement</h3>
<p>Traduisez ce code C32 en assembleur à la main :</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> <span class="dv">10</span><span class="op">;</span> i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">=</span> sum <span class="op">+</span> i<span class="op">;</span></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Comparez avec la sortie du compilateur !</p>
<hr />
<h2 data-number="9.9" id="ce-quil-faut-retenir-6"><span class="header-section-number">9.9</span> Ce qu’il faut retenir</h2>
<ol type="1">
<li><p><strong>Le compilateur traduit</strong> : C32 (lisible) →
Assembleur (exécutable)</p></li>
<li><p><strong>Trois phases</strong> : Lexer → Parser → Générateur de
code</p></li>
<li><p><strong>Les variables locales vivent sur la pile</strong> : Accès
via <code>[SP, #offset]</code></p></li>
<li><p><strong>Les structures de contrôle deviennent des sauts</strong>
: <code>if</code> → <code>CMP</code> + <code>B</code></p></li>
<li><p><strong>Les fonctions suivent une convention</strong> : Arguments
en R0-R3, retour en R0</p></li>
</ol>
<p><strong>Prochaine étape</strong> : Au Chapitre 8, nous explorerons le
langage C32 en détail — sa syntaxe, ses types, et ses possibilités.</p>
<hr />
<p><strong>Conseil</strong> : Pour vraiment comprendre le compilateur,
écrivez du C32 et regardez l’assembleur généré. Cherchez à prédire ce
que le compilateur va produire !</p>
<h1 data-number="10" id="langage-de-haut-niveau-c32"><span class="header-section-number">10</span> Langage de Haut Niveau
(C32)</h1>
<blockquote>
<p>“Le logiciel est l’esprit qui anime la machine.”</p>
</blockquote>
<p>Jusqu’à présent, nous avons construit le matériel et appris à lui
parler en assembleur. Mais écrire des applications complexes en
assembleur est laborieux. C’est ici qu’intervient le
<strong>C32</strong> — un langage de haut niveau qui vous permet de vous
concentrer sur la <strong>logique</strong> de votre programme.</p>
<hr />
<h2 data-number="10.1" id="où-en-sommes-nous-7"><span class="header-section-number">10.1</span> Où en sommes-nous ?</h2>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                     COUCHE 7: Applications                       │
├─────────────────────────────────────────────────────────────────┤
│                  COUCHE 6: Système d&#39;Exploitation                │
├─────────────────────────────────────────────────────────────────┤
│  ══════════════► COUCHE 5: Langage de Haut Niveau (C32) ◄══════ │
│                    (Variables, fonctions, boucles)               │
│                    (Vous êtes ici !)                             │
├─────────────────────────────────────────────────────────────────┤
│                      COUCHE 4: Compilateur                       │
├─────────────────────────────────────────────────────────────────┤
│                   COUCHE 3: Assembleur (A32 ASM)                 │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 2: Architecture Machine (ISA)             │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<p>Le C32 est un sous-ensemble du langage C. Si vous connaissez le C, le
Java ou le C++, vous vous sentirez chez vous.</p>
<hr />
<h2 data-number="10.2" id="pourquoi-un-langage-de-haut-niveau"><span class="header-section-number">10.2</span> Pourquoi un Langage de Haut
Niveau ?</h2>
<h3 data-number="10.2.1" id="le-problème-de-lassembleur"><span class="header-section-number">10.2.1</span> Le problème de
l’assembleur</h3>
<pre><code>Assembleur                           C32
───────────                          ───
MOV R0, #0                          int sum = 0;
MOV R1, #1                          for (int i = 1; i &lt;= 10; i = i + 1) {
loop:                                   sum = sum + i;
  CMP R1, #10                       }
  BGT done
  ADD R0, R0, R1
  ADD R1, R1, #1
  B loop
done:</code></pre>
<p>Le C32 est : - <strong>Plus lisible</strong> : Variables nommées,
structures de contrôle - <strong>Plus maintenable</strong> : Moins de
code, moins de bugs - <strong>Portable</strong> : Le même code peut
cibler différentes architectures</p>
<h3 data-number="10.2.2" id="labstraction"><span class="header-section-number">10.2.2</span> L’abstraction</h3>
<pre><code>[ Pensée Humaine ]  →  &quot;Calculer la moyenne&quot;
        ↓
[ Langage C32 ]     →  sum = sum + tab[i];
        ↓
[ Assembleur A32 ]  →  LDR R0, [R1, R2]; ADD R3, R3, R0...
        ↓
[ Code Machine ]    →  0xE0833000...</code></pre>
<hr />
<h2 data-number="10.3" id="spécification-du-langage-c32"><span class="header-section-number">10.3</span> Spécification du Langage
C32</h2>
<h3 data-number="10.3.1" id="les-types-de-données"><span class="header-section-number">10.3.1</span> Les Types de Données</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Taille</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;">32 bits</td>
<td style="text-align: left;">Entier signé (complément à 2)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>uint</code></td>
<td style="text-align: left;">32 bits</td>
<td style="text-align: left;">Entier non-signé</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>char</code></td>
<td style="text-align: left;">8 bits</td>
<td style="text-align: left;">Caractère ASCII</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bool</code></td>
<td style="text-align: left;">1 bit</td>
<td style="text-align: left;"><code>true</code> ou
<code>false</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>void</code></td>
<td style="text-align: left;">—</td>
<td style="text-align: left;">Pour les fonctions sans retour</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>type*</code></td>
<td style="text-align: left;">32 bits</td>
<td style="text-align: left;">Pointeur (adresse mémoire)</td>
</tr>
</tbody>
</table>
<h3 data-number="10.3.2" id="variables"><span class="header-section-number">10.3.2</span> Variables</h3>
<div class="sourceCode" id="cb148"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>           <span class="co">// Variable globale ou locale</span></span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> tab<span class="op">[</span><span class="dv">10</span><span class="op">];</span>          <span class="co">// Tableau de 10 entiers</span></span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span>          <span class="co">// Pointeur vers x</span></span></code></pre></div>
<h3 data-number="10.3.3" id="portée-des-variables"><span class="header-section-number">10.3.3</span> Portée des variables</h3>
<ul>
<li><strong>Globales</strong> : Déclarées hors des fonctions,
accessibles partout</li>
<li><strong>Locales</strong> : Déclarées dans une fonction, vivent sur
la pile</li>
</ul>
<hr />
<h2 data-number="10.4" id="opérateurs"><span class="header-section-number">10.4</span> Opérateurs</h2>
<h3 data-number="10.4.1" id="arithmétiques"><span class="header-section-number">10.4.1</span> Arithmétiques</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Opérateur</th>
<th style="text-align: left;">Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>+</code></td>
<td style="text-align: left;">Addition</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-</code></td>
<td style="text-align: left;">Soustraction</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>*</code></td>
<td style="text-align: left;">Multiplication</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>/</code></td>
<td style="text-align: left;">Division</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%</code></td>
<td style="text-align: left;">Modulo (reste)</td>
</tr>
</tbody>
</table>
<h3 data-number="10.4.2" id="comparaison"><span class="header-section-number">10.4.2</span> Comparaison</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Opérateur</th>
<th style="text-align: left;">Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>==</code></td>
<td style="text-align: left;">Égal</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>!=</code></td>
<td style="text-align: left;">Différent</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;</code></td>
<td style="text-align: left;">Inférieur</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;</code></td>
<td style="text-align: left;">Supérieur</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;=</code></td>
<td style="text-align: left;">Inférieur ou égal</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;=</code></td>
<td style="text-align: left;">Supérieur ou égal</td>
</tr>
</tbody>
</table>
<h3 data-number="10.4.3" id="logiques"><span class="header-section-number">10.4.3</span> Logiques</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Opérateur</th>
<th style="text-align: left;">Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>&amp;&amp;</code></td>
<td style="text-align: left;">ET logique</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>\|\|</code></td>
<td style="text-align: left;">OU logique</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>!</code></td>
<td style="text-align: left;">NON logique</td>
</tr>
</tbody>
</table>
<h3 data-number="10.4.4" id="binaires"><span class="header-section-number">10.4.4</span> Binaires</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Opérateur</th>
<th style="text-align: left;">Signification</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>&amp;</code></td>
<td style="text-align: left;">ET bit à bit</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>\|</code></td>
<td style="text-align: left;">OU bit à bit</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>^</code></td>
<td style="text-align: left;">XOR bit à bit</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>~</code></td>
<td style="text-align: left;">Inversion</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&lt;&lt;</code></td>
<td style="text-align: left;">Décalage gauche</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&gt;&gt;</code></td>
<td style="text-align: left;">Décalage droite</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="10.5" id="structures-de-contrôle"><span class="header-section-number">10.5</span> Structures de Contrôle</h2>
<h3 data-number="10.5.1" id="if-else-1"><span class="header-section-number">10.5.1</span> If / Else</h3>
<div class="sourceCode" id="cb149"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>score <span class="op">&gt;</span> <span class="dv">100</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>    win<span class="op">();</span></span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>score <span class="op">&gt;</span> <span class="dv">50</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>    try_again<span class="op">();</span></span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a>    game_over<span class="op">();</span></span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="10.5.2" id="while"><span class="header-section-number">10.5.2</span> While</h3>
<div class="sourceCode" id="cb150"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>x <span class="op">&lt;</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="10.5.3" id="for"><span class="header-section-number">10.5.3</span> For</h3>
<div class="sourceCode" id="cb151"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">10</span><span class="op">;</span> i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>    sum <span class="op">=</span> sum <span class="op">+</span> i<span class="op">;</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="10.5.4" id="do-while"><span class="header-section-number">10.5.4</span> Do-While</h3>
<div class="sourceCode" id="cb152"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="op">{</span></span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> x <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span> <span class="cf">while</span> <span class="op">(</span>x <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div>
<hr />
<h2 data-number="10.6" id="fonctions"><span class="header-section-number">10.6</span> Fonctions</h2>
<h3 data-number="10.6.1" id="définition"><span class="header-section-number">10.6.1</span> Définition</h3>
<div class="sourceCode" id="cb153"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> add<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> greet<span class="op">()</span> <span class="op">{</span></span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a>    putchar<span class="op">(</span><span class="ch">&#39;H&#39;</span><span class="op">);</span></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>    putchar<span class="op">(</span><span class="ch">&#39;i&#39;</span><span class="op">);</span></span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="10.6.2" id="appel"><span class="header-section-number">10.6.2</span> Appel</h3>
<div class="sourceCode" id="cb154"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> result <span class="op">=</span> add<span class="op">(</span><span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a>greet<span class="op">();</span></span></code></pre></div>
<h3 data-number="10.6.3" id="récursion"><span class="header-section-number">10.6.3</span> Récursion</h3>
<div class="sourceCode" id="cb155"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> factorial<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n <span class="op">*</span> factorial<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h2 data-number="10.7" id="pointeurs-et-tableaux"><span class="header-section-number">10.7</span> Pointeurs et Tableaux</h2>
<h3 data-number="10.7.1" id="pointeurs"><span class="header-section-number">10.7.1</span> Pointeurs</h3>
<p>Un pointeur contient une <strong>adresse mémoire</strong> :</p>
<div class="sourceCode" id="cb156"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> p <span class="op">=</span> <span class="op">&amp;</span>x<span class="op">;</span>    <span class="co">// p contient l&#39;adresse de x</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>p <span class="op">=</span> <span class="dv">100</span><span class="op">;</span>       <span class="co">// x vaut maintenant 100</span></span></code></pre></div>
<h3 data-number="10.7.2" id="tableaux"><span class="header-section-number">10.7.2</span> Tableaux</h3>
<p>Un tableau est une suite de valeurs consécutives en mémoire :</p>
<div class="sourceCode" id="cb157"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> scores<span class="op">[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>scores<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>scores<span class="op">[</span><span class="dv">4</span><span class="op">]</span> <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span></code></pre></div>
<h3 data-number="10.7.3" id="lien-entre-pointeurs-et-tableaux"><span class="header-section-number">10.7.3</span> Lien entre pointeurs et
tableaux</h3>
<div class="sourceCode" id="cb158"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> tab<span class="op">[</span><span class="dv">10</span><span class="op">];</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">*</span> p <span class="op">=</span> tab<span class="op">;</span>      <span class="co">// Équivalent à &amp;tab[0]</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>p<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>         <span class="co">// Équivalent à tab[3] = 42</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a><span class="op">*(</span>p <span class="op">+</span> <span class="dv">3</span><span class="op">)</span> <span class="op">=</span> <span class="dv">42</span><span class="op">;</span>     <span class="co">// Même chose !</span></span></code></pre></div>
<hr />
<h2 data-number="10.8" id="accès-au-matériel-mmio"><span class="header-section-number">10.8</span> Accès au Matériel (MMIO)</h2>
<h3 data-number="10.8.1" id="lécran"><span class="header-section-number">10.8.1</span> L’écran</h3>
<div class="sourceCode" id="cb159"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="co">// L&#39;écran commence à 0x00400000</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a><span class="co">// 320×240 pixels, 1 bit par pixel</span></span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> set_pixel<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>    uint<span class="op">*</span> screen <span class="op">=</span> <span class="op">(</span>uint<span class="op">*)</span><span class="bn">0x00400000</span><span class="op">;</span></span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> offset <span class="op">=</span> y <span class="op">*</span> <span class="dv">10</span> <span class="op">+</span> <span class="op">(</span>x <span class="op">/</span> <span class="dv">32</span><span class="op">);</span></span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>    uint mask <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="op">(</span><span class="dv">31</span> <span class="op">-</span> <span class="op">(</span>x <span class="op">%</span> <span class="dv">32</span><span class="op">));</span></span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a>    screen<span class="op">[</span>offset<span class="op">]</span> <span class="op">=</span> screen<span class="op">[</span>offset<span class="op">]</span> <span class="op">|</span> mask<span class="op">;</span></span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-11"><a href="#cb159-11" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> clear_screen<span class="op">()</span> <span class="op">{</span></span>
<span id="cb159-12"><a href="#cb159-12" aria-hidden="true" tabindex="-1"></a>    uint<span class="op">*</span> screen <span class="op">=</span> <span class="op">(</span>uint<span class="op">*)</span><span class="bn">0x00400000</span><span class="op">;</span></span>
<span id="cb159-13"><a href="#cb159-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">2400</span><span class="op">;</span> i <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb159-14"><a href="#cb159-14" aria-hidden="true" tabindex="-1"></a>        screen<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb159-15"><a href="#cb159-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb159-16"><a href="#cb159-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="10.8.2" id="le-clavier"><span class="header-section-number">10.8.2</span> Le clavier</h3>
<div class="sourceCode" id="cb160"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Le clavier est à 0x00402600</span></span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> get_key<span class="op">()</span> <span class="op">{</span></span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> keyboard <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">*)</span><span class="bn">0x00402600</span><span class="op">;</span></span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span>keyboard<span class="op">;</span></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> wait_key<span class="op">()</span> <span class="op">{</span></span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>get_key<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Attendre</span></span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h2 data-number="10.9" id="exemple-complet-1"><span class="header-section-number">10.9</span> Exemple Complet</h2>
<div class="sourceCode" id="cb161"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Programme qui dessine un rectangle et attend une touche</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a><span class="kw">extern</span> <span class="dt">void</span> putchar<span class="op">(</span><span class="dt">char</span> c<span class="op">);</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Dessiner un rectangle 10×5 à la position (20, 30)</span></span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a>    uint<span class="op">*</span> screen <span class="op">=</span> <span class="op">(</span>uint<span class="op">*)</span><span class="bn">0x00400000</span><span class="op">;</span></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> y <span class="op">=</span> <span class="dv">30</span><span class="op">;</span> y <span class="op">&lt;</span> <span class="dv">35</span><span class="op">;</span> y <span class="op">=</span> y <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> <span class="dv">20</span><span class="op">;</span> x <span class="op">&lt;</span> <span class="dv">30</span><span class="op">;</span> x <span class="op">=</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> offset <span class="op">=</span> y <span class="op">*</span> <span class="dv">10</span> <span class="op">+</span> <span class="op">(</span>x <span class="op">/</span> <span class="dv">32</span><span class="op">);</span></span>
<span id="cb161-12"><a href="#cb161-12" aria-hidden="true" tabindex="-1"></a>            uint mask <span class="op">=</span> <span class="dv">1</span> <span class="op">&lt;&lt;</span> <span class="op">(</span><span class="dv">31</span> <span class="op">-</span> <span class="op">(</span>x <span class="op">%</span> <span class="dv">32</span><span class="op">));</span></span>
<span id="cb161-13"><a href="#cb161-13" aria-hidden="true" tabindex="-1"></a>            screen<span class="op">[</span>offset<span class="op">]</span> <span class="op">=</span> screen<span class="op">[</span>offset<span class="op">]</span> <span class="op">|</span> mask<span class="op">;</span></span>
<span id="cb161-14"><a href="#cb161-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb161-15"><a href="#cb161-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb161-16"><a href="#cb161-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-17"><a href="#cb161-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Afficher un message</span></span>
<span id="cb161-18"><a href="#cb161-18" aria-hidden="true" tabindex="-1"></a>    putchar<span class="op">(</span><span class="ch">&#39;D&#39;</span><span class="op">);</span></span>
<span id="cb161-19"><a href="#cb161-19" aria-hidden="true" tabindex="-1"></a>    putchar<span class="op">(</span><span class="ch">&#39;o&#39;</span><span class="op">);</span></span>
<span id="cb161-20"><a href="#cb161-20" aria-hidden="true" tabindex="-1"></a>    putchar<span class="op">(</span><span class="ch">&#39;n&#39;</span><span class="op">);</span></span>
<span id="cb161-21"><a href="#cb161-21" aria-hidden="true" tabindex="-1"></a>    putchar<span class="op">(</span><span class="ch">&#39;e&#39;</span><span class="op">);</span></span>
<span id="cb161-22"><a href="#cb161-22" aria-hidden="true" tabindex="-1"></a>    putchar<span class="op">(</span><span class="ch">&#39;!&#39;</span><span class="op">);</span></span>
<span id="cb161-23"><a href="#cb161-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-24"><a href="#cb161-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Attendre une touche</span></span>
<span id="cb161-25"><a href="#cb161-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> kbd <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">*)</span><span class="bn">0x00402600</span><span class="op">;</span></span>
<span id="cb161-26"><a href="#cb161-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(*</span>kbd <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb161-27"><a href="#cb161-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-28"><a href="#cb161-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb161-29"><a href="#cb161-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h2 data-number="10.10" id="exercices-pratiques-7"><span class="header-section-number">10.10</span> Exercices Pratiques</h2>
<h3 data-number="10.10.1" id="exercices-sur-le-simulateur-web-7"><span class="header-section-number">10.10.1</span> Exercices sur le Simulateur
Web</h3>
<p>La section <strong>C32</strong> contient de nombreux exercices
progressifs :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Catégorie</th>
<th style="text-align: left;">Exercices clés</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Bases</strong></td>
<td style="text-align: left;">Variables, Expressions, Modulo</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Contrôle</strong></td>
<td style="text-align: left;">Conditions, Else-If, Opérateurs
Logiques</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Boucles</strong></td>
<td style="text-align: left;">For, While, Imbriquées</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Fonctions</strong></td>
<td style="text-align: left;">Paramètres, Valeur Absolue, Min/Max</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Tableaux</strong></td>
<td style="text-align: left;">Accès, Maximum, Comptage</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Pointeurs</strong></td>
<td style="text-align: left;">Adresses, Swap</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Récursion</strong></td>
<td style="text-align: left;">Factorielle, Fibonacci, PGCD</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Algorithmes</strong></td>
<td style="text-align: left;">Tri à Bulles, Recherche Binaire</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Graphique</strong></td>
<td style="text-align: left;">Pixel, Ligne, Rectangle, Damier</td>
</tr>
</tbody>
</table>
<h3 data-number="10.10.2" id="défis-suggérés"><span class="header-section-number">10.10.2</span> Défis suggérés</h3>
<ol type="1">
<li><p><strong>Hello World</strong> : Affichez votre nom à
l’écran</p></li>
<li><p><strong>Jeu de devinette</strong> : Le programme choisit un
nombre, l’utilisateur devine</p></li>
<li><p><strong>Calculatrice</strong> : Lisez deux nombres et affichez
leur somme</p></li>
</ol>
<hr />
<h2 data-number="10.11" id="les-structures-structs"><span class="header-section-number">10.11</span> Les Structures (Structs)</h2>
<p>Le C32 supporte les structures (structs) pour regrouper plusieurs
variables :</p>
<h3 data-number="10.11.1" id="définition-dune-structure"><span class="header-section-number">10.11.1</span> Définition d’une
structure</h3>
<div class="sourceCode" id="cb162"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">{</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 data-number="10.11.2" id="utilisation-1"><span class="header-section-number">10.11.2</span> Utilisation</h3>
<div class="sourceCode" id="cb163"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point p<span class="op">;</span>     <span class="co">// Déclarer une variable de type struct</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>p<span class="op">.</span>x <span class="op">=</span> <span class="dv">10</span><span class="op">;</span>           <span class="co">// Accéder aux champs avec .</span></span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a>p<span class="op">.</span>y <span class="op">=</span> <span class="dv">20</span><span class="op">;</span></span></code></pre></div>
<h3 data-number="10.11.3" id="pointeur-vers-structure"><span class="header-section-number">10.11.3</span> Pointeur vers
structure</h3>
<div class="sourceCode" id="cb164"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">*</span>ptr <span class="op">=</span> <span class="op">&amp;</span>p<span class="op">;</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">-&gt;</span>x <span class="op">=</span> <span class="dv">30</span><span class="op">;</span>        <span class="co">// Accéder via pointeur avec -&gt;</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a>ptr<span class="op">-&gt;</span>y <span class="op">=</span> <span class="dv">40</span><span class="op">;</span></span></code></pre></div>
<h3 data-number="10.11.4" id="exemple-complet-2"><span class="header-section-number">10.11.4</span> Exemple complet</h3>
<div class="sourceCode" id="cb165"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">{</span> <span class="dt">int</span> x<span class="op">;</span> <span class="dt">int</span> y<span class="op">;</span> <span class="op">};</span></span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> distance_sq<span class="op">(</span><span class="kw">struct</span> Point <span class="op">*</span>p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> p<span class="op">-&gt;</span>x <span class="op">*</span> p<span class="op">-&gt;</span>x <span class="op">+</span> p<span class="op">-&gt;</span>y <span class="op">*</span> p<span class="op">-&gt;</span>y<span class="op">;</span></span>
<span id="cb165-5"><a href="#cb165-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb165-6"><a href="#cb165-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb165-7"><a href="#cb165-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb165-8"><a href="#cb165-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point p<span class="op">;</span></span>
<span id="cb165-9"><a href="#cb165-9" aria-hidden="true" tabindex="-1"></a>    p<span class="op">.</span>x <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb165-10"><a href="#cb165-10" aria-hidden="true" tabindex="-1"></a>    p<span class="op">.</span>y <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb165-11"><a href="#cb165-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> distance_sq<span class="op">(&amp;</span>p<span class="op">);</span>  <span class="co">// Retourne 25</span></span>
<span id="cb165-12"><a href="#cb165-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="10.11.5" id="structures-imbriquées"><span class="header-section-number">10.11.5</span> Structures imbriquées</h3>
<div class="sourceCode" id="cb166"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Point <span class="op">{</span> <span class="dt">int</span> x<span class="op">;</span> <span class="dt">int</span> y<span class="op">;</span> <span class="op">};</span></span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Rectangle <span class="op">{</span></span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Point corner<span class="op">;</span></span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> width<span class="op">;</span></span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> height<span class="op">;</span></span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb166-7"><a href="#cb166-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb166-8"><a href="#cb166-8" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb166-9"><a href="#cb166-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> Rectangle r<span class="op">;</span></span>
<span id="cb166-10"><a href="#cb166-10" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>corner<span class="op">.</span>x <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb166-11"><a href="#cb166-11" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>corner<span class="op">.</span>y <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb166-12"><a href="#cb166-12" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>width <span class="op">=</span> <span class="dv">100</span><span class="op">;</span></span>
<span id="cb166-13"><a href="#cb166-13" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>height <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb166-14"><a href="#cb166-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> r<span class="op">.</span>width <span class="op">*</span> r<span class="op">.</span>height<span class="op">;</span>  <span class="co">// Retourne 5000</span></span>
<span id="cb166-15"><a href="#cb166-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h2 data-number="10.12" id="limitations-du-c32"><span class="header-section-number">10.12</span> Limitations du C32</h2>
<p>Pour rester simple et pédagogique, le C32 a quelques limites :</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Fonctionnalité</th>
<th style="text-align: left;">État</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>struct</code></td>
<td style="text-align: left;">Supporté</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>float</code>,
<code>double</code></td>
<td style="text-align: left;">Non supporté</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>malloc</code>/<code>free</code></td>
<td style="text-align: left;">Via OS uniquement</td>
</tr>
<tr class="even">
<td style="text-align: left;">Chaînes de caractères</td>
<td style="text-align: left;">Basique</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Préprocesseur</td>
<td style="text-align: left;">Minimal</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="10.13" id="ce-quil-faut-retenir-7"><span class="header-section-number">10.13</span> Ce qu’il faut retenir</h2>
<ol type="1">
<li><p><strong>C32 simplifie la programmation</strong> : Variables
nommées, structures de contrôle</p></li>
<li><p><strong>Les types de base</strong> : <code>int</code>,
<code>char</code>, <code>bool</code>, <code>void</code>,
pointeurs</p></li>
<li><p><strong>Pointeurs = adresses</strong> : Accès direct à la
mémoire</p></li>
<li><p><strong>MMIO</strong> : Écran à 0x00400000, clavier à
0x00402600</p></li>
<li><p><strong>Fonctions</strong> : Modularité et réutilisation du
code</p></li>
</ol>
<p><strong>Prochaine étape</strong> : Au Chapitre 9, nous construirons
un <strong>Système d’Exploitation</strong> minimal — gestion mémoire,
graphiques, entrées/sorties.</p>
<hr />
<p><strong>Conseil</strong> : Le C32 est proche du C. Si vous voulez
aller plus loin, apprenez le C — c’est le langage de base de Linux,
Windows, et de presque tous les systèmes embarqués !</p>
<h1 data-number="11" id="système-dexploitation"><span class="header-section-number">11</span> Système d’Exploitation</h1>
<blockquote>
<p>“Un OS est ce qui reste quand on a enlevé tout ce qui est utile.” —
Ken Thompson</p>
</blockquote>
<p>Félicitations ! Vous avez construit le matériel, l’assembleur et le
compilateur. Votre machine Codex est fonctionnelle. Mais pour l’instant,
chaque programmeur doit réinventer la roue : comment dessiner un cercle
? comment lire une chaîne de caractères ?</p>
<p>Dans ce dernier chapitre, nous allons construire une
<strong>Bibliothèque Système</strong> qui simplifie l’accès au
matériel.</p>
<hr />
<h2 data-number="11.1" id="où-en-sommes-nous-8"><span class="header-section-number">11.1</span> Où en sommes-nous ?</h2>
<pre><code>┌─────────────────────────────────────────────────────────────────┐
│                     COUCHE 7: Applications                       │
├─────────────────────────────────────────────────────────────────┤
│  ══════════════► COUCHE 6: Système d&#39;Exploitation ◄════════════ │
│           (Gestion mémoire, Drivers écran/clavier)               │
│                    (Vous êtes ici !)                             │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 5: Langage de Haut Niveau (C32)           │
├─────────────────────────────────────────────────────────────────┤
│                      COUCHE 4: Compilateur                       │
├─────────────────────────────────────────────────────────────────┤
│                   COUCHE 3: Assembleur (A32 ASM)                 │
├─────────────────────────────────────────────────────────────────┤
│                 COUCHE 2: Architecture Machine (ISA)             │
├─────────────────────────────────────────────────────────────────┤
│                    COUCHE 1: Logique Matérielle                  │
└─────────────────────────────────────────────────────────────────┘</code></pre>
<p>C’est le <strong>sommet de la pyramide</strong> logicielle ! L’OS
cache la complexité du matériel et offre des services de haut niveau aux
applications.</p>
<hr />
<h2 data-number="11.2" id="quest-ce-quun-système-dexploitation"><span class="header-section-number">11.2</span> Qu’est-ce qu’un Système
d’Exploitation ?</h2>
<h3 data-number="11.2.1" id="la-hiérarchie-logicielle"><span class="header-section-number">11.2.1</span> La hiérarchie
logicielle</h3>
<pre><code>┌─────────────────────────────┐
│        Application          │  (Ex: Snake, Calculatrice)
│    Utilise l&#39;API de l&#39;OS    │
├─────────────────────────────┤
│    Bibliothèque Système     │  (malloc, draw_line, printf)
│    Cache les détails        │
├─────────────────────────────┤
│        Matériel (CPU)       │  (Registres, MMIO, Mémoire)
└─────────────────────────────┘</code></pre>
<h3 data-number="11.2.2" id="ce-que-fait-un-os"><span class="header-section-number">11.2.2</span> Ce que fait un OS</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Fonction</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Gestion mémoire</strong></td>
<td style="text-align: left;">Allouer/libérer de la mémoire
dynamiquement</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Graphiques</strong></td>
<td style="text-align: left;">Dessiner des formes, du texte</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Entrées/Sorties</strong></td>
<td style="text-align: left;">Lire le clavier, afficher à l’écran</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Fichiers</strong></td>
<td style="text-align: left;">Sauvegarder/charger des données
(avancé)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Multitâche</strong></td>
<td style="text-align: left;">Exécuter plusieurs programmes
(avancé)</td>
</tr>
</tbody>
</table>
<p>Notre OS Codex implémente les trois premiers points.</p>
<hr />
<h2 data-number="11.3" id="gestion-de-la-mémoire-le-tas-heap"><span class="header-section-number">11.3</span> Gestion de la Mémoire (Le Tas
/ Heap)</h2>
<h3 data-number="11.3.1" id="le-problème-2"><span class="header-section-number">11.3.1</span> Le problème</h3>
<p>Jusqu’à présent, nous utilisions : - <strong>Variables
globales</strong> : Taille fixée à la compilation - <strong>Variables
locales</strong> : Sur la pile, libérées automatiquement</p>
<p>Mais que faire si on veut allouer une taille <strong>inconnue à
l’avance</strong> ?</p>
<h3 data-number="11.3.2" id="lallocateur-bump-simple"><span class="header-section-number">11.3.2</span> L’allocateur “Bump”
(Simple)</h3>
<p>L’allocateur le plus simple : un pointeur qui avance à chaque
allocation.</p>
<div class="sourceCode" id="cb169"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span><span class="op">*</span> heap_ptr <span class="op">=</span> <span class="op">(</span><span class="dt">char</span><span class="op">*)</span>HEAP_START<span class="op">;</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span><span class="op">*</span> malloc<span class="op">(</span><span class="dt">int</span> size<span class="op">)</span> <span class="op">{</span></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span><span class="op">*</span> result <span class="op">=</span> heap_ptr<span class="op">;</span></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a>    heap_ptr <span class="op">=</span> heap_ptr <span class="op">+</span> size<span class="op">;</span></span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> free<span class="op">(</span><span class="dt">char</span><span class="op">*</span> ptr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb169-10"><a href="#cb169-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Ne fait rien ! La mémoire n&#39;est jamais récupérée.</span></span>
<span id="cb169-11"><a href="#cb169-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Avantage</strong> : Très simple, très rapide.
<strong>Inconvénient</strong> : On ne peut pas réutiliser la mémoire
libérée.</p>
<h3 data-number="11.3.3" id="lallocateur-par-liste-chaînée-avancé"><span class="header-section-number">11.3.3</span> L’allocateur par Liste
Chaînée (Avancé)</h3>
<p>Pour réutiliser la mémoire, chaque bloc contient : - Sa taille - Un
pointeur vers le bloc libre suivant</p>
<pre><code>┌────────────────────────────────────────────────────┐
│ [size|next] [données...]  [size|next] [données...] │
└────────────────────────────────────────────────────┘</code></pre>
<p>Quand on libère un bloc, on l’ajoute à la liste des blocs libres.
Quand on alloue, on cherche un bloc de taille suffisante.</p>
<hr />
<h2 data-number="11.4" id="bibliothèque-graphique"><span class="header-section-number">11.4</span> Bibliothèque Graphique</h2>
<h3 data-number="11.4.1" id="le-problème-3"><span class="header-section-number">11.4.1</span> Le problème</h3>
<p>Pour allumer un pixel, il faut : 1. Calculer l’adresse de l’octet 2.
Calculer la position du bit 3. Faire un OR pour allumer (ou AND + NOT
pour éteindre)</p>
<p>C’est fastidieux et source d’erreurs.</p>
<h3 data-number="11.4.2" id="les-fonctions-graphiques"><span class="header-section-number">11.4.2</span> Les fonctions
graphiques</h3>
<div class="sourceCode" id="cb171"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> screen_init<span class="op">();</span></span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> screen_clear<span class="op">();</span></span>
<span id="cb171-3"><a href="#cb171-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> screen_set_color<span class="op">(</span><span class="dt">int</span> color<span class="op">);</span></span>
<span id="cb171-4"><a href="#cb171-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb171-5"><a href="#cb171-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> screen_draw_pixel<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">);</span></span>
<span id="cb171-6"><a href="#cb171-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> screen_draw_line<span class="op">(</span><span class="dt">int</span> x1<span class="op">,</span> <span class="dt">int</span> y1<span class="op">,</span> <span class="dt">int</span> x2<span class="op">,</span> <span class="dt">int</span> y2<span class="op">);</span></span>
<span id="cb171-7"><a href="#cb171-7" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> screen_draw_rect<span class="op">(</span><span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">,</span> <span class="dt">int</span> w<span class="op">,</span> <span class="dt">int</span> h<span class="op">);</span></span>
<span id="cb171-8"><a href="#cb171-8" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> screen_draw_circle<span class="op">(</span><span class="dt">int</span> cx<span class="op">,</span> <span class="dt">int</span> cy<span class="op">,</span> <span class="dt">int</span> r<span class="op">);</span></span>
<span id="cb171-9"><a href="#cb171-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> screen_print<span class="op">(</span><span class="dt">char</span><span class="op">*</span> text<span class="op">,</span> <span class="dt">int</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">);</span></span></code></pre></div>
<h3 data-number="11.4.3" id="lalgorithme-de-bresenham"><span class="header-section-number">11.4.3</span> L’algorithme de
Bresenham</h3>
<p>Pour dessiner des lignes droites avec uniquement des additions et des
comparaisons :</p>
<div class="sourceCode" id="cb172"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> screen_draw_line<span class="op">(</span><span class="dt">int</span> x1<span class="op">,</span> <span class="dt">int</span> y1<span class="op">,</span> <span class="dt">int</span> x2<span class="op">,</span> <span class="dt">int</span> y2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dx <span class="op">=</span> abs<span class="op">(</span>x2 <span class="op">-</span> x1<span class="op">);</span></span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dy <span class="op">=</span> abs<span class="op">(</span>y2 <span class="op">-</span> y1<span class="op">);</span></span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sx <span class="op">=</span> x1 <span class="op">&lt;</span> x2 <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sy <span class="op">=</span> y1 <span class="op">&lt;</span> y2 <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> err <span class="op">=</span> dx <span class="op">-</span> dy<span class="op">;</span></span>
<span id="cb172-7"><a href="#cb172-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-8"><a href="#cb172-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb172-9"><a href="#cb172-9" aria-hidden="true" tabindex="-1"></a>        screen_draw_pixel<span class="op">(</span>x1<span class="op">,</span> y1<span class="op">);</span></span>
<span id="cb172-10"><a href="#cb172-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>x1 <span class="op">==</span> x2 <span class="op">&amp;&amp;</span> y1 <span class="op">==</span> y2<span class="op">)</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb172-11"><a href="#cb172-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> e2 <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> err<span class="op">;</span></span>
<span id="cb172-12"><a href="#cb172-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>e2 <span class="op">&gt;</span> <span class="op">-</span>dy<span class="op">)</span> <span class="op">{</span> err <span class="op">=</span> err <span class="op">-</span> dy<span class="op">;</span> x1 <span class="op">=</span> x1 <span class="op">+</span> sx<span class="op">;</span> <span class="op">}</span></span>
<span id="cb172-13"><a href="#cb172-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>e2 <span class="op">&lt;</span> dx<span class="op">)</span>  <span class="op">{</span> err <span class="op">=</span> err <span class="op">+</span> dx<span class="op">;</span> y1 <span class="op">=</span> y1 <span class="op">+</span> sy<span class="op">;</span> <span class="op">}</span></span>
<span id="cb172-14"><a href="#cb172-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb172-15"><a href="#cb172-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Pas de multiplication, pas de division — uniquement des opérations
que notre CPU fait rapidement !</p>
<hr />
<h2 data-number="11.5" id="entrées-sorties"><span class="header-section-number">11.5</span> Entrées / Sorties</h2>
<h3 data-number="11.5.1" id="printf-simplifié"><span class="header-section-number">11.5.1</span> Printf simplifié</h3>
<div class="sourceCode" id="cb173"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> putchar<span class="op">(</span><span class="dt">char</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb173-2"><a href="#cb173-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Appel système SVC pour afficher un caractère</span></span>
<span id="cb173-3"><a href="#cb173-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb173-4"><a href="#cb173-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-5"><a href="#cb173-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> puts<span class="op">(</span><span class="dt">char</span><span class="op">*</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb173-6"><a href="#cb173-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(*</span>s <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb173-7"><a href="#cb173-7" aria-hidden="true" tabindex="-1"></a>        putchar<span class="op">(*</span>s<span class="op">);</span></span>
<span id="cb173-8"><a href="#cb173-8" aria-hidden="true" tabindex="-1"></a>        s <span class="op">=</span> s <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb173-9"><a href="#cb173-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb173-10"><a href="#cb173-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb173-11"><a href="#cb173-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb173-12"><a href="#cb173-12" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> print_int<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb173-13"><a href="#cb173-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb173-14"><a href="#cb173-14" aria-hidden="true" tabindex="-1"></a>        putchar<span class="op">(</span><span class="ch">&#39;-&#39;</span><span class="op">);</span></span>
<span id="cb173-15"><a href="#cb173-15" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="op">-</span>n<span class="op">;</span></span>
<span id="cb173-16"><a href="#cb173-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb173-17"><a href="#cb173-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&gt;=</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb173-18"><a href="#cb173-18" aria-hidden="true" tabindex="-1"></a>        print_int<span class="op">(</span>n <span class="op">/</span> <span class="dv">10</span><span class="op">);</span></span>
<span id="cb173-19"><a href="#cb173-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb173-20"><a href="#cb173-20" aria-hidden="true" tabindex="-1"></a>    putchar<span class="op">(</span><span class="ch">&#39;0&#39;</span> <span class="op">+</span> <span class="op">(</span>n <span class="op">%</span> <span class="dv">10</span><span class="op">));</span></span>
<span id="cb173-21"><a href="#cb173-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 data-number="11.5.2" id="lecture-du-clavier"><span class="header-section-number">11.5.2</span> Lecture du clavier</h3>
<div class="sourceCode" id="cb174"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> keyboard_read<span class="op">()</span> <span class="op">{</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">*</span> kbd <span class="op">=</span> <span class="op">(</span><span class="dt">int</span><span class="op">*)</span><span class="bn">0x00402600</span><span class="op">;</span></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span>kbd<span class="op">;</span></span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> keyboard_wait<span class="op">()</span> <span class="op">{</span></span>
<span id="cb174-7"><a href="#cb174-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> key<span class="op">;</span></span>
<span id="cb174-8"><a href="#cb174-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">((</span>key <span class="op">=</span> keyboard_read<span class="op">())</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb174-9"><a href="#cb174-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Attendre</span></span>
<span id="cb174-10"><a href="#cb174-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb174-11"><a href="#cb174-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> key<span class="op">;</span></span>
<span id="cb174-12"><a href="#cb174-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<hr />
<h2 data-number="11.6" id="interruptions-et-timer-concepts"><span class="header-section-number">11.6</span> Interruptions et Timer
(Concepts)</h2>
<h3 data-number="11.6.1" id="le-problème-du-polling"><span class="header-section-number">11.6.1</span> Le problème du polling</h3>
<p>Dans notre approche actuelle, le CPU vérifie constamment le clavier
:</p>
<div class="sourceCode" id="cb175"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> <span class="op">(</span>keyboard_read<span class="op">()</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{}</span>  <span class="co">// CPU occupe à ne rien faire !</span></span></code></pre></div>
<h3 data-number="11.6.2" id="les-interruptions"><span class="header-section-number">11.6.2</span> Les interruptions</h3>
<p>Avec les interruptions, le matériel <strong>signale</strong> au CPU
qu’un événement s’est produit :</p>
<ol type="1">
<li>Le CPU exécute le programme</li>
<li>Une touche est pressée → Le matériel déclenche une
<strong>interruption</strong></li>
<li>Le CPU s’arrête et saute vers le <strong>handler
d’interruption</strong></li>
<li>Le handler traite l’événement</li>
<li>Le CPU reprend le programme là où il s’était arrêté</li>
</ol>
<p>C’est la base du multitâche et des systèmes réactifs !</p>
<hr />
<h2 data-number="11.7" id="applications-démo"><span class="header-section-number">11.7</span> Applications Démo</h2>
<p>Le répertoire <code>demos/</code> contient des exemples complets
:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Démo</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>01_hello</code></td>
<td style="text-align: left;">Hello World classique</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>02_counter</code></td>
<td style="text-align: left;">Compteur avec affichage</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>03_graphics</code></td>
<td style="text-align: left;">Dessins géométriques</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>04_snake</code></td>
<td style="text-align: left;">Jeu du serpent complet !</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>05_shell</code></td>
<td style="text-align: left;">Interface en ligne de commande</td>
</tr>
</tbody>
</table>
<h3 data-number="11.7.1" id="compiler-et-exécuter-une-démo"><span class="header-section-number">11.7.1</span> Compiler et exécuter une
démo</h3>
<div class="sourceCode" id="cb176"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compiler</span></span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> c32_cli <span class="at">--</span> demos/04_snake/main.c <span class="at">-o</span> snake.bin</span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Exécuter</span></span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a><span class="ex">cargo</span> run <span class="at">-p</span> a32_runner <span class="at">--</span> snake.bin</span></code></pre></div>
<p>Ou utilisez le <strong>Simulateur Web</strong> pour une expérience
visuelle !</p>
<hr />
<h2 data-number="11.8" id="exercices-pratiques-8"><span class="header-section-number">11.8</span> Exercices Pratiques</h2>
<h3 data-number="11.8.1" id="exercices-sur-le-simulateur-web-8"><span class="header-section-number">11.8.1</span> Exercices sur le Simulateur
Web</h3>
<p>La section <strong>OS</strong> contient des exercices interactifs
:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Calculatrice</code></td>
<td style="text-align: left;">Calculatrice interactive avec clavier</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Variables</code></td>
<td style="text-align: left;">Shell pour définir des variables</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Timer</code></td>
<td style="text-align: left;">Affichage d’un compteur animé</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Scheduler</code></td>
<td style="text-align: left;">Simulation d’un ordonnanceur</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Projet Mini-OS</code></td>
<td style="text-align: left;">Shell multi-applications</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Task Manager</code></td>
<td style="text-align: left;">Gestionnaire de tâches visuel</td>
</tr>
</tbody>
</table>
<h3 data-number="11.8.2" id="défis-suggérés-1"><span class="header-section-number">11.8.2</span> Défis suggérés</h3>
<ol type="1">
<li><p><strong>Étendre l’OS</strong> : Ajoutez
<code>screen_draw_triangle()</code> en utilisant trois appels à
<code>screen_draw_line()</code>.</p></li>
<li><p><strong>Gestion mémoire</strong> : Testez l’allocateur avec
plusieurs <code>malloc()</code> et observez le comportement.</p></li>
<li><p><strong>Projet final</strong> : Créez votre propre application
dans <code>demos/</code> en utilisant tout ce que vous avez appris
!</p></li>
</ol>
<hr />
<h2 data-number="11.9" id="le-parcours-complet-1"><span class="header-section-number">11.9</span> Le Parcours Complet</h2>
<p>Vous avez parcouru tout le chemin :</p>
<pre><code>Chapitre 0 : Introduction
    ↓
Chapitre 1-5 : MATÉRIEL
    NAND → Portes → ALU → Mémoire → CPU
    ↓
Chapitre 6-9 : LOGICIEL
    Assembleur → Compilateur → C32 → OS
    ↓
Applications : Jeux, Calculatrices, Shell...</code></pre>
<p>Vous comprenez maintenant que l’ordinateur n’est pas une boîte
magique, mais une <strong>pyramide d’abstractions</strong>
magnifiquement ordonnées.</p>
<hr />
<h2 data-number="11.10" id="ce-quil-faut-retenir-8"><span class="header-section-number">11.10</span> Ce qu’il faut retenir</h2>
<ol type="1">
<li><p><strong>L’OS cache le matériel</strong> :
<code>draw_circle()</code> au lieu de manipuler des bits</p></li>
<li><p><strong>Gestion mémoire dynamique</strong> :
<code>malloc()</code> et <code>free()</code></p></li>
<li><p><strong>Bibliothèque graphique</strong> : Lignes, rectangles,
cercles, texte</p></li>
<li><p><strong>Entrées/Sorties</strong> : <code>putchar()</code>,
<code>keyboard_read()</code></p></li>
<li><p><strong>Interruptions</strong> : Le matériel peut signaler des
événements au CPU</p></li>
</ol>
<hr />
<h2 data-number="11.11" id="félicitations"><span class="header-section-number">11.11</span> Félicitations !</h2>
<p>Vous avez parcouru tout le chemin, de la <strong>porte NAND</strong>
au <strong>système d’exploitation</strong>. Vous comprenez maintenant
:</p>
<ul>
<li>Comment les bits deviennent des calculs (ALU)</li>
<li>Comment les calculs deviennent de la mémoire (RAM)</li>
<li>Comment la mémoire devient un programme (CPU)</li>
<li>Comment un programme devient une application (Compilateur + OS)</li>
</ul>
<p>Quand vous verrez du code s’exécuter, vous saurez
<strong>exactement</strong> ce qui se passe dans la machine. Ce n’est
plus de la magie — c’est de l’ingénierie que vous maîtrisez.</p>
<hr />
<p><strong>Et maintenant ?</strong></p>
<ul>
<li>Apprenez le C pour approfondir la programmation système</li>
<li>Étudiez le noyau Linux pour voir un vrai OS</li>
<li>Explorez les architectures ARM/RISC-V modernes</li>
<li>Construisez vos propres projets sur la base de Codex !</li>
</ul>
<h1 data-number="12" id="annexe-tous-les-exercices"><span class="header-section-number">12</span> Annexe : Tous les Exercices</h1>
<p>Cette annexe contient les enonces de tous les exercices disponibles
sur le simulateur web.</p>
<hr />
<h2 data-number="12.1" id="a.-exercices-hdl-portes-logiques"><span class="header-section-number">12.1</span> A. Exercices HDL (Portes
Logiques)</h2>
<p>Ces exercices construisent progressivement un ordinateur a partir de
la porte NAND.</p>
<h3 data-number="12.1.1" id="projet-1-portes-de-base"><span class="header-section-number">12.1.1</span> Projet 1 : Portes de
Base</h3>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 56%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Inv</td>
<td style="text-align: left;">Inverseur (NOT) :
<code>Inv(a) = Nand(a, a)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">And2</td>
<td style="text-align: left;">Porte AND :
<code>And2(a,b) = Inv(Nand(a,b))</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Or2</td>
<td style="text-align: left;">Porte OR :
<code>Or2(a,b) = Nand(Inv(a), Inv(b))</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Xor2</td>
<td style="text-align: left;">Porte XOR :
<code>Xor2(a,b) = Or2(And2(a, Inv(b)), And2(Inv(a), b))</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Mux</td>
<td style="text-align: left;">Multiplexeur : si sel=0 alors y=a sinon
y=b</td>
</tr>
<tr class="even">
<td style="text-align: left;">DMux</td>
<td style="text-align: left;">Demultiplexeur : distribue x vers a ou b
selon sel</td>
</tr>
</tbody>
</table>
<h3 data-number="12.1.2" id="projet-2-arithmetique"><span class="header-section-number">12.1.2</span> Projet 2 : Arithmetique</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">HalfAdder</td>
<td style="text-align: left;">Demi-additionneur : sum = a XOR b, carry =
a AND b</td>
</tr>
<tr class="even">
<td style="text-align: left;">FullAdder</td>
<td style="text-align: left;">Additionneur complet avec retenue
entrante</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Add32</td>
<td style="text-align: left;">Additionneur 32 bits (ripple carry)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Inc32</td>
<td style="text-align: left;">Incrementeur : ajoute 1 a l’entree</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Alu32</td>
<td style="text-align: left;">ALU 32 bits avec 6 operations</td>
</tr>
</tbody>
</table>
<h3 data-number="12.1.3" id="projet-3-memoire"><span class="header-section-number">12.1.3</span> Projet 3 : Memoire</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">DFF</td>
<td style="text-align: left;">D Flip-Flop (fourni)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Bit</td>
<td style="text-align: left;">Registre 1 bit avec load</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Register</td>
<td style="text-align: left;">Registre 32 bits</td>
</tr>
<tr class="even">
<td style="text-align: left;">RAM8</td>
<td style="text-align: left;">8 registres avec adressage 3 bits</td>
</tr>
<tr class="odd">
<td style="text-align: left;">RAM64</td>
<td style="text-align: left;">64 registres avec adressage 6 bits</td>
</tr>
<tr class="even">
<td style="text-align: left;">PC</td>
<td style="text-align: left;">Compteur de programme avec
inc/load/reset</td>
</tr>
</tbody>
</table>
<h3 data-number="12.1.4" id="projet-5-cpu"><span class="header-section-number">12.1.4</span> Projet 5 : CPU</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">CPU</td>
<td style="text-align: left;">Processeur complet A32</td>
</tr>
</tbody>
</table>
<h3 data-number="12.1.5" id="projet-6-cpu-pipeline-avance"><span class="header-section-number">12.1.5</span> Projet 6 : CPU Pipeline
(Avance)</h3>
<p>Ces exercices construisent un CPU pipeline 5 etages avec gestion des
aleas.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">IF_ID_Reg</td>
<td style="text-align: left;">Registre pipeline IF/ID avec stall et
flush</td>
</tr>
<tr class="even">
<td style="text-align: left;">HazardDetect</td>
<td style="text-align: left;">Detection des aleas load-use</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ForwardUnit</td>
<td style="text-align: left;">Bypass des donnees (forwarding)</td>
</tr>
<tr class="even">
<td style="text-align: left;">CPU_Pipeline</td>
<td style="text-align: left;">CPU pipeline 5 etages complet</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="12.2" id="b.-exercices-assembleur-a32"><span class="header-section-number">12.2</span> B. Exercices Assembleur
A32</h2>
<p>Ces exercices enseignent la programmation en assembleur A32.</p>
<h3 data-number="12.2.1" id="bases"><span class="header-section-number">12.2.1</span> Bases</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Hello World</td>
<td style="text-align: left;">Charger 42 dans R0</td>
<td style="text-align: left;">R0 = 42</td>
</tr>
<tr class="even">
<td style="text-align: left;">Addition</td>
<td style="text-align: left;">Calculer 15 + 27</td>
<td style="text-align: left;">R0 = 42</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Soustraction</td>
<td style="text-align: left;">Calculer 100 - 58</td>
<td style="text-align: left;">R0 = 42</td>
</tr>
<tr class="even">
<td style="text-align: left;">Logique</td>
<td style="text-align: left;">0xFF AND 0x0F</td>
<td style="text-align: left;">R0 = 15</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Doubler</td>
<td style="text-align: left;">21 * 2 sans MUL</td>
<td style="text-align: left;">R0 = 42</td>
</tr>
</tbody>
</table>
<h3 data-number="12.2.2" id="controle-de-flux"><span class="header-section-number">12.2.2</span> Controle de Flux</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Conditions</td>
<td style="text-align: left;">Maximum de 25 et 17</td>
<td style="text-align: left;">R0 = 25</td>
</tr>
<tr class="even">
<td style="text-align: left;">Valeur Absolue</td>
<td style="text-align: left;">Calculer</td>
<td style="text-align: left;">-42</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Boucles</td>
<td style="text-align: left;">Somme 1 + 2 + … + 10</td>
<td style="text-align: left;">R0 = 55</td>
</tr>
<tr class="even">
<td style="text-align: left;">Multiplication</td>
<td style="text-align: left;">6 * 7 par additions</td>
<td style="text-align: left;">R0 = 42</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Fibonacci</td>
<td style="text-align: left;">Calculer F(10)</td>
<td style="text-align: left;">R0 = 55</td>
</tr>
</tbody>
</table>
<h3 data-number="12.2.3" id="memoire"><span class="header-section-number">12.2.3</span> Memoire</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Tableaux</td>
<td style="text-align: left;">Somme de {10, 20, 30, 40, 50}</td>
<td style="text-align: left;">R0 = 150</td>
</tr>
<tr class="even">
<td style="text-align: left;">Maximum Tableau</td>
<td style="text-align: left;">Max de {12, 45, 7, 89, 23}</td>
<td style="text-align: left;">R0 = 89</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Memoire</td>
<td style="text-align: left;">Store puis Load</td>
<td style="text-align: left;">R0 = 30</td>
</tr>
</tbody>
</table>
<h3 data-number="12.2.4" id="structures"><span class="header-section-number">12.2.4</span> Structures</h3>
<p>Ces exercices preparent aux structs en C en montrant comment les
donnees structurees sont organisees en memoire.</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Structure Simple</td>
<td style="text-align: left;">Lire champs d’un Point (x+y)</td>
<td style="text-align: left;">R0 = 42</td>
</tr>
<tr class="even">
<td style="text-align: left;">Initialiser Structure</td>
<td style="text-align: left;">Ecrire dans les champs d’un Point</td>
<td style="text-align: left;">R0 = 42</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Structure Rectangle</td>
<td style="text-align: left;">Structure avec 4 champs, calcul aire</td>
<td style="text-align: left;">R0 = 42</td>
</tr>
<tr class="even">
<td style="text-align: left;">Tableau de Structures</td>
<td style="text-align: left;">Parcourir tableau de Points, somme des
x</td>
<td style="text-align: left;">R0 = 33</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Somme x+y Structures</td>
<td style="text-align: left;">Acceder aux deux champs de chaque
Point</td>
<td style="text-align: left;">R0 = 42</td>
</tr>
</tbody>
</table>
<h3 data-number="12.2.5" id="fonctions-1"><span class="header-section-number">12.2.5</span> Fonctions</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Fonctions</td>
<td style="text-align: left;">Fonction double(21)</td>
<td style="text-align: left;">R0 = 42</td>
</tr>
<tr class="even">
<td style="text-align: left;">Fonction Add3</td>
<td style="text-align: left;">add3(10, 15, 17)</td>
<td style="text-align: left;">R0 = 42</td>
</tr>
</tbody>
</table>
<h3 data-number="12.2.6" id="entreessorties"><span class="header-section-number">12.2.6</span> Entrees/Sorties</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Ecrire Caractere</td>
<td style="text-align: left;">Ecrire ‘A’ a PUTC</td>
<td style="text-align: left;">R0 = 65</td>
</tr>
<tr class="even">
<td style="text-align: left;">Hello String</td>
<td style="text-align: left;">Afficher “Hi”</td>
<td style="text-align: left;">R0 = 2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Print Loop</td>
<td style="text-align: left;">Afficher “ABCD” avec boucle</td>
<td style="text-align: left;">R0 = 4</td>
</tr>
</tbody>
</table>
<h3 data-number="12.2.7" id="ecran-320x240-1-bitpixel"><span class="header-section-number">12.2.7</span> Ecran (320x240, 1
bit/pixel)</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Pixel</td>
<td style="text-align: left;">Allumer pixel (0,0)</td>
<td style="text-align: left;">R0 = 0x80</td>
</tr>
<tr class="even">
<td style="text-align: left;">Ligne Horizontale</td>
<td style="text-align: left;">8 pixels horizontaux</td>
<td style="text-align: left;">R0 = 0xFF</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Ligne Verticale</td>
<td style="text-align: left;">8 pixels verticaux</td>
<td style="text-align: left;">R0 = 8</td>
</tr>
<tr class="even">
<td style="text-align: left;">Rectangle</td>
<td style="text-align: left;">Carre 8x8</td>
<td style="text-align: left;">R0 = 8</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Damier</td>
<td style="text-align: left;">Motif en damier</td>
<td style="text-align: left;">R0 = 8</td>
</tr>
</tbody>
</table>
<h3 data-number="12.2.8" id="jeux-interactifs"><span class="header-section-number">12.2.8</span> Jeux Interactifs</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Lire Caractere</td>
<td style="text-align: left;">Lire clavier et convertir ASCII</td>
</tr>
<tr class="even">
<td style="text-align: left;">Lire 2 Chiffres</td>
<td style="text-align: left;">Former un nombre a 2 chiffres</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Deviner Nombre</td>
<td style="text-align: left;">Jeu de devinette (secret = 7)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Degrade</td>
<td style="text-align: left;">Effet dithering sur ecran</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Recherche Dichotomique</td>
<td style="text-align: left;">Trouver 42 en 7 essais</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="12.3" id="c.-exercices-c32"><span class="header-section-number">12.3</span> C. Exercices C32</h2>
<p>Ces exercices enseignent la programmation en C32.</p>
<h3 data-number="12.3.1" id="bases-1"><span class="header-section-number">12.3.1</span> Bases</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Variables</td>
<td style="text-align: left;">x=10, y=32, retourner x+y</td>
<td style="text-align: left;">42</td>
</tr>
<tr class="even">
<td style="text-align: left;">Expressions</td>
<td style="text-align: left;">(5+3)*(10-4)/2</td>
<td style="text-align: left;">24</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Modulo</td>
<td style="text-align: left;">(100%7) + (45%8)</td>
<td style="text-align: left;">7</td>
</tr>
<tr class="even">
<td style="text-align: left;">Incrementation</td>
<td style="text-align: left;">5 -&gt; +3 -&gt; *2 -&gt; -1</td>
<td style="text-align: left;">15</td>
</tr>
</tbody>
</table>
<h3 data-number="12.3.2" id="conditions"><span class="header-section-number">12.3.2</span> Conditions</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Conditions</td>
<td style="text-align: left;">Maximum de 25 et 17</td>
<td style="text-align: left;">25</td>
</tr>
<tr class="even">
<td style="text-align: left;">Else-If</td>
<td style="text-align: left;">Classifier note 75</td>
<td style="text-align: left;">3</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Operateurs Logiques</td>
<td style="text-align: left;">15 dans [10,20] ?</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Maximum de 3</td>
<td style="text-align: left;">Max de 15, 42, 27</td>
<td style="text-align: left;">42</td>
</tr>
</tbody>
</table>
<h3 data-number="12.3.3" id="boucles"><span class="header-section-number">12.3.3</span> Boucles</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Boucle For</td>
<td style="text-align: left;">Somme 1 a 10</td>
<td style="text-align: left;">55</td>
</tr>
<tr class="even">
<td style="text-align: left;">Boucle While</td>
<td style="text-align: left;">Compter chiffres de 12345</td>
<td style="text-align: left;">5</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Boucles Imbriquees</td>
<td style="text-align: left;">Double boucle i*j</td>
<td style="text-align: left;">60</td>
</tr>
<tr class="even">
<td style="text-align: left;">Multiplication</td>
<td style="text-align: left;">7<em>8 sans operateur </em></td>
<td style="text-align: left;">56</td>
</tr>
</tbody>
</table>
<h3 data-number="12.3.4" id="fonctions-2"><span class="header-section-number">12.3.4</span> Fonctions</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Fonctions</td>
<td style="text-align: left;">square(7)</td>
<td style="text-align: left;">49</td>
</tr>
<tr class="even">
<td style="text-align: left;">Parametres Multiples</td>
<td style="text-align: left;">add3(10, 20, 12)</td>
<td style="text-align: left;">42</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Valeur Absolue</td>
<td style="text-align: left;">abs(-15) + abs(10)</td>
<td style="text-align: left;">25</td>
</tr>
<tr class="even">
<td style="text-align: left;">Min et Max</td>
<td style="text-align: left;">max(10,25) - min(10,25)</td>
<td style="text-align: left;">15</td>
</tr>
</tbody>
</table>
<h3 data-number="12.3.5" id="tableaux-1"><span class="header-section-number">12.3.5</span> Tableaux</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Tableaux</td>
<td style="text-align: left;">Somme de {3,7,2,9,5}</td>
<td style="text-align: left;">26</td>
</tr>
<tr class="even">
<td style="text-align: left;">Maximum Tableau</td>
<td style="text-align: left;">Max de 6 elements</td>
<td style="text-align: left;">56</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Compter Elements</td>
<td style="text-align: left;">Nombres pairs</td>
<td style="text-align: left;">4</td>
</tr>
</tbody>
</table>
<h3 data-number="12.3.6" id="pointeurs-1"><span class="header-section-number">12.3.6</span> Pointeurs</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Pointeurs</td>
<td style="text-align: left;">Modifier via *p</td>
<td style="text-align: left;">42</td>
</tr>
<tr class="even">
<td style="text-align: left;">Swap</td>
<td style="text-align: left;">Echanger x et y</td>
<td style="text-align: left;">20</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Pointeurs et Tableaux</td>
<td style="text-align: left;">Somme avec *(p+i)</td>
<td style="text-align: left;">50</td>
</tr>
</tbody>
</table>
<h3 data-number="12.3.7" id="operations-binaires"><span class="header-section-number">12.3.7</span> Operations Binaires</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Operations Binaires</td>
<td style="text-align: left;">(10&amp;12)</td>
<td style="text-align: left;">(10^12)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Puissance de 2</td>
<td style="text-align: left;">is_pow2(16)+is_pow2(15)+is_pow2(32)</td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
<h3 data-number="12.3.8" id="recursion"><span class="header-section-number">12.3.8</span> Recursion</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Factorielle</td>
<td style="text-align: left;">fact(5)</td>
<td style="text-align: left;">120</td>
</tr>
<tr class="even">
<td style="text-align: left;">Fibonacci</td>
<td style="text-align: left;">fib(10)</td>
<td style="text-align: left;">55</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Somme Recursive</td>
<td style="text-align: left;">sum(10)</td>
<td style="text-align: left;">55</td>
</tr>
</tbody>
</table>
<h3 data-number="12.3.9" id="algorithmes-avances"><span class="header-section-number">12.3.9</span> Algorithmes Avances</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">PGCD (Euclide)</td>
<td style="text-align: left;">gcd(48, 18)</td>
<td style="text-align: left;">6</td>
</tr>
<tr class="even">
<td style="text-align: left;">Puissance</td>
<td style="text-align: left;">power(2, 10)</td>
<td style="text-align: left;">1024</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Test Primalite</td>
<td style="text-align: left;">Premiers &lt;= 20</td>
<td style="text-align: left;">8</td>
</tr>
<tr class="even">
<td style="text-align: left;">Tri a Bulles</td>
<td style="text-align: left;">Trier et retourner min</td>
<td style="text-align: left;">12</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Recherche Binaire</td>
<td style="text-align: left;">Trouver 23 dans tableau</td>
<td style="text-align: left;">5</td>
</tr>
<tr class="even">
<td style="text-align: left;">Inverser Tableau</td>
<td style="text-align: left;">Inverser {1,2,3,4,5}</td>
<td style="text-align: left;">35</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Somme Chiffres</td>
<td style="text-align: left;">digit_sum(12345)</td>
<td style="text-align: left;">15</td>
</tr>
<tr class="even">
<td style="text-align: left;">Palindrome</td>
<td style="text-align: left;">12321 + 1221 + 123</td>
<td style="text-align: left;">2</td>
</tr>
</tbody>
</table>
<h3 data-number="12.3.10" id="structures-1"><span class="header-section-number">12.3.10</span> Structures</h3>
<p>Les structures permettent de regrouper plusieurs variables liees.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Definition Struct</td>
<td style="text-align: left;">struct Point, p.x + p.y</td>
<td style="text-align: left;">42</td>
</tr>
<tr class="even">
<td style="text-align: left;">Pointeur Struct</td>
<td style="text-align: left;">Utiliser l’operateur -&gt;</td>
<td style="text-align: left;">42</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Struct et Fonctions</td>
<td style="text-align: left;">distance_sq(Point*)</td>
<td style="text-align: left;">25</td>
</tr>
<tr class="even">
<td style="text-align: left;">Structs Imbriquees</td>
<td style="text-align: left;">Rectangle avec Point</td>
<td style="text-align: left;">42</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Tableau de Structs</td>
<td style="text-align: left;">Point[3], somme des x</td>
<td style="text-align: left;">33</td>
</tr>
<tr class="even">
<td style="text-align: left;">Sizeof Struct</td>
<td style="text-align: left;">Taille des structures</td>
<td style="text-align: left;">16</td>
</tr>
</tbody>
</table>
<h3 data-number="12.3.11" id="entreessorties-1"><span class="header-section-number">12.3.11</span> Entrees/Sorties</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Ecrire Caractere</td>
<td style="text-align: left;">putchar(65)</td>
<td style="text-align: left;">65</td>
</tr>
<tr class="even">
<td style="text-align: left;">Afficher Chaine</td>
<td style="text-align: left;">print(“HI”)</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Afficher Nombre</td>
<td style="text-align: left;">print_int(42)</td>
<td style="text-align: left;">42</td>
</tr>
<tr class="even">
<td style="text-align: left;">Dessiner Pixel</td>
<td style="text-align: left;">Pixel (0,0)</td>
<td style="text-align: left;">128</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Ligne Horizontale</td>
<td style="text-align: left;">16 pixels</td>
<td style="text-align: left;">16</td>
</tr>
<tr class="even">
<td style="text-align: left;">Dessiner Rectangle</td>
<td style="text-align: left;">Carre 8x8</td>
<td style="text-align: left;">64</td>
</tr>
</tbody>
</table>
<h3 data-number="12.3.12" id="projets-avances"><span class="header-section-number">12.3.12</span> Projets Avances</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Objectif</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Crible Eratosthene</td>
<td style="text-align: left;">Premiers &lt;= 50</td>
<td style="text-align: left;">15</td>
</tr>
<tr class="even">
<td style="text-align: left;">Suite Collatz</td>
<td style="text-align: left;">Longueur pour n=27</td>
<td style="text-align: left;">112</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Projet Final</td>
<td style="text-align: left;">Diviseurs de 28</td>
<td style="text-align: left;">28</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="12.4" id="d.-construction-du-compilateur"><span class="header-section-number">12.4</span> D. Construction du
Compilateur</h2>
<p>Ces exercices construisent progressivement un compilateur C -&gt;
A32.</p>
<h3 data-number="12.4.1" id="phase-1-lexer"><span class="header-section-number">12.4.1</span> Phase 1 : Lexer</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">1.1 Reconnaitre Chiffre</td>
<td style="text-align: left;"><code>is_digit(c)</code> : retourne 1 si
‘0’-‘9’</td>
</tr>
<tr class="even">
<td style="text-align: left;">1.2 Lire Nombre</td>
<td style="text-align: left;"><code>parse_number(s, pos)</code> :
extrait un entier</td>
</tr>
<tr class="odd">
<td style="text-align: left;">1.3 Identifier Tokens</td>
<td style="text-align: left;"><code>next_token()</code> : retourne type
du token</td>
</tr>
</tbody>
</table>
<h3 data-number="12.4.2" id="phase-2-parser"><span class="header-section-number">12.4.2</span> Phase 2 : Parser</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">2.1 Evaluer a + b</td>
<td style="text-align: left;">Parser et calculer une operation</td>
</tr>
<tr class="even">
<td style="text-align: left;">2.2 Evaluer a + b + c</td>
<td style="text-align: left;">Chaine d’operations gauche a droite</td>
</tr>
<tr class="odd">
<td style="text-align: left;">2.3 Precedence</td>
<td style="text-align: left;">Descente recursive : <code>*</code> avant
<code>+</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">2.4 Parentheses</td>
<td style="text-align: left;">Supporter <code>(2 + 3) * 4</code></td>
</tr>
</tbody>
</table>
<h3 data-number="12.4.3" id="phase-3-emission-asm"><span class="header-section-number">12.4.3</span> Phase 3 : Emission ASM</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">3.1 Generer MOV</td>
<td style="text-align: left;">Produire <code>&quot;MOV R0, #42&quot;</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">3.2 Operation Binaire</td>
<td style="text-align: left;">Mapper <code>+</code> -&gt;
<code>ADD</code>, <code>*</code> -&gt; <code>MUL</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">3.3 Comparaison</td>
<td style="text-align: left;">Generer <code>CMP</code> et
conditions</td>
</tr>
</tbody>
</table>
<h3 data-number="12.4.4" id="phase-4-codegen-expressions-1"><span class="header-section-number">12.4.4</span> Phase 4 : CodeGen
Expressions</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">4.1 Constante -&gt; A32</td>
<td style="text-align: left;">Code pour charger une constante</td>
</tr>
<tr class="even">
<td style="text-align: left;">4.2 Addition -&gt; A32</td>
<td style="text-align: left;"><code>a + b</code> -&gt;
<code>MOV/MOV/ADD</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">4.3 Expression -&gt; A32</td>
<td style="text-align: left;">Expression complete avec precedence</td>
</tr>
</tbody>
</table>
<h3 data-number="12.4.5" id="phase-5-structures-de-controle"><span class="header-section-number">12.4.5</span> Phase 5 : Structures de
Controle</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">5.1 If/Else -&gt; A32</td>
<td style="text-align: left;">Sauts conditionnels et labels</td>
</tr>
<tr class="even">
<td style="text-align: left;">5.2 While -&gt; A32</td>
<td style="text-align: left;">Boucles avec labels</td>
</tr>
</tbody>
</table>
<h3 data-number="12.4.6" id="phase-6-fonctions-1"><span class="header-section-number">12.4.6</span> Phase 6 : Fonctions</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">6.1 Prologue/Epilogue</td>
<td style="text-align: left;">Sauvegarder LR, reserver pile</td>
</tr>
<tr class="even">
<td style="text-align: left;">6.2 Appel de Fonction</td>
<td style="text-align: left;">Arguments et BL</td>
</tr>
</tbody>
</table>
<h3 data-number="12.4.7" id="phase-7-projet-final-1"><span class="header-section-number">12.4.7</span> Phase 7 : Projet Final</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">7.1 Mini-Compilateur</td>
<td style="text-align: left;">Compiler expression en A32 executable</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="12.5" id="e.-systeme-dexploitation"><span class="header-section-number">12.5</span> E. Systeme d’Exploitation</h2>
<p>Ces exercices introduisent les concepts OS.</p>
<h3 data-number="12.5.1" id="initialisation"><span class="header-section-number">12.5.1</span> Initialisation</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Bootstrap</td>
<td style="text-align: left;">Initialiser SP, effacer BSS, appeler
main</td>
<td style="text-align: left;">42</td>
</tr>
</tbody>
</table>
<h3 data-number="12.5.2" id="gestion-memoire"><span class="header-section-number">12.5.2</span> Gestion Memoire</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Bump Allocator</td>
<td style="text-align: left;">Allocation simple par incrementation</td>
<td style="text-align: left;">100</td>
</tr>
<tr class="even">
<td style="text-align: left;">Free List</td>
<td style="text-align: left;">Allocateur avec liberation</td>
<td style="text-align: left;">1</td>
</tr>
</tbody>
</table>
<h3 data-number="12.5.3" id="drivers"><span class="header-section-number">12.5.3</span> Drivers</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Driver Ecran</td>
<td style="text-align: left;">Fonctions set_pixel, clear_screen</td>
<td style="text-align: left;">4</td>
</tr>
<tr class="even">
<td style="text-align: left;">Police Bitmap</td>
<td style="text-align: left;">Dessiner caracteres 8x8</td>
<td style="text-align: left;">51</td>
</tr>
</tbody>
</table>
<h3 data-number="12.5.4" id="console-et-clavier"><span class="header-section-number">12.5.4</span> Console et Clavier</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Console</td>
<td style="text-align: left;">Console texte avec curseur (40x30)</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Driver Clavier</td>
<td style="text-align: left;">Lire les touches, buffer clavier</td>
<td style="text-align: left;">3</td>
</tr>
</tbody>
</table>
<h3 data-number="12.5.5" id="shell-et-applications"><span class="header-section-number">12.5.5</span> Shell et Applications</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Shell</td>
<td style="text-align: left;">Interpreteur de commandes basique</td>
<td style="text-align: left;">1</td>
</tr>
<tr class="even">
<td style="text-align: left;">Calculatrice</td>
<td style="text-align: left;">Evaluer expressions arithmetiques</td>
<td style="text-align: left;">42</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Variables Shell</td>
<td style="text-align: left;">Variables dans le shell ($x, $y)</td>
<td style="text-align: left;">15</td>
</tr>
<tr class="even">
<td style="text-align: left;">Compte a Rebours</td>
<td style="text-align: left;">Timer avec affichage</td>
<td style="text-align: left;">0</td>
</tr>
</tbody>
</table>
<h3 data-number="12.5.6" id="multitache"><span class="header-section-number">12.5.6</span> Multitache</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Resultat</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Interruptions</td>
<td style="text-align: left;">Gestion des interruptions timer</td>
<td style="text-align: left;">10</td>
</tr>
<tr class="even">
<td style="text-align: left;">Coroutines</td>
<td style="text-align: left;">Changement de contexte manuel</td>
<td style="text-align: left;">2</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Scheduler</td>
<td style="text-align: left;">Ordonnanceur round-robin</td>
<td style="text-align: left;">6</td>
</tr>
</tbody>
</table>
<h3 data-number="12.5.7" id="projets-os"><span class="header-section-number">12.5.7</span> Projets OS</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Exercice</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Projet 1: Mini-OS Shell</td>
<td style="text-align: left;">Shell complet avec commandes</td>
</tr>
<tr class="even">
<td style="text-align: left;">Projet 2: Task Manager</td>
<td style="text-align: left;">Gestionnaire de taches multiples</td>
</tr>
</tbody>
</table>
<hr />
<h2 data-number="12.6" id="conseils-pour-les-exercices"><span class="header-section-number">12.6</span> Conseils pour les
Exercices</h2>
<ol type="1">
<li><strong>Commencez simple</strong> : Les premiers exercices de chaque
section sont accessibles</li>
<li><strong>Lisez l’enonce</strong> : Chaque exercice contient des
indices</li>
<li><strong>Testez souvent</strong> : Le simulateur execute votre code
instantanement</li>
<li><strong>Consultez les solutions</strong> : Apres avoir essaye,
comparez avec la solution</li>
<li><strong>Progressez</strong> : Chaque exercice prepare le
suivant</li>
</ol>
<hr />
<p><strong>Bon courage !</strong></p>
</body>
</html>
