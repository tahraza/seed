---
marp: true
theme: seed-tp
paginate: true
header: "Seed - TP Chapitre 02"
---

# TP Chapitre 02 : Construction de l'ALU

## Objectifs pratiques

- ImplÃ©menter le Half Adder et Full Adder
- Construire un additionneur multi-bits
- Assembler l'ALU complÃ¨te
- GÃ©nÃ©rer les drapeaux

**DurÃ©e estimÃ©e :** 2h30

**PrÃ©requis :** TP Chapitre 01 terminÃ© (portes logiques)

---

## PrÃ©paration

### AccÃ¨s au Simulateur

ğŸ‘‰ [Ouvrir le Simulateur HDL](https://seed.music-music.fr/)

Allez dans **HDL Progression** â†’ **Projet 3 : ArithmÃ©tique**

**Alternative locale :**
```bash
cd web
npm install
npm run dev
```

---

## Exercice 1 : Half Adder

**Objectif :** Additionner 2 bits sans retenue d'entrÃ©e

### SpÃ©cification

| a | b | sum | carry |
|---|---|:---:|:-----:|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |

### Formules

```
sum   = XOR(a, b)
carry = AND(a, b)
```

ğŸ‘‰ [Ouvrir l'exercice HalfAdder](https://seed.music-music.fr/)

---

### Code Ã  complÃ©ter

```vhdl
entity HalfAdder is
  port(
    a     : in bit;
    b     : in bit;
    sum   : out bit;
    carry : out bit
  );
end entity;

architecture rtl of HalfAdder is
  component Xor2 port(a, b : in bit; y : out bit); end component;
  component And2 port(a, b : in bit; y : out bit); end component;
begin
  -- TODO: ComplÃ©ter
end architecture;
```

<details>
<summary>Solution</summary>

```vhdl
u_sum: Xor2 port map (a => a, b => b, y => sum);
u_carry: And2 port map (a => a, b => b, y => carry);
```

</details>

---

## Exercice 2 : Full Adder

**Objectif :** Additionner 2 bits + retenue d'entrÃ©e

### SpÃ©cification

3 entrÃ©es : a, b, cin
2 sorties : sum, cout

### Construction

```
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
  a â”€â”€â”€â”¤        â”œâ”€â”€ s1 â”€â”€â”
       â”‚  HA1   â”‚        â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
  b â”€â”€â”€â”¤        â”œâ”€â”€ c1 â”€â”€â”¼â”€â”€â”€â”¤        â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚   â”‚   OR   â”œâ”€â”€ cout
                         â”‚   â”‚        â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 cin â”€â”€â”¤        â”œâ”€â”€ c2 â”€â”€â”˜       â–²
       â”‚  HA2   â”‚                â”‚
  s1 â”€â”€â”¤        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€ sum
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

ğŸ‘‰ [Ouvrir l'exercice FullAdder](https://seed.music-music.fr/)

---

### Code Ã  complÃ©ter

```vhdl
entity FullAdder is
  port(
    a    : in bit;
    b    : in bit;
    cin  : in bit;
    sum  : out bit;
    cout : out bit
  );
end entity;

architecture rtl of FullAdder is
  component HalfAdder
    port(a, b : in bit; sum, carry : out bit);
  end component;
  component Or2 port(a, b : in bit; y : out bit); end component;
  signal s1, c1, c2 : bit;
begin
  -- TODO: ComplÃ©ter
end architecture;
```

<details>
<summary>Solution</summary>

```vhdl
ha1: HalfAdder port map (a => a, b => b, sum => s1, carry => c1);
ha2: HalfAdder port map (a => s1, b => cin, sum => sum, carry => c2);
u_cout: Or2 port map (a => c1, b => c2, y => cout);
```

</details>

---

## Exercice 3 : Additionneur 16 bits

**Objectif :** ChaÃ®ner des Full Adders

### SpÃ©cification

- EntrÃ©es : a[15:0], b[15:0]
- Sorties : y[15:0], cout

### Construction en cascade

```vhdl
FA0: cin = '0'         â†’ y[0], c0
FA1: cin = c0          â†’ y[1], c1
FA2: cin = c1          â†’ y[2], c2
...
FA15: cin = c14        â†’ y[15], cout
```

ğŸ‘‰ [Ouvrir l'exercice Add16](https://seed.music-music.fr/)

---

### Code avec generate

```vhdl
entity Add16 is
  port(
    a    : in bits(15 downto 0);
    b    : in bits(15 downto 0);
    y    : out bits(15 downto 0);
    cout : out bit
  );
end entity;

architecture rtl of Add16 is
  component FullAdder
    port(a, b, cin : in bit; sum, cout : out bit);
  end component;
  signal c : bits(16 downto 0);
begin
  c(0) <= '0';  -- Pas de retenue initiale

  gen: for i in 0 to 15 generate
    fa: FullAdder port map (
      a => a(i), b => b(i), cin => c(i),
      sum => y(i), cout => c(i+1)
    );
  end generate;

  cout <= c(16);
end architecture;
```

---

## Exercice 4 : IncrÃ©menteur (Inc16)

**Objectif :** Ajouter 1 Ã  un nombre

### Astuce

`Inc(a) = Add(a, 1)` mais on peut simplifier !

```
a + 1 = a + 0...01
```

Le second opÃ©rande est toujours 0...01.

ğŸ‘‰ [Ouvrir l'exercice Inc16](https://seed.music-music.fr/)

<details>
<summary>Solution simplifiÃ©e</summary>

On peut utiliser un additionneur avec `b = 0` et `cin = 1` :

```vhdl
add: Add16 port map (
  a => a,
  b => "0000000000000000",
  cin => '1',  -- +1
  y => y
);
```

Ou chaÃ®ner des Half Adders (plus Ã©conomique).

</details>

---

## Exercice 5 : Soustracteur (Sub16)

**Objectif :** Utiliser le complÃ©ment Ã  2

### Rappel

```
A - B = A + NOT(B) + 1
```

### Construction

1. Inverser tous les bits de B
2. Additionner avec cin = 1

ğŸ‘‰ [Ouvrir l'exercice Sub16](https://seed.music-music.fr/)

---

### Code Ã  complÃ©ter

```vhdl
entity Sub16 is
  port(
    a : in bits(15 downto 0);
    b : in bits(15 downto 0);
    y : out bits(15 downto 0)
  );
end entity;

architecture rtl of Sub16 is
  component Inv port(a : in bit; y : out bit); end component;
  component FullAdder port(a,b,cin : in bit; sum,cout : out bit); end component;
  signal not_b : bits(15 downto 0);
  signal c : bits(16 downto 0);
begin
  -- Ã‰tape 1 : Inverser B
  gen_inv: for i in 0 to 15 generate
    inv: Inv port map (a => b(i), y => not_b(i));
  end generate;

  -- Ã‰tape 2 : Additionner avec cin = 1
  c(0) <= '1';
  gen_add: for i in 0 to 15 generate
    fa: FullAdder port map (
      a => a(i), b => not_b(i), cin => c(i),
      sum => y(i), cout => c(i+1)
    );
  end generate;
end architecture;
```

---

## Exercice 6 : ALU ComplÃ¨te

**Objectif :** Assembler toutes les opÃ©rations

### Interface

```vhdl
entity ALU is
  port(
    a  : in bits(31 downto 0);
    b  : in bits(31 downto 0);
    op : in bits(3 downto 0);
    y  : out bits(31 downto 0);
    n  : out bit;  -- Negative
    z  : out bit;  -- Zero
    c  : out bit;  -- Carry
    v  : out bit   -- Overflow
  );
end entity;
```

ğŸ‘‰ [Ouvrir l'exercice ALU](https://seed.music-music.fr/)

---

### Architecture de l'ALU

**Principe :** Calculer tous les rÃ©sultats, puis MUX pour sÃ©lectionner

```
         a         b
         â”‚         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚         â”‚         â”‚
â”Œâ”€â”€â”€â–¼â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”
â”‚  AND  â”‚ â”‚  OR   â”‚ â”‚  ADD  â”‚ ...
â””â”€â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”€â”˜
    â”‚         â”‚         â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚         â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
    â”‚       MUX8Way     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              y
```

---

### Ã‰tapes d'implÃ©mentation

1. **OpÃ©rations logiques** : AND32, OR32, XOR32, NOT32

2. **Addition/Soustraction** :
   - Inverser B si SUB
   - cin = 1 si SUB

3. **SÃ©lection** : Mux8Way selon `op`

4. **Drapeaux** :
   - N = y(31)
   - Z = NOR de tous les bits de y
   - C = cout de l'additionneur
   - V = calcul d'overflow

---

### Calcul du flag V (Overflow signÃ©)

L'overflow se produit quand :
- Deux positifs donnent un nÃ©gatif
- Deux nÃ©gatifs donnent un positif

```vhdl
-- Pour l'addition :
-- V = (a[31] == b[31]) AND (a[31] != y[31])

signal same_sign, sign_changed : bit;

u_same: Xnor2 port map (a => a(31), b => b(31), y => same_sign);
u_changed: Xor2 port map (a => a(31), b => y(31), y => sign_changed);
u_v: And2 port map (a => same_sign, b => sign_changed, y => v);
```

---

### Calcul du flag Z (Zero)

Tous les bits du rÃ©sultat doivent Ãªtre Ã  0 :

```vhdl
-- Option 1 : Or32Way puis NOT
signal any_one : bit;
u_or: Or32Way port map (a => y, y => any_one);
u_z: Inv port map (a => any_one, y => z);

-- Option 2 : ChaÃ®ne de NOR
```

---

## Exercice 7 : Test de l'ALU

**Objectif :** VÃ©rifier le fonctionnement

### Tests Ã  effectuer

| a | b | op | RÃ©sultat attendu | Flags |
|---|---|:--:|:-----------------|:------|
| 5 | 3 | ADD | 8 | N=0, Z=0 |
| 5 | 5 | SUB | 0 | Z=1 |
| -1 | 1 | ADD | 0 | Z=1, C=1 |
| 0x7FFFFFFF | 1 | ADD | 0x80000000 | N=1, V=1 |

ğŸ‘‰ [Tester dans le simulateur](https://seed.music-music.fr/)

---

## Exercice Bonus : Multiplicateur 8 bits

**Objectif :** Comprendre la multiplication matÃ©rielle

### Principe des produits partiels

```
        a[7:0]
      Ã— b[7:0]
      â”€â”€â”€â”€â”€â”€â”€â”€
  pp0 = a AND b[0]     (dÃ©calage 0)
  pp1 = a AND b[1]     (dÃ©calage 1)
  ...
  pp7 = a AND b[7]     (dÃ©calage 7)
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  y[15:0] = somme des pp
```

### Structure

1. **8 And8** pour gÃ©nÃ©rer les produits partiels
2. **Addition en arbre** (7 additions)
3. **RÃ©sultat sur 16 bits**

ğŸ‘‰ [Ouvrir l'exercice Mul8](https://seed.music-music.fr/)

---

## RÃ©capitulatif

### Composants implÃ©mentÃ©s

| Composant | ComplexitÃ© | PrÃ©requis |
|:----------|:----------:|:----------|
| HalfAdder | â­ | XOR, AND |
| FullAdder | â­â­ | HalfAdder, OR |
| Add16 | â­â­ | FullAdder |
| Inc16 | â­ | Add16 |
| Sub16 | â­â­ | Add16, NOT |
| ALU | â­â­â­ | Tout ! |
| Mul8 | â­â­â­ | And8, Add16 |

---

## Validation Finale

### Checklist

- [ ] HalfAdder : tous les tests passent
- [ ] FullAdder : tous les tests passent
- [ ] Add16 : additionne correctement
- [ ] Sub16 : soustrait via complÃ©ment Ã  2
- [ ] ALU : toutes les opÃ©rations fonctionnent
- [ ] Drapeaux N, Z, C, V calculÃ©s correctement

### Prochaine Ã©tape

â¡ï¸ **Chapitre 03 : MÃ©moire** â€” Construire des registres et de la RAM !

ğŸ“š **RÃ©fÃ©rence :** Livre Seed, Chapitre 02 - ArithmÃ©tique
