---
marp: true
theme: seed-td
paginate: true
header: "Seed - TD Chapitre 05"
---

# TD Chapitre 05 : Le Processeur (CPU)

## Objectifs

- Comprendre le cycle Fetch-Decode-Execute
- Analyser le rÃ´le du dÃ©codeur
- Tracer le chemin des donnÃ©es
- Comprendre les signaux de contrÃ´le

**DurÃ©e estimÃ©e :** 1h30

---

## Exercice 1 : Le Cycle d'ExÃ©cution

**Objectif :** Identifier les phases d'exÃ©cution

### 1.1 Ordonnancement

Remettez dans l'ordre les phases du cycle :

- [ ] Writeback
- [ ] Fetch
- [ ] Memory
- [ ] Decode
- [ ] Execute

<details>
<summary>Solution</summary>

1. **Fetch** : Lire l'instruction Ã  PC
2. **Decode** : Analyser les bits
3. **Execute** : Calcul ALU
4. **Memory** : AccÃ¨s mÃ©moire (si LDR/STR)
5. **Writeback** : Ã‰crire le rÃ©sultat

</details>

---

### 1.2 Que se passe-t-il Ã  chaque phase ?

| Phase | Action principale |
|:------|:------------------|
| Fetch | ? |
| Decode | ? |
| Execute | ? |
| Memory | ? |
| Writeback | ? |

<details>
<summary>Solution</summary>

| Phase | Action principale |
|:------|:------------------|
| Fetch | **PC â†’ MÃ©moire â†’ Instruction** |
| Decode | **DÃ©codeur dÃ©coupe, ContrÃ´le gÃ©nÃ¨re signaux** |
| Execute | **ALU effectue l'opÃ©ration** |
| Memory | **LDR lit, STR Ã©crit (sinon rien)** |
| Writeback | **RÃ©sultat â†’ Registre Rd** |

</details>

---

## Exercice 2 : Le DÃ©codeur

**Objectif :** Comprendre l'extraction des champs

### 2.1 DÃ©codage d'instruction

DÃ©codez cette instruction (en binaire) :

```
1110 000 0100 0 0010 0001 0000 0000 0011
```

| Champ | Bits | Valeur | Signification |
|:------|:-----|:-------|:--------------|
| cond | 31-28 | ? | ? |
| class | 27-25 | ? | ? |
| op | 24-21 | ? | ? |
| S | 20 | ? | ? |
| Rn | 19-16 | ? | ? |
| Rd | 15-12 | ? | ? |
| Rm | 3-0 | ? | ? |

<details>
<summary>Solution</summary>

| Champ | Bits | Valeur | Signification |
|:------|:-----|:-------|:--------------|
| cond | 31-28 | 1110 | AL (toujours) |
| class | 27-25 | 000 | ALU registre |
| op | 24-21 | 0100 | ADD |
| S | 20 | 0 | Ne pas modifier flags |
| Rn | 19-16 | 0010 | R2 |
| Rd | 15-12 | 0001 | R1 |
| Rm | 3-0 | 0011 | R3 |

**Instruction :** `ADD R1, R2, R3`

</details>

---

### 2.2 Question conceptuelle

Pourquoi dit-on que le dÃ©codeur est "purement combinatoire" ?

<details>
<summary>Solution</summary>

Le dÃ©codeur ne contient **pas de mÃ©moire** (pas de DFF).

Il fait uniquement du **cÃ¢blage** : router les bits de l'instruction vers les bonnes sorties.

- EntrÃ©e : 32 bits d'instruction
- Sortie : les champs (cond, op, Rn, Rd, etc.)

C'est instantanÃ©, pas de dÃ©lai de cycle.

</details>

---

## Exercice 3 : L'UnitÃ© de ContrÃ´le

**Objectif :** DÃ©terminer les signaux de contrÃ´le

### 3.1 Table de contrÃ´le

ComplÃ©tez la table des signaux pour chaque instruction :

| Instruction | reg_write | mem_read | mem_write | alu_src | branch |
|:------------|:---------:|:--------:|:---------:|:-------:|:------:|
| ADD Rd, Rn, Rm | ? | ? | ? | ? | ? |
| ADD Rd, Rn, #imm | ? | ? | ? | ? | ? |
| LDR Rd, [Rn] | ? | ? | ? | ? | ? |
| STR Rd, [Rn] | ? | ? | ? | ? | ? |
| B label | ? | ? | ? | ? | ? |
| CMP Rn, Rm | ? | ? | ? | ? | ? |

<details>
<summary>Solution</summary>

| Instruction | reg_write | mem_read | mem_write | alu_src | branch |
|:------------|:---------:|:--------:|:---------:|:-------:|:------:|
| ADD Rd, Rn, Rm | **1** | 0 | 0 | **0** (reg) | 0 |
| ADD Rd, Rn, #imm | **1** | 0 | 0 | **1** (imm) | 0 |
| LDR Rd, [Rn] | **1** | **1** | 0 | 1 | 0 |
| STR Rd, [Rn] | 0 | 0 | **1** | 1 | 0 |
| B label | 0 | 0 | 0 | X | **1** |
| CMP Rn, Rm | 0 | 0 | 0 | 0 | 0 |

**Note :** CMP met Ã  jour les flags mais n'Ã©crit pas dans un registre.

</details>

---

## Exercice 4 : Chemin des DonnÃ©es

**Objectif :** Tracer le flux pour diffÃ©rentes instructions

### 4.1 Tracer ADD R1, R2, R3

Dessinez le chemin des donnÃ©es pour `ADD R1, R2, R3` :

1. Quels registres sont lus ?
2. Que calcule l'ALU ?
3. OÃ¹ va le rÃ©sultat ?

<details>
<summary>Solution</summary>

```
1. RegFile lit R2 (Rn) et R3 (Rm)
2. ALU calcule R2 + R3
3. RÃ©sultat â†’ R1 (Rd)
```

```
       Rn=R2   Rm=R3
          â”‚       â”‚
          â–¼       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   RegFile       â”‚
    â”‚  (lecture)      â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚      â”‚
    Data_A    Data_B
         â”‚      â”‚
         â–¼      â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚   ALU    â”‚ op=ADD
       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
            â”‚
       RÃ©sultat
            â”‚
            â–¼
       RegFile (Rd=R1)
```

</details>

---

### 4.2 Tracer LDR R0, [R1, #8]

DÃ©crivez le chemin pour `LDR R0, [R1, #8]` :

<details>
<summary>Solution</summary>

```
1. RegFile lit R1 (adresse de base)
2. Extend extrait 8 (offset)
3. ALU calcule R1 + 8 (adresse effective)
4. MÃ©moire lit MEM[R1+8]
5. RÃ©sultat â†’ R0
```

```
       Rn=R1    imm=8
          â”‚       â”‚
          â–¼       â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”
    â”‚ RegFile â”‚  â”‚Extendâ”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”€â”˜
         â”‚          â”‚
    Data_A    alu_src=1
         â”‚          â”‚
         â–¼          â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚   ALU (ADD)  â”‚
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
         Adresse = R1+8
              â”‚
              â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚   MÃ©moire    â”‚ mem_read=1
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
           Valeur
              â”‚
              â–¼
       RegFile (Rd=R0)
```

</details>

---

## Exercice 5 : Conditions et Flags

**Objectif :** Comprendre le CondCheck

### 5.1 Table CondCheck

ComplÃ©tez la sortie `ok` du CondCheck :

| cond | Condition | N | Z | C | V | ok |
|:----:|:----------|:-:|:-:|:-:|:-:|:--:|
| 0000 | EQ | 0 | 1 | 0 | 0 | ? |
| 0000 | EQ | 0 | 0 | 0 | 0 | ? |
| 0001 | NE | 0 | 1 | 0 | 0 | ? |
| 1011 | LT | 1 | 0 | 0 | 0 | ? |
| 1011 | LT | 0 | 0 | 0 | 1 | ? |
| 1110 | AL | X | X | X | X | ? |

<details>
<summary>Solution</summary>

| cond | Condition | N | Z | C | V | ok |
|:----:|:----------|:-:|:-:|:-:|:-:|:--:|
| 0000 | EQ | 0 | 1 | 0 | 0 | **1** (Z=1) |
| 0000 | EQ | 0 | 0 | 0 | 0 | **0** (Z=0) |
| 0001 | NE | 0 | 1 | 0 | 0 | **0** (Z=1 donc pas NE) |
| 1011 | LT | 1 | 0 | 0 | 0 | **1** (Nâ‰ V : 1â‰ 0) |
| 1011 | LT | 0 | 0 | 0 | 1 | **1** (Nâ‰ V : 0â‰ 1) |
| 1110 | AL | X | X | X | X | **1** (toujours) |

</details>

---

### 5.2 Impact du CondCheck

Que se passe-t-il quand `ok = 0` ?

<details>
<summary>Solution</summary>

Quand `ok = 0`, l'instruction est **annulÃ©e** :

- `reg_write` est forcÃ© Ã  0 â†’ Pas d'Ã©criture dans le registre
- `branch` est forcÃ© Ã  0 â†’ Pas de saut
- `mem_write` est forcÃ© Ã  0 â†’ Pas d'Ã©criture mÃ©moire

L'instruction devient un **NOP** (No Operation).

C'est la base de la **prÃ©dication** en ARM/A32.

</details>

---

## Exercice 6 : Les Multiplexeurs

**Objectif :** Comprendre le routage des donnÃ©es

### 6.1 RÃ´le des MUX

Pour chaque MUX, expliquez son rÃ´le :

| MUX | EntrÃ©e 0 | EntrÃ©e 1 | SÃ©lection |
|:----|:---------|:---------|:----------|
| alu_src | ? | ? | ? |
| wb_src | ? | ? | ? |
| pc_src | ? | ? | ? |

<details>
<summary>Solution</summary>

| MUX | EntrÃ©e 0 | EntrÃ©e 1 | SÃ©lection |
|:----|:---------|:---------|:----------|
| alu_src | **Rm** (registre) | **Imm** (immÃ©diat) | 0=reg, 1=imm |
| wb_src | **ALU result** | **MEM data** | 0=alu, 1=mem |
| pc_src | **PC+4** | **Branch addr** | 0=sÃ©quentiel, 1=saut |

</details>

---

## Exercice 7 : Pipeline (DÃ©fi)

**Objectif :** Comprendre les hazards

### 7.1 Data Hazard

Analysez ce code :

```asm
ADD R1, R2, R3    ; Instruction 1
SUB R4, R1, R5    ; Instruction 2
```

Pourquoi y a-t-il un problÃ¨me dans un pipeline ?

<details>
<summary>Solution</summary>

**ProblÃ¨me :** SUB a besoin de R1, mais ADD n'a pas encore Ã©crit R1.

```
Cycle:     1    2    3    4    5    6
ADD R1:   IF   ID   EX   MEM  WB
SUB R4:        IF   ID   EX   ...
                    â†‘
              Besoin de R1, mais pas encore Ã©crit !
```

**Solutions :**
1. **Forwarding** : Bypass le rÃ©sultat de ADD directement vers SUB
2. **Stall** : Attendre que ADD finisse (pÃ©nalitÃ© de performance)

</details>

---

## RÃ©capitulatif

### CompÃ©tences validÃ©es

AprÃ¨s ce TD, vous devez savoir :

- [ ] DÃ©crire les 5 phases d'exÃ©cution
- [ ] DÃ©coder une instruction en champs
- [ ] DÃ©terminer les signaux de contrÃ´le
- [ ] Tracer le chemin des donnÃ©es
- [ ] Expliquer le rÃ´le du CondCheck

### Prochaine Ã©tape

â¡ï¸ **TP Chapitre 05** : Explorer le CPU Visualizer et implÃ©menter les composants

ğŸ“š **RÃ©fÃ©rence :** Livre Seed, Chapitre 05 - CPU
