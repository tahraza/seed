---
marp: true
theme: seed-tp
paginate: true
header: "Seed - TP Chapitre 05"
---

# TP Chapitre 05 : Exploration du CPU

## Objectifs pratiques

- Explorer le CPU Visualizer
- Observer le cycle d'ex√©cution
- Comprendre les signaux de contr√¥le
- Impl√©menter les composants du CPU

**Dur√©e estim√©e :** 2h

**Pr√©requis :** TD Chapitre 05 termin√©

---

## Partie 1 : CPU Visualizer

### Acc√®s au Visualizer

üëâ [Ouvrir le CPU Visualizer](https://seed.music-music.fr/visualizer.html)

**Interface :**
- Vue pipeline (5 √©tapes)
- Panneau registres (R0-R15)
- Panneau flags (N, Z, C, V)
- Code source avec surlignage

---

## Exercice 1 : Premi√®re Exploration

**Objectif :** Se familiariser avec l'interface

### √âtapes

1. Cliquez sur **Demo 1: Addition simple**
2. Cliquez sur **Reset** pour initialiser
3. Observez l'interface :
   - O√π sont les registres ?
   - O√π est le code ?
   - O√π sont les √©tapes du pipeline ?

### Validation

‚úÖ Vous identifiez les 4 zones principales

---

## Exercice 2 : Ex√©cution Pas-√†-Pas

**Objectif :** Observer le cycle d'ex√©cution

### √âtapes

1. Avec **Demo 1: Addition**, cliquez sur **Step** (ou touche N)
2. Observez quelle √©tape s'illumine
3. Continuez en pas-√†-pas
4. Notez :
   - Quand R0 change-t-il ?
   - Quand R1 change-t-il ?
   - Quand R2 change-t-il (r√©sultat) ?

### Code de la d√©mo

```asm
MOV R0, #5      ; R0 = 5
MOV R1, #3      ; R1 = 3
ADD R2, R0, R1  ; R2 = R0 + R1 = 8
```

üëâ [Ex√©cuter](https://seed.music-music.fr/visualizer.html)

---

### Questions

1. Combien de cycles pour l'instruction MOV ?
2. √Ä quelle √©tape le registre est-il modifi√© ?
3. Que vaut R2 √† la fin ?

<details>
<summary>R√©ponses</summary>

1. **5 cycles** (Fetch ‚Üí Decode ‚Üí Execute ‚Üí Memory ‚Üí Writeback)
2. **Writeback** : c'est la derni√®re √©tape
3. **R2 = 8** (5 + 3)

</details>

---

## Exercice 3 : Observer les Flags

**Objectif :** Comprendre N, Z, C, V

### √âtapes

1. Chargez **Demo 6: Flags CPU**
2. Ex√©cutez pas-√†-pas
3. Observez les flags apr√®s chaque instruction

### Questions

- Quelle instruction met Z = 1 ?
- Quelle instruction met N = 1 ?
- Quelle instruction met C = 1 ?

üëâ [Ex√©cuter Demo Flags](https://seed.music-music.fr/visualizer.html)

<details>
<summary>Indice</summary>

- Z = 1 quand le r√©sultat est 0 (ex: SUB R0, R0)
- N = 1 quand le r√©sultat est n√©gatif
- C = 1 en cas de d√©passement non-sign√©

</details>

---

## Exercice 4 : Branchement Conditionnel

**Objectif :** Observer un branchement

### √âtapes

1. Chargez **Demo 2: Boucles**
2. Ex√©cutez jusqu'√† l'instruction B.LE
3. Observez :
   - Les flags apr√®s CMP
   - Le PC change-t-il apr√®s B.LE ?
   - Combien de fois la boucle s'ex√©cute ?

### Code de la d√©mo

```asm
    MOV R0, #0       ; sum = 0
    MOV R1, #1       ; i = 1
loop:
    ADD R0, R0, R1   ; sum += i
    ADD R1, R1, #1   ; i++
    CMP R1, #5
    B.LE loop        ; si i <= 5, boucler
```

üëâ [Ex√©cuter](https://seed.music-music.fr/visualizer.html)

---

### Questions

1. Pourquoi utilise-t-on CMP avant B.LE ?
2. Que vaut R0 √† la fin (somme de 1 √† 5) ?

<details>
<summary>R√©ponses</summary>

1. **CMP** calcule R1 - 5 et met √† jour les flags. B.LE teste Z=1 ou N‚â†V.
2. **R0 = 15** (1+2+3+4+5)

</details>

---

## Exercice 5 : Acc√®s M√©moire

**Objectif :** Observer LDR et STR

### √âtapes

1. Chargez **Demo 3: Acc√®s m√©moire**
2. Ex√©cutez pas-√†-pas
3. Observez :
   - L'√©tape **Memory** s'active-t-elle ?
   - Quand la valeur appara√Æt-elle dans le registre ?

üëâ [Ex√©cuter Demo M√©moire](https://seed.music-music.fr/visualizer.html)

---

## Partie 2 : Impl√©mentation HDL (Optionnel)

### Acc√®s au Simulateur HDL

üëâ [Ouvrir le Simulateur HDL](https://seed.music-music.fr/)

Allez dans **HDL Progression** ‚Üí **Projet 5 : CPU**

---

## Exercice 6 : Le D√©codeur

**Objectif :** Extraire les champs de l'instruction

### Sp√©cification

```vhdl
entity Decoder is
  port(
    instr : in bits(31 downto 0);
    cond  : out bits(3 downto 0);
    class : out bits(2 downto 0);
    op    : out bits(3 downto 0);
    s_bit : out bit;
    rn    : out bits(3 downto 0);
    rd    : out bits(3 downto 0);
    rm    : out bits(3 downto 0);
    imm12 : out bits(11 downto 0)
  );
end entity;
```

### Code √† compl√©ter

```vhdl
architecture rtl of Decoder is
begin
  cond  <= instr(31 downto 28);
  class <= instr(27 downto 25);
  -- TODO: Compl√©ter les autres champs
end architecture;
```

<details>
<summary>Solution</summary>

```vhdl
cond  <= instr(31 downto 28);
class <= instr(27 downto 25);
op    <= instr(24 downto 21);
s_bit <= instr(20);
rn    <= instr(19 downto 16);
rd    <= instr(15 downto 12);
rm    <= instr(3 downto 0);
imm12 <= instr(11 downto 0);
```

</details>

---

## Exercice 7 : CondCheck

**Objectif :** V√©rifier les conditions

### Sp√©cification

```vhdl
entity CondCheck is
  port(
    cond : in bits(3 downto 0);
    n, z, c, v : in bit;
    ok : out bit
  );
end entity;
```

### Logique

| cond | Condition | Test |
|:----:|:----------|:-----|
| 0000 | EQ | Z = 1 |
| 0001 | NE | Z = 0 |
| 1010 | GE | N = V |
| 1011 | LT | N ‚â† V |
| 1110 | AL | toujours |

üëâ [Ouvrir l'exercice](https://seed.music-music.fr/)

---

### Solution CondCheck

<details>
<summary>Solution</summary>

```vhdl
architecture rtl of CondCheck is
  signal eq, ne, ge, lt, al : bit;
  signal n_xor_v : bit;
begin
  eq <= z;
  ne <= not z;
  n_xor_v <= n xor v;
  ge <= not n_xor_v;
  lt <= n_xor_v;
  al <= '1';

  -- Multiplexeur selon cond
  with cond select ok <=
    eq when "0000",
    ne when "0001",
    ge when "1010",
    lt when "1011",
    al when "1110",
    '0' when others;
end architecture;
```

</details>

---

## Exercice 8 : Charger Votre Code

**Objectif :** Ex√©cuter un programme personnel

### √âtapes

1. Dans le CPU Visualizer, cliquez sur **Charger fichier**
2. Cr√©ez un fichier `test.asm` avec ce code :

```asm
; Calcul de 10 + 20 + 30
MOV R0, #10
MOV R1, #20
MOV R2, #30
ADD R3, R0, R1
ADD R3, R3, R2
HALT
```

3. Chargez et ex√©cutez
4. V√©rifiez que R3 = 60

üëâ [Charger dans le Visualizer](https://seed.music-music.fr/visualizer.html)

---

## R√©capitulatif

### Composants explor√©s

| Composant | Fonction |
|:----------|:---------|
| Pipeline | 5 √©tapes d'ex√©cution |
| Registres | R0-R15, mise √† jour en WB |
| Flags | N, Z, C, V apr√®s op√©rations |
| Branchements | Modifient le PC |
| M√©moire | LDR/STR √† l'√©tape MEM |

---

## Validation Finale

### Checklist

- [ ] Ex√©cuter une d√©mo pas-√†-pas
- [ ] Observer les flags changer
- [ ] Comprendre un branchement conditionnel
- [ ] Voir l'√©tape Memory s'activer pour LDR
- [ ] (Optionnel) Impl√©menter le Decoder

### Prochaine √©tape

‚û°Ô∏è **Chapitre 06 : Assembleur** ‚Äî Traduire le code assembleur en binaire !

üìö **R√©f√©rence :** Livre Seed, Chapitre 05 - CPU
