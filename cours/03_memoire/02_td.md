---
marp: true
theme: seed-td
paginate: true
header: "Seed - TD Chapitre 03"
---

# TD Chapitre 03 : Logique SÃ©quentielle

## Objectifs

- Comprendre le rÃ´le de l'horloge
- MaÃ®triser le comportement de la DFF
- Concevoir des registres avec rÃ©troaction
- Comprendre l'adressage de la RAM

**DurÃ©e estimÃ©e :** 1h30

---

## Exercice 1 : Comprendre l'Horloge

**Objectif :** Distinguer combinatoire et sÃ©quentiel

### 1.1 Classification

Classez ces circuits en **combinatoire** ou **sÃ©quentiel** :

| Circuit | Type |
|:--------|:-----|
| Porte AND | ? |
| Additionneur | ? |
| Registre | ? |
| Multiplexeur | ? |
| RAM | ? |
| ALU | ? |

<details>
<summary>Solution</summary>

| Circuit | Type |
|:--------|:-----|
| Porte AND | **Combinatoire** |
| Additionneur | **Combinatoire** |
| Registre | **SÃ©quentiel** |
| Multiplexeur | **Combinatoire** |
| RAM | **SÃ©quentiel** |
| ALU | **Combinatoire** |

**RÃ¨gle :** SÃ©quentiel si contient de la mÃ©moire (DFF).

</details>

---

### 1.2 Front montant

Sur ce chronogramme, Ã  quels instants (t1, t2, t3, t4) y a-t-il un front montant ?

```
clk:   â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€â”   â”Œâ”€â”€â”€
         â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜   â””â”€â”€â”€â”˜
      t0  t1  t2  t3  t4  t5  t6
```

<details>
<summary>Solution</summary>

Front montant = passage de 0 Ã  1

- **t2** : Front montant âœ“
- **t4** : Front montant âœ“
- **t6** : Front montant âœ“

t1, t3, t5 sont des fronts descendants (1 â†’ 0).

</details>

---

## Exercice 2 : Comportement de la DFF

**Objectif :** Appliquer la rÃ¨gle `q(t) = d(t-1)`

### 2.1 Chronogramme

ComplÃ©tez la sortie `q` pour cette DFF :

```
clk:   â”€â” â”Œâ”€â” â”Œâ”€â” â”Œâ”€â” â”Œâ”€â” â”Œâ”€â”
        â””â”€â”˜ â””â”€â”˜ â””â”€â”˜ â””â”€â”˜ â””â”€â”˜ â””â”€
  d:   â”€[0]â”€[1]â”€[1]â”€[0]â”€[1]â”€[0]â”€

  q:   â”€[?]â”€[?]â”€[?]â”€[?]â”€[?]â”€[?]â”€
        t0  t1  t2  t3  t4  t5
```

Supposons q(t0) = 0 (valeur initiale).

<details>
<summary>Solution</summary>

```
  q:   â”€[0]â”€[0]â”€[1]â”€[1]â”€[0]â”€[1]â”€
        t0  t1  t2  t3  t4  t5
```

- q(t0) = 0 (initial)
- q(t1) = d(t0) = 0
- q(t2) = d(t1) = 1
- q(t3) = d(t2) = 1
- q(t4) = d(t3) = 0
- q(t5) = d(t4) = 1

La sortie est "en retard" d'un cycle sur l'entrÃ©e.

</details>

---

### 2.2 Question conceptuelle

Pourquoi la DFF est-elle appelÃ©e "l'atome de la mÃ©moire" ?

<details>
<summary>Solution</summary>

La DFF est le plus petit circuit capable de **mÃ©moriser un bit** d'un cycle Ã  l'autre.

- Elle introduit un dÃ©lai d'un cycle
- Elle permet de stocker de l'information
- Tous les autres composants de mÃ©moire (registres, RAM) sont construits Ã  partir de DFF

</details>

---

## Exercice 3 : Registre 1-bit

**Objectif :** Comprendre la rÃ©troaction

### 3.1 SchÃ©ma

Dessinez le schÃ©ma d'un registre 1-bit utilisant :
- 1 Mux 2-vers-1
- 1 DFF

Indice : La sortie du DFF revient vers le Mux.

<details>
<summary>Solution</summary>

```
           â”Œâ”€â”€â”€â”€â”€â”
  in â”€â”€â”€â”€â”€â”€â”¤  1  â”‚
           â”‚     â”‚
           â”‚ Mux â”œâ”€â”€â”€â”€â”¬â”€â”€â”€ out
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤  0  â”‚    â”‚
  â”‚        â”‚     â”‚    â”‚
  â”‚   loadâ”€â”¤ sel â”‚    â”‚
  â”‚        â””â”€â”€â”€â”€â”€â”˜    â”‚
  â”‚                   â”‚
  â”‚     â”Œâ”€â”€â”€â”€â”€â”       â”‚
  â””â”€â”€â”€â”€â”€â”¤     â”‚       â”‚
        â”‚ DFF â”‚â—„â”€â”€â”€â”€â”€â”€â”˜
        â””â”€â”€â”€â”€â”€â”˜
```

- Si load=0 : Mux sÃ©lectionne entrÃ©e 0 (valeur DFF) â†’ maintien
- Si load=1 : Mux sÃ©lectionne entrÃ©e 1 (in) â†’ nouvelle valeur

</details>

---

### 3.2 Chronogramme du registre

ComplÃ©tez la sortie `q` pour ce registre 1-bit :

```
clk:   â”€â” â”Œâ”€â” â”Œâ”€â” â”Œâ”€â” â”Œâ”€â”
        â””â”€â”˜ â””â”€â”˜ â””â”€â”˜ â””â”€â”˜ â””â”€
  in:  â”€[1]â”€[1]â”€[0]â”€[1]â”€[0]â”€
load:  â”€[1]â”€[0]â”€[0]â”€[1]â”€[0]â”€

  q:   â”€[?]â”€[?]â”€[?]â”€[?]â”€[?]â”€
        t0  t1  t2  t3  t4
```

Supposons q(t0) = 0.

<details>
<summary>Solution</summary>

```
  q:   â”€[0]â”€[1]â”€[1]â”€[1]â”€[1]â”€
        t0  t1  t2  t3  t4
```

- q(t0) = 0 (initial)
- t1 : load=1, donc q(t1) = in(t0) = 1
- t2 : load=0, donc q(t2) = q(t1) = 1 (maintien)
- t3 : load=0, donc q(t3) = q(t2) = 1 (maintien)
- t4 : load=1, donc q(t4) = in(t3) = 1

**Attention au timing :** la valeur de `in` utilisÃ©e est celle du cycle oÃ¹ load=1.

</details>

---

## Exercice 4 : Compteur de Programme (PC)

**Objectif :** GÃ©rer les prioritÃ©s

### 4.1 Table de prioritÃ©

Le PC a 4 modes : reset, load, inc, hold. ComplÃ©tez :

| reset | load | inc | Action |
|:-----:|:----:|:---:|:-------|
| 1 | x | x | ? |
| 0 | 1 | x | ? |
| 0 | 0 | 1 | ? |
| 0 | 0 | 0 | ? |

<details>
<summary>Solution</summary>

| reset | load | inc | Action |
|:-----:|:----:|:---:|:-------|
| 1 | x | x | **PC â† 0** |
| 0 | 1 | x | **PC â† in** |
| 0 | 0 | 1 | **PC â† PC + 1** |
| 0 | 0 | 0 | **PC â† PC** (hold) |

`x` = don't care (peu importe la valeur)

</details>

---

### 4.2 Simulation du PC

Simulez le PC avec ces signaux. PC initial = 5.

| Cycle | reset | load | inc | in | PC aprÃ¨s |
|:-----:|:-----:|:----:|:---:|:--:|:--------:|
| 0 | 0 | 0 | 1 | - | ? |
| 1 | 0 | 0 | 1 | - | ? |
| 2 | 0 | 1 | 0 | 10 | ? |
| 3 | 0 | 0 | 1 | - | ? |
| 4 | 1 | 0 | 0 | - | ? |

<details>
<summary>Solution</summary>

| Cycle | reset | load | inc | in | PC aprÃ¨s |
|:-----:|:-----:|:----:|:---:|:--:|:--------:|
| 0 | 0 | 0 | 1 | - | **6** |
| 1 | 0 | 0 | 1 | - | **7** |
| 2 | 0 | 1 | 0 | 10 | **10** |
| 3 | 0 | 0 | 1 | - | **11** |
| 4 | 1 | 0 | 0 | - | **0** |

Le cycle 4 reset a prioritÃ© sur tout.

</details>

---

## Exercice 5 : Adressage RAM

**Objectif :** Comprendre l'adressage

### 5.1 RAM8 : DÃ©codage d'adresse

Une RAM8 a 8 mots. L'adresse est sur 3 bits [2:0].

| address | Registre sÃ©lectionnÃ© |
|:-------:|:--------------------:|
| 000 | ? |
| 011 | ? |
| 101 | ? |
| 111 | ? |

<details>
<summary>Solution</summary>

| address | Registre sÃ©lectionnÃ© |
|:-------:|:--------------------:|
| 000 | **Reg 0** |
| 011 | **Reg 3** |
| 101 | **Reg 5** |
| 111 | **Reg 7** |

L'adresse binaire = numÃ©ro du registre.

</details>

---

### 5.2 RAM64 : Adresse hiÃ©rarchique

Une RAM64 est construite avec 8 RAM8.

L'adresse est sur 6 bits [5:0].

DÃ©composez ces adresses :

| address | RAM8 | Mot dans RAM8 |
|:-------:|:----:|:-------------:|
| 000101 | ? | ? |
| 011010 | ? | ? |
| 101111 | ? | ? |

<details>
<summary>Solution</summary>

address[5:3] = quelle RAM8
address[2:0] = quel mot dans cette RAM8

| address | [5:3] | [2:0] | RAM8 | Mot |
|:-------:|:-----:|:-----:|:----:|:---:|
| 000101 | 000 | 101 | **0** | **5** |
| 011010 | 011 | 010 | **3** | **2** |
| 101111 | 101 | 111 | **5** | **7** |

</details>

---

## Exercice 6 : Conception de registre

**Objectif :** Appliquer les concepts

### 6.1 Registre avec enable

Concevez un registre 1-bit avec deux signaux :
- `enable` : Si 0, la sortie est toujours 0
- `load` : Comme avant

Dessinez le schÃ©ma.

<details>
<summary>Solution</summary>

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”
                    â”‚       â”‚
  BitReg â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚  AND  â”œâ”€â”€â”€ out
                    â”‚       â”‚
  enable â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”˜
```

On utilise un registre normal suivi d'un AND avec enable.

Alternative : intÃ©grer enable dans la logique du Mux interne.

</details>

---

### 6.2 Question conceptuelle

Pourquoi dit-on que les registres sont "plus rapides" que la RAM ?

<details>
<summary>Solution</summary>

1. **AccÃ¨s direct** : Les registres sont directement connectÃ©s Ã  l'ALU, pas besoin de dÃ©codage d'adresse

2. **Pas de multiplexage** : Pas de Mux gÃ©ant Ã  traverser

3. **Plus prÃ¨s du CPU** : Moins de fil = moins de dÃ©lai de propagation

4. **Peu nombreux** : 16 registres vs millions de cellules RAM = circuit plus simple

**En pratique :** Un accÃ¨s registre = 1 cycle, un accÃ¨s RAM = plusieurs cycles.

</details>

---

## Exercice 7 : DÃ©fi - Registre Ã  dÃ©calage

**Objectif :** Ã‰tendre le concept

Un **shift register** dÃ©cale les bits d'une position Ã  chaque cycle.

Exemple sur 4 bits avec entrÃ©e sÃ©rie `sin` :

```
Cycle 0: [0][0][0][0], sin=1
Cycle 1: [1][0][0][0], sin=0
Cycle 2: [0][1][0][0], sin=1
Cycle 3: [1][0][1][0], sin=1
```

Comment construire un tel registre avec des DFF ?

<details>
<summary>Solution</summary>

```
sin â”€â”€â–º DFF â”€â”€â–º DFF â”€â”€â–º DFF â”€â”€â–º DFF â”€â”€â–º sout
        q[3]    q[2]    q[1]    q[0]
```

Chaque DFF prend son entrÃ©e de la DFF prÃ©cÃ©dente.
Le bit "entre" par la gauche et "sort" par la droite.

UtilisÃ© pour : communication sÃ©rie, multiplication par 2, etc.

</details>

---

## RÃ©capitulatif

### CompÃ©tences validÃ©es

AprÃ¨s ce TD, vous devez savoir :

- [ ] Distinguer combinatoire et sÃ©quentiel
- [ ] Appliquer la rÃ¨gle DFF : q(t) = d(t-1)
- [ ] Concevoir un registre avec rÃ©troaction
- [ ] Simuler le comportement du PC
- [ ] DÃ©composer une adresse RAM hiÃ©rarchique

### Prochaine Ã©tape

â¡ï¸ **TP Chapitre 03** : ImplÃ©menter BitReg, Register, PC et RAM

ğŸ“š **RÃ©fÃ©rence :** Livre Seed, Chapitre 03 - MÃ©moire
