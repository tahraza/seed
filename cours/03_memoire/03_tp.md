---
marp: true
theme: seed-tp
paginate: true
header: "Seed - TP Chapitre 03"
---

# TP Chapitre 03 : Construction de la MÃ©moire

## Objectifs pratiques

- ImplÃ©menter le registre 1-bit
- Construire un registre multi-bits
- Assembler le compteur de programme
- CrÃ©er une RAM adressable

**DurÃ©e estimÃ©e :** 2h

**PrÃ©requis :** TP Chapitre 01 terminÃ© (Mux, DMux)

---

## PrÃ©paration

### AccÃ¨s au Simulateur

ğŸ‘‰ [Ouvrir le Simulateur HDL](https://seed.music-music.fr/)

Allez dans **HDL Progression** â†’ **Projet 4 : SÃ©quentiel**

**Note :** La DFF est fournie comme primitive.

---

## Exercice 1 : Registre 1-bit (BitReg)

**Objectif :** CrÃ©er une cellule mÃ©moire persistante

### SpÃ©cification

- Si `load = 1` : stocker `d` au prochain front
- Si `load = 0` : conserver la valeur

### SchÃ©ma

```
           â”Œâ”€â”€â”€â”€â”€â”
  d â”€â”€â”€â”€â”€â”€â”€â”¤  1  â”‚
           â”‚ Mux â”œâ”€â”€â”€â”€â”¬â”€â”€â”€ q
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¤  0  â”‚    â”‚
  â”‚   loadâ”€â”¤ sel â”‚    â”‚
  â”‚        â””â”€â”€â”€â”€â”€â”˜    â”‚
  â”‚                   â”‚
  â”‚   â”Œâ”€â”€â”€â”€â”€â”         â”‚
  â””â”€â”€â”€â”¤ DFF â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â””â”€â”€â”€â”€â”€â”˜
```

ğŸ‘‰ [Ouvrir l'exercice BitReg](https://seed.music-music.fr/)

---

### Code Ã  complÃ©ter

```vhdl
entity BitReg is
  port(
    d    : in bit;
    load : in bit;
    q    : out bit
  );
end entity;

architecture rtl of BitReg is
  component Mux port(a,b,sel : in bit; y : out bit); end component;
  component DFF port(d : in bit; q : out bit); end component;
  signal mux_out, dff_out : bit;
begin
  -- TODO: ComplÃ©ter
  -- u_mux: Mux port map (a => ?, b => ?, sel => ?, y => ?);
  -- u_dff: DFF port map (d => ?, q => ?);
  -- q <= ?;
end architecture;
```

<details>
<summary>Solution</summary>

```vhdl
u_mux: Mux port map (a => dff_out, b => d, sel => load, y => mux_out);
u_dff: DFF port map (d => mux_out, q => dff_out);
q <= dff_out;
```

- Si load=0 : Mux sÃ©lectionne a=dff_out (maintien)
- Si load=1 : Mux sÃ©lectionne b=d (nouvelle valeur)

</details>

---

## Exercice 2 : Registre 16-bits

**Objectif :** ParallÃ©liser les BitReg

### SpÃ©cification

- EntrÃ©e : d[15:0], load
- Sortie : q[15:0]
- Tous les bits partagent le mÃªme signal `load`

### Structure

16 instances de BitReg en parallÃ¨le.

ğŸ‘‰ [Ouvrir l'exercice Register16](https://seed.music-music.fr/)

---

### Code

```vhdl
entity Register16 is
  port(
    d    : in bits(15 downto 0);
    load : in bit;
    q    : out bits(15 downto 0)
  );
end entity;

architecture rtl of Register16 is
  component BitReg
    port(d, load : in bit; q : out bit);
  end component;
begin
  u0:  BitReg port map (d => d(0),  load => load, q => q(0));
  u1:  BitReg port map (d => d(1),  load => load, q => q(1));
  u2:  BitReg port map (d => d(2),  load => load, q => q(2));
  u3:  BitReg port map (d => d(3),  load => load, q => q(3));
  u4:  BitReg port map (d => d(4),  load => load, q => q(4));
  u5:  BitReg port map (d => d(5),  load => load, q => q(5));
  u6:  BitReg port map (d => d(6),  load => load, q => q(6));
  u7:  BitReg port map (d => d(7),  load => load, q => q(7));
  u8:  BitReg port map (d => d(8),  load => load, q => q(8));
  u9:  BitReg port map (d => d(9),  load => load, q => q(9));
  u10: BitReg port map (d => d(10), load => load, q => q(10));
  u11: BitReg port map (d => d(11), load => load, q => q(11));
  u12: BitReg port map (d => d(12), load => load, q => q(12));
  u13: BitReg port map (d => d(13), load => load, q => q(13));
  u14: BitReg port map (d => d(14), load => load, q => q(14));
  u15: BitReg port map (d => d(15), load => load, q => q(15));
end architecture;
```

---

## Exercice 3 : Compteur de Programme (PC)

**Objectif :** ImplÃ©menter les 4 modes

### SpÃ©cification

| PrioritÃ© | Mode | Condition | Action |
|:--------:|:-----|:----------|:-------|
| 1 | reset | reset=1 | PC â† 0 |
| 2 | load | load=1 | PC â† in |
| 3 | inc | inc=1 | PC â† PC+1 |
| 4 | hold | sinon | PC â† PC |

ğŸ‘‰ [Ouvrir l'exercice PC](https://seed.music-music.fr/)

---

### Architecture suggÃ©rÃ©e

```
                  in
                   â”‚
              â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
  out â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Adder   â”‚â”€â”€â”€â–º out+1
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                   â”‚
              â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
  out â”€â”€â”€â”€â”€â”€â”€â”€â”¤ Mux inc â”‚â”€â”€â”€â–º val_if_inc
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                   â”‚
         in â”€â”€â”¬â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
              â”‚ Mux loadâ”‚â”€â”€â”€â–º val_if_load
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                   â”‚
          0 â”€â”€â”¬â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
              â”‚Mux resetâ”‚â”€â”€â”€â–º to_reg
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                   â”‚
              â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
              â”‚ Register â”‚
              â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                   â”‚
                  out
```

---

### Code Ã  complÃ©ter

```vhdl
entity PC is
  port(
    in_val : in bits(15 downto 0);
    reset  : in bit;
    load   : in bit;
    inc    : in bit;
    out_val: out bits(15 downto 0)
  );
end entity;

architecture rtl of PC is
  component Register16 port(d : in bits(15 downto 0); load : in bit; q : out bits(15 downto 0)); end component;
  component Inc16 port(a : in bits(15 downto 0); y : out bits(15 downto 0)); end component;
  component Mux16 port(a,b : in bits(15 downto 0); sel : in bit; y : out bits(15 downto 0)); end component;

  signal reg_out, incremented, after_inc, after_load, to_reg : bits(15 downto 0);
  constant ZERO : bits(15 downto 0) := (others => '0');
begin
  -- TODO: ComplÃ©ter
end architecture;
```

---

### Solution PC

<details>
<summary>Solution</summary>

```vhdl
-- IncrÃ©menter la valeur courante
u_inc: Inc16 port map (a => reg_out, y => incremented);

-- Mux inc : si inc=1, prendre incremented, sinon reg_out
u_mux_inc: Mux16 port map (a => reg_out, b => incremented, sel => inc, y => after_inc);

-- Mux load : si load=1, prendre in_val, sinon after_inc
u_mux_load: Mux16 port map (a => after_inc, b => in_val, sel => load, y => after_load);

-- Mux reset : si reset=1, prendre 0, sinon after_load
u_mux_reset: Mux16 port map (a => after_load, b => ZERO, sel => reset, y => to_reg);

-- Registre (toujours load=1 car une des options est toujours choisie)
u_reg: Register16 port map (d => to_reg, load => '1', q => reg_out);

out_val <= reg_out;
```

</details>

---

## Exercice 4 : RAM8

**Objectif :** MÃ©moire de 8 mots

### SpÃ©cification

- 8 mots de 16 bits
- Adresse sur 3 bits
- `load` = 1 : Ã©crire Ã  l'adresse
- Lecture toujours active

### Structure

```
       load    address[2:0]
         â”‚           â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”
    â”‚       DMux8Way         â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚    â”‚        â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”...  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”
    â”‚ Reg0  â”‚     â”‚ Reg7  â”‚ â† in
    â””â”€â”€â”€â”€â”¬â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”˜
         â”‚             â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
    â”‚       Mux8Way16        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                out
```

ğŸ‘‰ [Ouvrir l'exercice RAM8](https://seed.music-music.fr/)

---

### Code Ã  complÃ©ter

```vhdl
entity RAM8 is
  port(
    input   : in bits(15 downto 0);
    address : in bits(2 downto 0);
    load    : in bit;
    output  : out bits(15 downto 0)
  );
end entity;

architecture rtl of RAM8 is
  component Register16 port(d : in bits(15 downto 0); load : in bit; q : out bits(15 downto 0)); end component;
  component DMux8Way port(input, sel : in bit; a,b,c,d,e,f,g,h : out bit); end component;
  component Mux8Way16 port(a,b,c,d,e,f,g,h : in bits(15 downto 0); sel : in bits(2 downto 0); y : out bits(15 downto 0)); end component;

  signal load0,load1,load2,load3,load4,load5,load6,load7 : bit;
  signal r0,r1,r2,r3,r4,r5,r6,r7 : bits(15 downto 0);
begin
  -- TODO: ComplÃ©ter
end architecture;
```

---

### Solution RAM8

<details>
<summary>Solution</summary>

```vhdl
-- DÃ©multiplexer le signal load vers le bon registre
u_dmux: DMux8Way port map (
  input => load, sel => address,
  a => load0, b => load1, c => load2, d => load3,
  e => load4, f => load5, g => load6, h => load7
);

-- Les 8 registres
reg0: Register16 port map (d => input, load => load0, q => r0);
reg1: Register16 port map (d => input, load => load1, q => r1);
reg2: Register16 port map (d => input, load => load2, q => r2);
reg3: Register16 port map (d => input, load => load3, q => r3);
reg4: Register16 port map (d => input, load => load4, q => r4);
reg5: Register16 port map (d => input, load => load5, q => r5);
reg6: Register16 port map (d => input, load => load6, q => r6);
reg7: Register16 port map (d => input, load => load7, q => r7);

-- Multiplexer la sortie
u_mux: Mux8Way16 port map (
  a => r0, b => r1, c => r2, d => r3,
  e => r4, f => r5, g => r6, h => r7,
  sel => address, y => output
);
```

</details>

---

## Exercice 5 : RAM64

**Objectif :** Composition hiÃ©rarchique

### SpÃ©cification

- 64 mots = 8 Ã— RAM8
- Adresse sur 6 bits :
  - `address[5:3]` : quelle RAM8
  - `address[2:0]` : quel mot dans RAM8

ğŸ‘‰ [Ouvrir l'exercice RAM64](https://seed.music-music.fr/)

---

### Code Ã  complÃ©ter

```vhdl
entity RAM64 is
  port(
    input   : in bits(15 downto 0);
    address : in bits(5 downto 0);
    load    : in bit;
    output  : out bits(15 downto 0)
  );
end entity;

architecture rtl of RAM64 is
  component RAM8 port(input : in bits(15 downto 0); address : in bits(2 downto 0); load : in bit; output : out bits(15 downto 0)); end component;
  component DMux8Way port(input : in bit; sel : in bits(2 downto 0); a,b,c,d,e,f,g,h : out bit); end component;
  component Mux8Way16 port(a,b,c,d,e,f,g,h : in bits(15 downto 0); sel : in bits(2 downto 0); y : out bits(15 downto 0)); end component;

  signal load0,load1,load2,load3,load4,load5,load6,load7 : bit;
  signal o0,o1,o2,o3,o4,o5,o6,o7 : bits(15 downto 0);
begin
  -- Bits de poids fort pour sÃ©lectionner la RAM8
  -- Bits de poids faible pour sÃ©lectionner le mot dans la RAM8
  -- TODO: ComplÃ©ter
end architecture;
```

---

### Solution RAM64

<details>
<summary>Solution</summary>

```vhdl
-- DMux sur les bits de poids fort
u_dmux: DMux8Way port map (
  input => load, sel => address(5 downto 3),
  a => load0, b => load1, c => load2, d => load3,
  e => load4, f => load5, g => load6, h => load7
);

-- 8 RAM8, adresse interne = bits de poids faible
ram0: RAM8 port map (input => input, address => address(2 downto 0), load => load0, output => o0);
ram1: RAM8 port map (input => input, address => address(2 downto 0), load => load1, output => o1);
ram2: RAM8 port map (input => input, address => address(2 downto 0), load => load2, output => o2);
ram3: RAM8 port map (input => input, address => address(2 downto 0), load => load3, output => o3);
ram4: RAM8 port map (input => input, address => address(2 downto 0), load => load4, output => o4);
ram5: RAM8 port map (input => input, address => address(2 downto 0), load => load5, output => o5);
ram6: RAM8 port map (input => input, address => address(2 downto 0), load => load6, output => o6);
ram7: RAM8 port map (input => input, address => address(2 downto 0), load => load7, output => o7);

-- Mux sur les bits de poids fort
u_mux: Mux8Way16 port map (
  a => o0, b => o1, c => o2, d => o3,
  e => o4, f => o5, g => o6, h => o7,
  sel => address(5 downto 3), y => output
);
```

</details>

---

## RÃ©capitulatif

### Composants implÃ©mentÃ©s

| Composant | ComplexitÃ© | Utilise |
|:----------|:----------:|:--------|
| BitReg | â­ | Mux, DFF |
| Register16 | â­ | 16Ã— BitReg |
| PC | â­â­ | Register16, Inc16, Mux16 |
| RAM8 | â­â­ | DMux8Way, 8Ã— Register16, Mux8Way16 |
| RAM64 | â­â­ | DMux8Way, 8Ã— RAM8, Mux8Way16 |

---

## Validation Finale

### Checklist

- [ ] BitReg maintient sa valeur quand load=0
- [ ] Register16 capture tous les bits simultanÃ©ment
- [ ] PC respecte les prioritÃ©s (reset > load > inc)
- [ ] RAM8 lit/Ã©crit Ã  la bonne adresse
- [ ] RAM64 dÃ©compose correctement l'adresse

### Prochaine Ã©tape

â¡ï¸ **Chapitre 04 : Architecture Machine** â€” DÃ©finir l'ISA du CPU !

ğŸ“š **RÃ©fÃ©rence :** Livre Seed, Chapitre 03 - MÃ©moire
