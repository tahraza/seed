---
marp: true
theme: seed-td
paginate: true
header: "Seed - TD Chapitre 04"
---

# TD Chapitre 04 : Architecture Machine

## Objectifs

- Comprendre le modÃ¨le RISC Load/Store
- MaÃ®triser les registres et leurs rÃ´les
- Ã‰crire des programmes en assembleur A32
- Utiliser les conditions et branchements

**DurÃ©e estimÃ©e :** 1h30

---

## Exercice 1 : Registres et RÃ´les

**Objectif :** Identifier les registres spÃ©ciaux

### 1.1 Association

Associez chaque registre Ã  son rÃ´le :

| Registre | RÃ´le |
|:---------|:-----|
| R0-R3 | ? |
| R13 (SP) | ? |
| R14 (LR) | ? |
| R15 (PC) | ? |

Choix : Pile, Arguments/Retours, Instruction courante, Adresse de retour

<details>
<summary>Solution</summary>

| Registre | RÃ´le |
|:---------|:-----|
| R0-R3 | **Arguments/Retours** |
| R13 (SP) | **Pile** (Stack Pointer) |
| R14 (LR) | **Adresse de retour** (Link Register) |
| R15 (PC) | **Instruction courante** (Program Counter) |

</details>

---

### 1.2 Question conceptuelle

Pourquoi le PC (R15) est-il accessible comme un registre normal ?

<details>
<summary>Solution</summary>

Cela permet :
- De faire des sauts calculÃ©s : `ADD PC, PC, R0`
- De retourner d'une fonction : `MOV PC, LR`
- De lire l'adresse courante pour du code position-indÃ©pendant

C'est une caractÃ©ristique ARM hÃ©ritÃ©e par nand2c.

</details>

---

## Exercice 2 : Instructions ArithmÃ©tiques

**Objectif :** Ã‰crire des opÃ©rations de base

### 2.1 Traduire en assembleur

Traduisez ces opÃ©rations C en assembleur A32 :

```c
int a = 5;        // R0 = 5
int b = 3;        // R1 = 3
int c = a + b;    // R2 = R0 + R1
int d = c - 1;    // R3 = R2 - 1
```

<details>
<summary>Solution</summary>

```asm
MOV R0, #5        ; a = 5
MOV R1, #3        ; b = 3
ADD R2, R0, R1    ; c = a + b
SUB R3, R2, #1    ; d = c - 1
```

</details>

---

### 2.2 Multiplication

nand2c a une instruction MUL. Traduisez :

```c
int x = 7;        // R0 = 7
int y = 4;        // R1 = 4
int z = x * y;    // R2 = R0 * R1
```

<details>
<summary>Solution</summary>

```asm
MOV R0, #7
MOV R1, #4
MUL R2, R0, R1    ; R2 = 28
```

</details>

---

## Exercice 3 : Load/Store

**Objectif :** Comprendre l'accÃ¨s mÃ©moire RISC

### 3.1 SchÃ©ma Load/Store

ComplÃ©tez le schÃ©ma pour incrÃ©menter une variable en mÃ©moire :

```
MÃ©moire              Registres
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ x = 42  â”‚  LOAD    â”‚ R0 = ?  â”‚
â”‚ addr=100â”‚ â”€â”€â”€â”€â”€â”€â–º  â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          â”‚
                     ADD R0, #1
                          â”‚
                     â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
                     â”‚ R0 = ?  â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  STORE   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ x = ?   â”‚ â—„â”€â”€â”€â”€â”€â”€
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

<details>
<summary>Solution</summary>

1. LOAD : R0 = 42
2. ADD : R0 = 43
3. STORE : x = 43

**Pourquoi 3 Ã©tapes ?** En RISC, on ne peut pas faire `ADD [mem], #1` directement.

</details>

---

### 3.2 Ã‰crire le code

Ã‰crivez le code assembleur pour incrÃ©menter la valeur Ã  l'adresse dans R1 :

<details>
<summary>Solution</summary>

```asm
LDR R0, [R1]      ; Charger depuis adresse R1
ADD R0, R0, #1    ; IncrÃ©menter
STR R0, [R1]      ; Stocker Ã  la mÃªme adresse
```

</details>

---

## Exercice 4 : Conditions et Branchements

**Objectif :** Utiliser CMP et B.cond

### 4.1 Traduire un if-else

Traduisez en assembleur :

```c
if (R0 == R1) {
    R2 = 1;
} else {
    R2 = 0;
}
```

<details>
<summary>Solution</summary>

```asm
CMP R0, R1
B.NE else_branch
MOV R2, #1        ; if branch
B end_if
else_branch:
MOV R2, #0        ; else branch
end_if:
```

**Alternative avec prÃ©dication :**
```asm
CMP R0, R1
MOV.EQ R2, #1     ; Si Ã©gal
MOV.NE R2, #0     ; Si diffÃ©rent
```

</details>

---

### 4.2 Boucle while

Traduisez en assembleur :

```c
int i = 0;        // R0
int sum = 0;      // R1
while (i < 5) {
    sum = sum + i;
    i = i + 1;
}
```

<details>
<summary>Solution</summary>

```asm
MOV R0, #0        ; i = 0
MOV R1, #0        ; sum = 0

loop:
CMP R0, #5
B.GE end_loop     ; si i >= 5, sortir
ADD R1, R1, R0    ; sum += i
ADD R0, R0, #1    ; i++
B loop

end_loop:
; R1 contient sum = 0+1+2+3+4 = 10
```

</details>

---

## Exercice 5 : Codes de Condition

**Objectif :** Choisir le bon code de condition

### 5.1 SignÃ© vs Non-signÃ©

AprÃ¨s `CMP R0, R1`, quel code utiliser ?

| Situation | SignÃ© | Non-signÃ© |
|:----------|:------|:----------|
| R0 < R1 | ? | ? |
| R0 >= R1 | ? | ? |
| R0 == R1 | ? | ? |

<details>
<summary>Solution</summary>

| Situation | SignÃ© | Non-signÃ© |
|:----------|:------|:----------|
| R0 < R1 | **LT** (Nâ‰ V) | **LO** ou **CC** (C=0) |
| R0 >= R1 | **GE** (N=V) | **HS** ou **CS** (C=1) |
| R0 == R1 | **EQ** (Z=1) | **EQ** (Z=1) |

**Important :** Utiliser LT/GE pour signÃ©, LO/HS pour non-signÃ© !

</details>

---

### 5.2 PiÃ¨ge des comparaisons

R0 = 0xFFFFFFFF, R1 = 0x00000001

AprÃ¨s `CMP R0, R1` :

- En **signÃ©** : R0 < R1 ? (car -1 < 1)
- En **non-signÃ©** : R0 > R1 ? (car 4294967295 > 1)

Quel branchement est pris : B.LT ou B.HI ?

<details>
<summary>Solution</summary>

- **B.LT est pris** : Car en signÃ©, -1 < 1 (Nâ‰ V)
- **B.HI est pris** : Car en non-signÃ©, 0xFFFFFFFF > 1 (C=1, Z=0)

**Les deux sont vrais !** C'est le programmeur qui choisit l'interprÃ©tation.

</details>

---

## Exercice 6 : Fonctions

**Objectif :** Utiliser BL et le retour

### 6.1 Appel simple

ComplÃ©tez le code pour appeler `double_val` qui multiplie R0 par 2 :

```asm
main:
    MOV R0, #5
    ; Appeler double_val
    ; ...
    ; Ici R0 devrait valoir 10
    HALT

double_val:
    ADD R0, R0, R0    ; R0 = R0 * 2
    ; Retourner
    ; ...
```

<details>
<summary>Solution</summary>

```asm
main:
    MOV R0, #5
    BL double_val     ; Appel, LR = adresse retour
    HALT              ; R0 = 10

double_val:
    ADD R0, R0, R0
    MOV PC, LR        ; Retour
```

</details>

---

### 6.2 Sauvegarder LR

Si `func_a` appelle `func_b`, que se passe-t-il avec LR ?

<details>
<summary>Solution</summary>

**ProblÃ¨me :** `BL func_b` Ã©crase LR !

**Solution :** Sauvegarder LR sur la pile :

```asm
func_a:
    SUB SP, SP, #4    ; Push LR
    STR LR, [SP]

    BL func_b         ; Appel (Ã©crase LR)

    LDR LR, [SP]      ; Pop LR
    ADD SP, SP, #4
    MOV PC, LR        ; Retour correct
```

</details>

---

## Exercice 7 : MMIO

**Objectif :** AccÃ©der aux pÃ©riphÃ©riques

### 7.1 Allumer un pixel

L'Ã©cran commence Ã  `0x00400000`. Chaque bit = 1 pixel.

Pour allumer le pixel (0, 0) :

```asm
; Ã€ complÃ©ter
LDR R0, =?         ; Adresse Ã©cran
MOV R1, #?         ; Bit 7 = premier pixel
STRB R1, [R0]
```

<details>
<summary>Solution</summary>

```asm
LDR R0, =0x00400000  ; Adresse de l'Ã©cran
MOV R1, #0x80        ; 0x80 = 10000000 (bit 7)
STRB R1, [R0]        ; Ã‰crire l'octet
```

Le bit 7 de l'octet 0 correspond au pixel (0,0).

</details>

---

### 7.2 Lire le clavier

Le clavier est Ã  `0x00402600`. Comment lire la touche pressÃ©e ?

<details>
<summary>Solution</summary>

```asm
LDR R0, =0x00402600  ; Adresse clavier
LDR R1, [R0]         ; Lire le code ASCII
CMP R1, #0           ; 0 = pas de touche
B.EQ no_key
; R1 contient le code ASCII
no_key:
```

</details>

---

## RÃ©capitulatif

### CompÃ©tences validÃ©es

AprÃ¨s ce TD, vous devez savoir :

- [ ] Identifier les registres spÃ©ciaux (SP, LR, PC)
- [ ] Ã‰crire des opÃ©rations arithmÃ©tiques en A32
- [ ] Utiliser le modÃ¨le Load/Store
- [ ] Choisir le bon code de condition
- [ ] Appeler une fonction avec BL et retourner

### Prochaine Ã©tape

â¡ï¸ **TP Chapitre 04** : Programmer sur le simulateur A32

ğŸ“š **RÃ©fÃ©rence :** Livre Seed, Chapitre 04 - Architecture
