---
marp: true
theme: seed-td
paginate: true
header: "Seed - TD Chapitre 06"
---

# TD Chapitre 06 : L'Assembleur

## Objectifs

- Comprendre les deux passes de l'assembleur
- Construire une table des symboles
- Encoder des instructions manuellement
- Utiliser les directives et le literal pool

**Durée estimée :** 1h30

---

## Exercice 1 : Les Deux Passes

**Objectif :** Comprendre pourquoi deux passes sont nécessaires

### 1.1 Analyse du problème

Analysez ce code :

```asm
    B end
    MOV R0, #1
    ADD R0, R0, #2
end:
    HALT
```

Pourquoi l'assembleur ne peut-il pas traduire `B end` en un seul passage ?

<details>
<summary>Solution</summary>

À la première ligne, l'assembleur ne connaît pas encore l'adresse de `end`.
Le label `end` est défini **après** son utilisation (référence vers l'avant).

L'assembleur doit d'abord parcourir tout le fichier pour collecter les adresses.

</details>

---

### 1.2 Table des symboles

Construisez la table des symboles pour ce code :

```asm
.text
start:
    MOV R0, #0
loop:
    ADD R0, R0, #1
    CMP R0, #10
    B.LT loop
end:
    HALT
```

Rappel : Chaque instruction fait 4 octets. Adresse de départ = 0x0000.

<details>
<summary>Solution</summary>

| Symbole | Adresse |
|:--------|:--------|
| start | 0x0000 |
| loop | 0x0004 |
| end | 0x0014 |

Calcul :
- start: 0x0000 (début)
- loop: 0x0004 (après MOV)
- end: après MOV + ADD + CMP + B.LT = 4 × 4 = 16 = 0x0010... non, 5 instructions = 0x0014

Correction : start(0) → MOV(4) → loop(4) → ADD(8) → CMP(12) → B.LT(16) → end(20=0x14)

| Symbole | Adresse |
|:--------|:--------|
| start | 0x0000 |
| loop | 0x0004 |
| end | 0x0014 |

</details>

---

## Exercice 2 : Encodage d'Instructions

**Objectif :** Encoder des instructions en binaire

### 2.1 Format ALU avec immédiat

Encodez `ADD R1, R2, #10` en binaire.

Format : `[cond:4][001][opcode:4][S:1][Rn:4][Rd:4][imm12:12]`

| Champ | Valeur |
|:------|:-------|
| cond | 1110 (AL) |
| class | 001 (imm) |
| opcode | 0100 (ADD) |
| S | ? |
| Rn | ? |
| Rd | ? |
| imm12 | ? |

<details>
<summary>Solution</summary>

| Champ | Valeur | Binaire |
|:------|:-------|:--------|
| cond | AL | 1110 |
| class | imm | 001 |
| opcode | ADD | 0100 |
| S | 0 | 0 |
| Rn | R2 | 0010 |
| Rd | R1 | 0001 |
| imm12 | 10 | 0000 0000 1010 |

Binaire complet : `1110 001 0100 0 0010 0001 0000 0000 1010`

Hex : `0xE2821010`

</details>

---

### 2.2 Format ALU avec registre

Encodez `SUB R3, R4, R5` en binaire.

Format : `[cond:4][000][opcode:4][S:1][Rn:4][Rd:4][00000000][Rm:4]`

<details>
<summary>Solution</summary>

| Champ | Valeur | Binaire |
|:------|:-------|:--------|
| cond | AL | 1110 |
| class | reg | 000 |
| opcode | SUB | 0010 |
| S | 0 | 0 |
| Rn | R4 | 0100 |
| Rd | R3 | 0011 |
| padding | - | 0000 0000 |
| Rm | R5 | 0101 |

Binaire : `1110 000 0010 0 0100 0011 0000 0000 0101`

Hex : `0xE0443005`

</details>

---

### 2.3 MOV avec immédiat

Encodez `MOV R0, #255` en binaire.

Indice : MOV utilise opcode 1101 et Rn = 0000.

<details>
<summary>Solution</summary>

| Champ | Valeur | Binaire |
|:------|:-------|:--------|
| cond | AL | 1110 |
| class | imm | 001 |
| opcode | MOV | 1101 |
| S | 0 | 0 |
| Rn | - | 0000 |
| Rd | R0 | 0000 |
| imm12 | 255 | 0000 1111 1111 |

Binaire : `1110 001 1101 0 0000 0000 0000 1111 1111`

Hex : `0xE3A000FF`

</details>

---

## Exercice 3 : Branchements

**Objectif :** Calculer les offsets de branchement

### 3.1 Offset de branchement

Pour ce code :

```
0x0000: B loop
0x0004: ADD R0, R0, #1
0x0008: loop:
0x0008: SUB R1, R1, #1
```

Calculez l'offset encodé dans `B loop`.

Rappel : offset = (cible - PC - 8) / 4

<details>
<summary>Solution</summary>

- Adresse de B : 0x0000
- PC pendant Fetch : 0x0000
- Pipeline : PC + 8 = 0x0008
- Cible (loop) : 0x0008

offset = (0x0008 - 0x0000 - 8) / 4 = 0 / 4 = **0**

L'offset encodé est 0 (l'instruction est juste après le décalage pipeline).

</details>

---

### 3.2 Branchement arrière

Pour ce code :

```
0x0000: loop:
0x0000: ADD R0, R0, #1
0x0004: CMP R0, #10
0x0008: B.LT loop
```

Calculez l'offset encodé dans `B.LT loop`.

<details>
<summary>Solution</summary>

- Adresse de B.LT : 0x0008
- PC + 8 : 0x0008 + 8 = 0x0010
- Cible (loop) : 0x0000

offset = (0x0000 - 0x0008 - 8) / 4 = -16 / 4 = **-4**

En complément à deux sur 24 bits : 0xFFFFFC

</details>

---

## Exercice 4 : Directives

**Objectif :** Comprendre les directives d'assemblage

### 4.1 Section .data

Quelle est la taille et le contenu en mémoire de :

```asm
.data
x:      .word 42
y:      .word 0x1234
msg:    .asciz "Hi"
```

<details>
<summary>Solution</summary>

| Symbole | Adresse | Taille | Contenu (hex) |
|:--------|:--------|:-------|:--------------|
| x | 0x0000 | 4 | 0x0000002A |
| y | 0x0004 | 4 | 0x00001234 |
| msg | 0x0008 | 3 | 0x48, 0x69, 0x00 ("Hi\0") |

Taille totale : 11 octets

</details>

---

### 4.2 Alignement

Pourquoi `.align 2` est-il important après une chaîne ?

```asm
.data
msg:    .asciz "A"
        .align 2
val:    .word 123
```

<details>
<summary>Solution</summary>

- `msg` occupe 2 octets ("A" + '\0')
- Sans alignement, `val` serait à l'adresse 0x0002
- Une lecture `.word` à une adresse non alignée sur 4 peut :
  - Être interdite (erreur)
  - Être très lente

`.align 2` force l'adresse suivante à être un multiple de 4 (2² = 4).

</details>

---

## Exercice 5 : Literal Pool

**Objectif :** Comprendre le mécanisme des grandes constantes

### 5.1 Pseudo-instruction

Que génère l'assembleur pour :

```asm
    LDR R0, =0xDEADBEEF
    ADD R0, R0, #1
    HALT
```

<details>
<summary>Solution</summary>

L'assembleur génère :

```
0x0000: LDR R0, [PC, #4]    ; PC+8+4 = 0x000C
0x0004: ADD R0, R0, #1
0x0008: HALT
0x000C: 0xDEADBEEF          ; Literal pool
```

La valeur 32 bits est stockée après le code et chargée via PC-relative.

</details>

---

### 5.2 Quand utiliser =

Pour chaque cas, indiquez si `=` est nécessaire :

| Instruction | = nécessaire ? |
|:------------|:---------------|
| `MOV R0, #10` | ? |
| `MOV R0, #1000` | ? |
| `LDR R0, =0xFFFFFFFF` | ? |
| `ADD R1, R1, #255` | ? |

<details>
<summary>Solution</summary>

| Instruction | = nécessaire ? | Raison |
|:------------|:---------------|:-------|
| `MOV R0, #10` | Non | 10 tient sur 12 bits |
| `MOV R0, #1000` | Non | 1000 < 4096, OK |
| `LDR R0, =0xFFFFFFFF` | **Oui** | 32 bits, trop grand |
| `ADD R1, R1, #255` | Non | 255 < 4096, OK |

</details>

---

## Exercice 6 : Programme Complet

**Objectif :** Analyser un programme assembleur complet

### Code

```asm
.text
.global _start
_start:
    LDR R0, =array      ; Adresse du tableau
    MOV R1, #0          ; Somme
    MOV R2, #5          ; Compteur
loop:
    LDR R3, [R0]        ; Charger élément
    ADD R1, R1, R3      ; Ajouter à la somme
    ADD R0, R0, #4      ; Élément suivant
    SUB R2, R2, #1      ; Décrémenter compteur
    CMP R2, #0
    B.NE loop
    HALT

.data
array:  .word 1, 2, 3, 4, 5
```

---

### Questions

1. Combien d'instructions dans `.text` ?
2. Quelle est la table des symboles ?
3. Que vaut R1 à la fin ?

<details>
<summary>Solution</summary>

1. **11 instructions** (LDR, MOV, MOV, LDR, ADD, ADD, SUB, CMP, B.NE, HALT + la pseudo-instruction LDR R0, =array)

2. Table des symboles :
   - _start: 0x0000
   - loop: 0x000C
   - array: 0x002C (après 11 instructions = 44 octets)

3. **R1 = 15** (somme de 1+2+3+4+5)

</details>

---

## Récapitulatif

### Compétences validées

- [ ] Expliquer les deux passes de l'assembleur
- [ ] Construire une table des symboles
- [ ] Encoder une instruction en binaire
- [ ] Calculer un offset de branchement
- [ ] Utiliser les directives et le literal pool

### Prochaine étape

**TP Chapitre 06** : Utiliser l'assembleur sur le simulateur web

Référence : Livre Seed, Chapitre 06 - Assembleur

