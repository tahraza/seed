---
marp: true
theme: seed-td
paginate: true
header: "Seed - TD Chapitre 01"
---

# TD Chapitre 01 : Logique Bool√©enne

## Objectifs

- Ma√Ætriser les tables de v√©rit√©
- Construire des portes √† partir de NAND
- Appliquer les lois de De Morgan
- Comprendre le Mux et le DMux

**Dur√©e estim√©e :** 1h30

---

## Exercice 1 : Tables de V√©rit√© (√âchauffement)

**Objectif :** Remplir des tables de v√©rit√© √† partir des d√©finitions

### 1.1 Table de la porte NAND

Compl√©tez la table de v√©rit√© de NAND(A, B) :

| A | B | NAND |
|---|---|:----:|
| 0 | 0 | ? |
| 0 | 1 | ? |
| 1 | 0 | ? |
| 1 | 1 | ? |

<details>
<summary>Solution</summary>

| A | B | NAND |
|---|---|:----:|
| 0 | 0 | **1** |
| 0 | 1 | **1** |
| 1 | 0 | **1** |
| 1 | 1 | **0** |

**R√®gle :** NAND = 0 uniquement si A ET B sont √† 1.

</details>

---

### 1.2 Table de la porte XOR

Compl√©tez la table de v√©rit√© de XOR(A, B) :

| A | B | XOR |
|---|---|:---:|
| 0 | 0 | ? |
| 0 | 1 | ? |
| 1 | 0 | ? |
| 1 | 1 | ? |

<details>
<summary>Solution</summary>

| A | B | XOR |
|---|---|:---:|
| 0 | 0 | **0** |
| 0 | 1 | **1** |
| 1 | 0 | **1** |
| 1 | 1 | **0** |

**R√®gle :** XOR = 1 si les entr√©es sont **diff√©rentes**.

</details>

---

## Exercice 2 : Construction √† partir de NAND

**Objectif :** Prouver que NAND est universel

### 2.1 Construire NOT

Comment construire un NOT en utilisant uniquement une porte NAND ?

**Indice :** Que se passe-t-il si on connecte le m√™me signal aux deux entr√©es ?

<details>
<summary>Solution</summary>

```
NOT(A) = NAND(A, A)
```

**V√©rification :**
- Si A = 0 : NAND(0, 0) = 1 ‚úì
- Si A = 1 : NAND(1, 1) = 0 ‚úì

</details>

---

### 2.2 Construire AND

Comment construire un AND en utilisant NOT et NAND ?

**Indice :** NAND = NOT(AND), donc AND = NOT(NAND)

<details>
<summary>Solution</summary>

```
AND(A, B) = NOT(NAND(A, B))
         = NAND(NAND(A, B), NAND(A, B))
```

En utilisant 2 portes NAND :
1. `w = NAND(A, B)`
2. `out = NAND(w, w)`

</details>

---

### 2.3 Construire OR (Th√©or√®me de De Morgan)

En utilisant le th√©or√®me de De Morgan :
```
A OR B = NOT(NOT(A) AND NOT(B))
```

√âcrivez OR uniquement avec des NAND.

<details>
<summary>Solution</summary>

```
OR(A, B) = NAND(NOT(A), NOT(B))
         = NAND(NAND(A, A), NAND(B, B))
```

En utilisant 3 portes NAND :
1. `not_a = NAND(A, A)`
2. `not_b = NAND(B, B)`
3. `out = NAND(not_a, not_b)`

</details>

---

## Exercice 3 : Lois de De Morgan

**Objectif :** Appliquer les lois de De Morgan

### Rappel des lois

```
1. NOT(A AND B) = NOT(A) OR NOT(B)
2. NOT(A OR B)  = NOT(A) AND NOT(B)
```

### 3.1 Simplification

Simplifiez l'expression suivante en utilisant De Morgan :

```
NOT(NOT(A) AND NOT(B))
```

<details>
<summary>Solution</summary>

En appliquant De Morgan (loi 1 invers√©e) :

```
NOT(NOT(A) AND NOT(B)) = NOT(NOT(A)) OR NOT(NOT(B))
                       = A OR B
```

</details>

---

### 3.2 V√©rification par table de v√©rit√©

V√©rifiez que `NOT(A OR B) = NOT(A) AND NOT(B)` :

| A | B | A OR B | NOT(A OR B) | NOT(A) | NOT(B) | NOT(A) AND NOT(B) |
|---|---|:------:|:-----------:|:------:|:------:|:-----------------:|
| 0 | 0 | ? | ? | ? | ? | ? |
| 0 | 1 | ? | ? | ? | ? | ? |
| 1 | 0 | ? | ? | ? | ? | ? |
| 1 | 1 | ? | ? | ? | ? | ? |

<details>
<summary>Solution</summary>

| A | B | A OR B | NOT(A OR B) | NOT(A) | NOT(B) | NOT(A) AND NOT(B) |
|---|---|:------:|:-----------:|:------:|:------:|:-----------------:|
| 0 | 0 | 0 | **1** | 1 | 1 | **1** |
| 0 | 1 | 1 | **0** | 1 | 0 | **0** |
| 1 | 0 | 1 | **0** | 0 | 1 | **0** |
| 1 | 1 | 1 | **0** | 0 | 0 | **0** |

Les colonnes `NOT(A OR B)` et `NOT(A) AND NOT(B)` sont identiques. ‚úì

</details>

---

## Exercice 4 : Multiplexeur (Mux)

**Objectif :** Comprendre le fonctionnement du Mux

### 4.1 Table de v√©rit√© du Mux

Compl√©tez la table de v√©rit√© pour `Mux(a, b, sel)` :

| a | b | sel | out |
|---|---|:---:|:---:|
| 0 | 0 | 0 | ? |
| 0 | 1 | 0 | ? |
| 1 | 0 | 0 | ? |
| 1 | 1 | 0 | ? |
| 0 | 0 | 1 | ? |
| 0 | 1 | 1 | ? |
| 1 | 0 | 1 | ? |
| 1 | 1 | 1 | ? |

<details>
<summary>Solution</summary>

| a | b | sel | out |
|---|---|:---:|:---:|
| 0 | 0 | 0 | **0** (= a) |
| 0 | 1 | 0 | **0** (= a) |
| 1 | 0 | 0 | **1** (= a) |
| 1 | 1 | 0 | **1** (= a) |
| 0 | 0 | 1 | **0** (= b) |
| 0 | 1 | 1 | **1** (= b) |
| 1 | 0 | 1 | **0** (= b) |
| 1 | 1 | 1 | **1** (= b) |

**R√®gle :** Si sel=0, out=a. Si sel=1, out=b.

</details>

---

### 4.2 Formule du Mux

Exprimez la sortie du Mux en fonction de a, b et sel :

```
out = ?
```

**Indice :** "Soit (a ET non-sel) soit (b ET sel)"

<details>
<summary>Solution</summary>

```
out = (a AND NOT(sel)) OR (b AND sel)
```

- Si sel=0 : out = (a AND 1) OR (b AND 0) = a
- Si sel=1 : out = (a AND 0) OR (b AND 1) = b

</details>

---

## Exercice 5 : D√©multiplexeur (DMux)

**Objectif :** Comprendre le routage avec DMux

### 5.1 Table de v√©rit√© du DMux

Le DMux a une entr√©e `in`, un s√©lecteur `sel`, et deux sorties `a` et `b`.

Compl√©tez la table :

| in | sel | a | b |
|:--:|:---:|:-:|:-:|
| 0 | 0 | ? | ? |
| 1 | 0 | ? | ? |
| 0 | 1 | ? | ? |
| 1 | 1 | ? | ? |

<details>
<summary>Solution</summary>

| in | sel | a | b |
|:--:|:---:|:-:|:-:|
| 0 | 0 | **0** | **0** |
| 1 | 0 | **1** | **0** |
| 0 | 1 | **0** | **0** |
| 1 | 1 | **0** | **1** |

**R√®gle :** Si sel=0, le signal va vers a. Si sel=1, vers b.

</details>

---

### 5.2 Formules du DMux

Exprimez les sorties a et b :

```
a = ?
b = ?
```

<details>
<summary>Solution</summary>

```
a = in AND NOT(sel)
b = in AND sel
```

Le signal `in` est dirig√© vers `a` ou `b` selon la valeur de `sel`.

</details>

---

## Exercice 6 : Fonction Myst√®re

**Objectif :** Analyser un circuit √† partir de sa description

### √ânonc√©

On a le circuit suivant :
```
w1 = NOT(A)
w2 = NOT(B)
w3 = AND(w1, B)
w4 = AND(A, w2)
out = OR(w3, w4)
```

### 6.1 Compl√©tez la table de v√©rit√©

| A | B | w1 | w2 | w3 | w4 | out |
|---|---|:--:|:--:|:--:|:--:|:---:|
| 0 | 0 | ? | ? | ? | ? | ? |
| 0 | 1 | ? | ? | ? | ? | ? |
| 1 | 0 | ? | ? | ? | ? | ? |
| 1 | 1 | ? | ? | ? | ? | ? |

### 6.2 Quelle porte connue ce circuit impl√©mente-t-il ?

<details>
<summary>Solution</summary>

| A | B | w1 | w2 | w3 | w4 | out |
|---|---|:--:|:--:|:--:|:--:|:---:|
| 0 | 0 | 1 | 1 | 0 | 0 | **0** |
| 0 | 1 | 1 | 0 | 1 | 0 | **1** |
| 1 | 0 | 0 | 1 | 0 | 1 | **1** |
| 1 | 1 | 0 | 0 | 0 | 0 | **0** |

C'est la porte **XOR** !

La formule `(NOT(A) AND B) OR (A AND NOT(B))` est exactement la d√©finition de XOR.

</details>

---

## Exercice 7 : D√©fi - Porte IMPLIES

**Objectif :** Construire une nouvelle porte

L'implication logique `A ‚Üí B` (si A alors B) vaut FAUX uniquement si A=1 et B=0 :

| A | B | A ‚Üí B |
|---|---|:-----:|
| 0 | 0 | 1 |
| 0 | 1 | 1 |
| 1 | 0 | 0 |
| 1 | 1 | 1 |

Construisez cette porte avec NOT et OR.

<details>
<summary>Solution</summary>

```
IMPLIES(A, B) = NOT(A) OR B
```

**V√©rification :**
- A=0, B=0 : NOT(0) OR 0 = 1 OR 0 = 1 ‚úì
- A=0, B=1 : NOT(0) OR 1 = 1 OR 1 = 1 ‚úì
- A=1, B=0 : NOT(1) OR 0 = 0 OR 0 = 0 ‚úì
- A=1, B=1 : NOT(1) OR 1 = 0 OR 1 = 1 ‚úì

</details>

---

## R√©capitulatif

### Comp√©tences valid√©es

Apr√®s ce TD, vous devez savoir :

- [ ] Remplir une table de v√©rit√© pour toute porte
- [ ] Construire NOT, AND, OR √† partir de NAND
- [ ] Appliquer les lois de De Morgan
- [ ] Expliquer le fonctionnement du Mux et DMux
- [ ] Analyser un circuit et identifier sa fonction

### Prochaine √©tape

‚û°Ô∏è **TP Chapitre 01** : Impl√©menter ces portes en HDL dans le simulateur

üìö **R√©f√©rence :** Livre Seed, Chapitre 01 - Logique Bool√©enne
